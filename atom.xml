<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep getting better</title>
  
  <subtitle>好记性不如烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaohuming.com/"/>
  <updated>2020-02-23T04:51:20.316Z</updated>
  <id>http://liaohuming.com/</id>
  
  <author>
    <name>廖祜明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Definition of kinds of boundary conditions</title>
    <link href="http://liaohuming.com/2020/02/23/notes/20200223-Definition%20of%20kinds%20of%20boundary%20conditions/"/>
    <id>http://liaohuming.com/2020/02/23/notes/20200223-Definition of kinds of boundary conditions/</id>
    <published>2020-02-23T04:37:01.000Z</published>
    <updated>2020-02-23T04:51:20.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Boundary-conditions"><a href="#1-Boundary-conditions" class="headerlink" title="1. Boundary conditions"></a>1. Boundary conditions</h3><p>There are many type of boundary conditions, most widely used are <strong>Natural</strong> boundary conditions, <strong>Essential</strong> boundary conditions, <strong>Dirichlet</strong> boundary conditions and <strong>Neumann</strong> boundary conditions. In a boundary value problem, what’s the difference between Essential boundary condition and Natural boundary conditions?</p><p>The two types of boundary conditions are used:</p><ul><li>Essential or geometric boundary conditions which are imposed on the primary variable like displacements, and</li><li>Natural or force boundary conditions which are imposed on the secondary variable like forces and tractions.</li></ul><p>Essential boundary conditions are conditions that are imposed explicitly on the solution and natural boundary conditions are those that automatically will be satisfied after solution of the problem. In the case of Finite Element approximations, the essential conditions will be exactly satisfied but the natural conditions only up to the order of the method. In many cases, the essential conditions correspond to Dirichlet boundary conditions when the problem is written as a boundary value problem for a partial differential equation. The natural condition corresponds to a Neumann condition, a stress-free condition, or something similar, depending on the problem. However, there are cases that are not so clear cut, so to identify $Dirichlet=essential$ and $Neumann=natural$ is not really correct. For instance, Dirichlet conditions can be assigned as natural conditions using Nitsche’s method, and Neumann conditions can be transformed to essential conditions using so-called mixed methods.</p><p>E.g. I am looking at the Ritz method for the following problem<br>$$<br>    -\frac{d^{2}u}{dx^{2}}-u+x^{2}=0, 0&lt;x&lt;1<br>$$<br>with boundary conditions $u(0)=0$ and $\displaystyle\frac{du}{dx}\mid_{x=1}=1$. </p><p>The last derivative term, how do I know whether that is a natural or essential BC? I have googled the following guidelines but I am still confused. Specification of the primary variable ($u$ in this case) is an essential BC. Specification of a secondary variable (like a force $F$, not present in this example) is a natural boundary condition. If a boundary condition involves one or more variables in a \textbf{direct} way it is essential otherwise it is natural. Direct implies excluding derivative of the primary function.</p><p>As I understand the difference: what is meant is that direct gives an expression that yields a definite value for (in this case) $u$. </p><p>For example,<br>$$<br>    u(0) = 0,<br>$$<br>says that at $x=0$ the value of $u$ is $0$. This is contrasted by natural expression which does not lead to a definite value of $u$.</p><p>For example,<br>$$<br>    \left[ \frac{du}{dx}\right]_{x=1}=1,<br>$$<br>does not yield a definite value for $u$ at $x = 1$ since a curve of slope $1$ can be drawn through any value of $u$.</p><h3 id="2-Local-Maximum-Entropy-shape-function"><a href="#2-Local-Maximum-Entropy-shape-function" class="headerlink" title="2. Local Maximum Entropy shape function"></a>2. Local Maximum Entropy shape function</h3><p>The Local Maximum Entropy shape function have a weak Kronecker-delta property at the boundary. Here the weak Kronecker-delta property at the boudary means at the boundary, the shape function value of a specified point equal to $1$ and the shape function values of other points equal to $0$. This property ensures that the values of the peformance function equal to what they should be (as user defined or as the engineering deifined) at the boundary. This is essential boundary condition/Dirichlet. So we say LME shape function enalbes the direct imposition of boundary conditions and furnishes automatic compatibility between fluids and solids or structures.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Boundary-conditions&quot;&gt;&lt;a href=&quot;#1-Boundary-conditions&quot; class=&quot;headerlink&quot; title=&quot;1. Boundary conditions&quot;&gt;&lt;/a&gt;1. Boundary conditions
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows系统下采用命令行编译C++ MPI程序</title>
    <link href="http://liaohuming.com/2020/02/22/notes/20200222-Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%87%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91C++%20MPI%E7%A8%8B%E5%BA%8F/"/>
    <id>http://liaohuming.com/2020/02/22/notes/20200222-Windows系统下采用命令行编译C++ MPI程序/</id>
    <published>2020-02-22T12:34:05.000Z</published>
    <updated>2020-02-22T14:31:07.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-目的"><a href="#一-目的" class="headerlink" title="一. 目的"></a>一. 目的</h3><p>目标程序比较大，之前主要是在Liunx下进行程序的开发、编译与使用，现在想在Windows下进行开发、编译与使用。为了实现跨平台，程序的编译过程不宜采用Visual Studio IDE建立的Solution进行编译，否则更换编译器时，VS的Soultion就用不了了。</p><p>理想的方式是自己编写程序编译的脚本文件，采用命令行编译的方式，程序使用的开发语言是C++，并采用MPI进行并行化。为此，本文记录如何在Windows系统下采用命令行编译C++ MPI程序。</p><h3 id="二-C-编译过程"><a href="#二-C-编译过程" class="headerlink" title="二. C++ 编译过程"></a>二. <a href="https://blog.csdn.net/leonliu06/article/details/78229534" target="_blank" rel="noopener">C++ 编译过程</a></h3><p>一般而言，对于 C++ 程序编译有以下4个阶段：</p><p><strong>预处理（preprocessing）</strong><br>对源程序中的伪指令（以#开头的指令）和特殊符号进行处理。伪指令包括宏定义、条件编译指令、头文件包含指令等。</p><p><strong>编译（compilation）</strong><br>将预处理后的文件编译生成后缀为.s的汇编语言文件，。编译程序所要做的工作是通过记法分析和语法分析，在确认所有指令都符合语法规则后，将其翻译成等价的中间代码或汇编代码。</p><p><strong>汇编（assembly）</strong><br>将汇编文件汇编生成后缀为.o的目标文件（二进制）。汇编过程实际上是指把汇编语言代码翻译成目标机器指令的过程。</p><p><strong>链接（linking）</strong><br>将多个目标文件和库连接生成后缀为.out或.exe的可执行文件。链接程序的主要工作就是将有关的目标文件彼此相连接，即将在一个文件中引用的符号现该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><p><strong>链接处理</strong><br>静态链接（static linking）:指链接器在链接时将库（静态库）的内容拷贝到可执行程序中。<br>动态链接（dynamic linking）:指程序运行时才将库（动态链接库）连接到程序中。</p><h3 id="三-环境"><a href="#三-环境" class="headerlink" title="三. 环境"></a>三. 环境</h3><ol><li>Windows 10 操作系统</li><li>安装Visual Studio Professional 2017</li><li>安装MSMPI，安装路径为：<code>D:\Program Files (x86)</code></li><li>目标程序版本：x64</li></ol><h3 id="四-编译方法"><a href="#四-编译方法" class="headerlink" title="四. 编译方法"></a>四. 编译方法</h3><ol><li>方法一：Visual Studio Professional 2017 IDE环境下的编译，详见<a href="https://blog.csdn.net/hsajas/article/details/80103414" target="_blank" rel="noopener">VS2017配置MPI</a>文章介绍</li><li>方法二：命令行编译C++ MPI程序。参考：<a href="https://stackoverflow.com/questions/50195657/how-to-compile-and-run-c-c-mpi-codes-in-cmd-on-windows-without-visual-studio" target="_blank" rel="noopener">How to compile and run C/C++ MPI codes in cmd on windows without Visual Studio</a></li></ol><p>具体步骤为：</p><ol><li><p>建立一个简单的mpi c++代码，如：MpiHelloWorld.cpp，并保存，例如：E:\Desktop\MPI_Test\MpiHelloWorld.cpp，接下来就采用命令行对此源代码进行编译</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#include<span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> myid, numprocs;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Init</span>(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(<span class="built_in">MPI_COMM_WORLD</span>, &amp;myid);</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(<span class="built_in">MPI_COMM_WORLD</span>, &amp;numprocs);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%d Hello world from process %d \n"</span>, numprocs, myid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开开始菜单中的<code>x64 Native Tools Command Prompt for VS 2017</code>工具，用vs自带的命令行工具，可以方便地调用cl.exe和link.exe，如果不想用vs自带的命令行工具，也可以使用windows原始的cmd命令行工具，不过这种情况下需要自己手动定义好vs的引用目录和库文件目录的环境变量。此处采用的是vs提供的命令行工具。<br><img src="/img/20200222-1.jpg" alt=""></p></li><li><p>切换至MpiHelloWorld.cpp文件所在目录</p></li></ol><p>首先编译，在该目录下执行以下命令：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl -I"D:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft SDKs<span class="symbol">\M</span>PI<span class="symbol">\I</span>nclude" -I"D:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft SDKs<span class="symbol">\M</span>PI<span class="symbol">\I</span>nclude<span class="symbol">\x</span>64" -c MPIHelloWorld.cpp</span><br></pre></td></tr></table></figure></p><p>其中，cl为cl.exe编译器，-I（大写的i）表示指定第一个寻找头文件的目录（如果指定多个目录，则使用多个-I），在本例中要将MPI的两个Include目录包含进去。-c表示只编译不链接。编译完之后可以看到当前目录下生成了MPIHelloWorld.obj汇编文件<br><img src="/img/20200222-2.jpg" alt=""></p><p>然后链接，在该目录下执行以下命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">link</span> <span class="selector-tag">-machine</span><span class="selector-pseudo">:x64</span> <span class="selector-tag">-out</span><span class="selector-pseudo">:MpiHelloWorld.exe</span> <span class="selector-tag">-dynamicbase</span> "<span class="selector-tag">msmpi</span><span class="selector-class">.lib</span>" <span class="selector-tag">-libpath</span><span class="selector-pseudo">:"D</span>:\<span class="selector-tag">Program</span> <span class="selector-tag">Files</span> (<span class="selector-tag">x86</span>)\<span class="selector-tag">Microsoft</span> <span class="selector-tag">SDKs</span>\<span class="selector-tag">MPI</span>\<span class="selector-tag">Lib</span>\<span class="selector-tag">x64</span>" <span class="selector-tag">MPIHelloWorld</span><span class="selector-class">.obj</span></span><br></pre></td></tr></table></figure></p><p>其中，link为link.exe链接器，-machine:x64表示x64版本，-out表示指定输出文件名，-dynamicbase表示包含附加依赖项msmpi.lib，而-libpath表示设置库目录，最后MPIHelloWorld.obj表示要链接的汇编文件。链接完之后可以看到当前目录下生成了MPIHelloWorld.exe可执行文件<br><img src="/img/20200222-3.jpg" alt=""></p><p>最后，执行该程序，例如本例中采用10个核<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mpiexec</span> <span class="selector-tag">-n</span> 10 <span class="selector-tag">MPIHelloWorld</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/20200222-4.jpg" alt=""></p><p>至此，完成了Windows系统下采用命令行编译C++ MPI程序，参考此编译过程，可以将其应用到复杂的程序编译过程中，此是后话了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-目的&quot;&gt;&lt;a href=&quot;#一-目的&quot; class=&quot;headerlink&quot; title=&quot;一. 目的&quot;&gt;&lt;/a&gt;一. 目的&lt;/h3&gt;&lt;p&gt;目标程序比较大，之前主要是在Liunx下进行程序的开发、编译与使用，现在想在Windows下进行开发、编译与使用。为了实
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>大道平直，努力向前</title>
    <link href="http://liaohuming.com/2018/03/06/diary/20180306-%E5%A4%A7%E9%81%93%E5%B9%B3%E7%9B%B4%E5%8A%AA%E5%8A%9B%E5%90%91%E5%89%8D/"/>
    <id>http://liaohuming.com/2018/03/06/diary/20180306-大道平直努力向前/</id>
    <published>2018-03-06T14:02:41.000Z</published>
    <updated>2020-02-23T04:32:19.883Z</updated>
    
    <content type="html"><![CDATA[<p>嚯，这篇博文居然还空着。</p><p>记得是去年的春天，即将要毕业，认识了心仪的女孩，一时间春回大地，万物复苏，未来的一切令我振奋与向往。这篇博客就是那时候想写的，想描述的也就是那样的心情。小时候总觉得日子好漫长，越长大时间走的越快。瞧，弹指一挥间，一年多过去了，这一年每天都过得跟打仗似的，非常累，非常充实，也学习到了很多，当然也有令人沮丧的事情与时候，归结起来都是收获。毕业了、工作了、心仪的女孩现在成了我的妻子。</p><p>拖了一年半之久，最初有想法的时候总想着等有个空闲的时间了，好好写一写，殊不知到了后面因为忙碌，或者因为记不起来，等等原因，这事情就搁浅了，再提笔已是一年半之后了，当初的心潮澎湃，也再不能描述出来了。</p><p>拖延症往往也是完美主义者，总是恐惧自己做出来的东西不够完美。比如有些想法迟迟不动笔写下来，因为总是希望写出一个完美的东西！其实先硬着头皮把最想表达的写下来，然后再反复迭代修改先有一个拙劣作品远胜过迟迟不肯动手。</p><p>所以啊，凡事都及时行动。The journey of a thousand miles begins with a single step.</p><p>update@2019年9月8日11:13:27<br>北航沙河校区三号教学楼，教师之家</p><p><img src="/img/20190908.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嚯，这篇博文居然还空着。&lt;/p&gt;
&lt;p&gt;记得是去年的春天，即将要毕业，认识了心仪的女孩，一时间春回大地，万物复苏，未来的一切令我振奋与向往。这篇博客就是那时候想写的，想描述的也就是那样的心情。小时候总觉得日子好漫长，越长大时间走的越快。瞧，弹指一挥间，一年多过去了，这一年每
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>编程过程中的小错误</title>
    <link href="http://liaohuming.com/2017/04/19/notes/20170419-%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%94%99%E8%AF%AF/"/>
    <id>http://liaohuming.com/2017/04/19/notes/20170419-编程过程中的小错误/</id>
    <published>2017-04-19T08:19:17.000Z</published>
    <updated>2017-04-19T08:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>C++中除号的用法错误，在C++中如果“/”两端皆为整数，那么将执行整除运算，即仅取除法运算中的整数部分（并不会四舍五入），要想做非整除运算，需要在“/”两端接float或者double类型的非整型数据类型，这样“/”将进行非整除运算，如下。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">300</span>/<span class="number">180</span>*<span class="number">3.14159</span>);    <span class="comment">// cos(3.14159)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">3.14159</span>*<span class="number">300</span>/<span class="number">180</span>);   <span class="comment">// cos(5.23598)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">300.0</span>/<span class="number">180.0</span>*<span class="number">3.14159</span>);   <span class="comment">// cos(5.23598)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;C++中除号的用法错误，在C++中如果“/”两端皆为整数，那么将执行整除运算，即仅取除法运算中的整数部分（并不会四舍五入），要想做非整除运算，需要在“/”两端接float或者double类型的非整型数据类型，这样“/”将进行非整除运算，如下。&lt;figure cl
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令备忘（持续更新）</title>
    <link href="http://liaohuming.com/2016/09/02/notes/20160902-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://liaohuming.com/2016/09/02/notes/20160902-Linux常用命令备忘（持续更新）/</id>
    <published>2016-09-02T14:28:11.000Z</published>
    <updated>2019-10-15T04:39:34.007Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>通过ssh登陆linux服务器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -y -l username serveraddress</span><br><span class="line"><span class="comment">// username为用户名</span></span><br><span class="line"><span class="comment">// serveraddress为服务器地址</span></span><br></pre></td></tr></table></figure></li><li><p>使用cygwin远程连接linux服务A后，通过A访问远程linux服务器B</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -y -l username server_A_address    <span class="comment">// 先登录远程服务器A</span></span><br><span class="line"></span><br><span class="line">ssh -y -l username server_B_address     <span class="comment">// 再在A上登录远程服务器B</span></span><br></pre></td></tr></table></figure></li><li><p>通过scp跨服务器复制文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scp file1.txt username@serveraddress:/home/username</span><br><span class="line"><span class="comment">// file1.txt 为复制源</span></span><br><span class="line"><span class="comment">// username@serveraddress:/home/username为目标路径</span></span><br><span class="line"></span><br><span class="line">scp -r test username@serveraddress:/home/username</span><br><span class="line"><span class="comment">// -r表示复制的是文件夹，test为文件夹</span></span><br><span class="line"></span><br><span class="line">scp -r -P <span class="number">20782</span> test username@serveraddress:/home/username</span><br><span class="line"><span class="comment">// -P 20782 表示端口号，对于有指定端口需求的，需要采用这种方式</span></span><br></pre></td></tr></table></figure></li><li><p>复制指定目录下的全部文件到另一个目录中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设复制源目录为dir1，目标目录为dir2，怎样才能将dir1下所有文件复制到dir2下？</span></span><br><span class="line"><span class="comment">// 如果dir2目录不存在，则可以直接使用</span></span><br><span class="line">cp -r dir1 dir2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果dir2目录已存在，则需要使用</span></span><br><span class="line">cp -r dir1/. dir2</span><br><span class="line"><span class="comment">// 如果这时使用cp -r dir1 dir2，则也会将dir1目录复制到dir2中，明显不符合要求。</span></span><br></pre></td></tr></table></figure></li><li><p>删除文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm filename</span><br></pre></td></tr></table></figure></li><li><p>删除文件夹及其所包含的文件或文件夹</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf flodername</span><br></pre></td></tr></table></figure></li><li><p>通过pkill终止指定用户的所有进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill -uusername</span><br><span class="line"><span class="comment">// -u为指定用户的命令，username为指定的用户</span></span><br></pre></td></tr></table></figure></li><li><p>通过chmod修改文件权限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x submit.sh</span><br><span class="line"><span class="comment">// u代表user，即所有用户，+x代表增加执行权限，submit.sh为要修改权限的文件</span></span><br><span class="line"></span><br><span class="line">chmod u-x submit.sh</span><br><span class="line"><span class="comment">//取消权限</span></span><br></pre></td></tr></table></figure></li><li><p>通过chown修改 文件/目录 的所有者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown userName testfile.xx <span class="comment">//修改tesfile.xx文件拥有者为userName</span></span><br><span class="line">chown -R userName testDir <span class="comment">//修改testDir目录及其所包含的文件的拥有者为userName</span></span><br></pre></td></tr></table></figure></li><li><p>运行目录下的可执行程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./submit.sh test.st</span><br><span class="line"><span class="comment">// ./代表当前路径下，submit.sh是输入参数，test.st是可执行程序</span></span><br></pre></td></tr></table></figure></li><li><p>通过nohup后台运行可执行程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup ./submit.sh test.st &amp;</span><br><span class="line"><span class="comment">// nohup 表示忽略HUP信号，标准输出和标准错误缺省会被重定向到nohup.out文件中</span></span><br><span class="line"><span class="comment">// 在结尾加上 &amp; 来将命令放入后台运行 </span></span><br><span class="line"><span class="comment">// 退出终端时，需要使用exit命令退出终端，如果直接关闭终端窗口会将后台运行的程序一同关闭</span></span><br></pre></td></tr></table></figure></li><li><p>linux 查看隐藏文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：显示所有文件（包含隐藏文件）</span></span><br><span class="line">ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：只显示隐藏文件</span></span><br><span class="line">l.</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：同样只显示隐藏文件</span></span><br><span class="line">ls -d .*</span><br></pre></td></tr></table></figure></li><li><p>通过XTerm打开linux下的图形界面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登陆方式</span></span><br><span class="line">$ ssh username@hostname -Y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登陆成功后，直接输入应用程序名称调用该程序</span></span><br><span class="line">applicationName</span><br></pre></td></tr></table></figure></li><li><p>删除文件夹（空与非空）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除空目录</span></span><br><span class="line">rmdir flodername</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除非空目录</span></span><br><span class="line"><span class="comment">// -r 就是向下递归，不管有多少级目录，一并删除</span></span><br><span class="line"><span class="comment">// -f 就是直接强行删除，不作任何提示的意思</span></span><br><span class="line">rm -rf flodername</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">rm -rf /var/<span class="built_in">log</span>/httpd/access</span><br><span class="line">将会删除/var/<span class="built_in">log</span>/httpd/access目录以及其下所有文件、文件夹</span><br><span class="line"></span><br><span class="line">rm -f /var/<span class="built_in">log</span>/httpd/access.<span class="built_in">log</span></span><br><span class="line">将会强制删除/var/<span class="built_in">log</span>/httpd/access.<span class="built_in">log</span>这个文件</span><br></pre></td></tr></table></figure></li><li><p>新建文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可简单利用编辑器vim，如果test.sh存在则打开，不存在则新建</span></span><br><span class="line">vim test.sh</span><br></pre></td></tr></table></figure></li><li><p>使用cygwin连接linux服务器时，让cygwin客户端始终保持连接，本实现参考自<a href="https://www.liaohuqiu.net/cn/posts/keep-alive-terminal-connection/" target="_blank" rel="noopener">命令行终端保持连接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls -a   <span class="comment">// 当前用户主目录下，执行查看，看到隐藏的.ssh文件夹</span></span><br><span class="line">cd .ssh     <span class="comment">// 进入.ssh文件夹</span></span><br><span class="line">vi config   <span class="comment">// 打开配置文件（若不存在则创建）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用vi编辑器，在配置文件中输入以下配置，其中时间间隔可自行设置</span></span><br><span class="line">Host *hostname.com</span><br><span class="line">   ServerAliveInterval <span class="number">60</span></span><br><span class="line"><span class="comment">// 保存退出</span></span><br><span class="line"></span><br><span class="line">chmod +x config <span class="comment">// 为其增加执行权限，完成设置</span></span><br></pre></td></tr></table></figure></li><li><p>Linux的关机与重启命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重启命令：</span><br><span class="line">reboot</span><br><span class="line">shutdown -r now     <span class="comment">// 立刻重启(root用户使用)</span></span><br><span class="line">shutdown -r <span class="number">10</span>      <span class="comment">// 过10分钟自动重启(root用户使用) </span></span><br><span class="line">shutdown -r <span class="number">20</span>:<span class="number">35</span>   <span class="comment">// 在时间为20:35时候重启(root用户使用)</span></span><br><span class="line">                    <span class="comment">//如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</span></span><br><span class="line"></span><br><span class="line">关机命令：</span><br><span class="line">halt                <span class="comment">// 立刻关机</span></span><br><span class="line">poweroff            <span class="comment">// 立刻关机</span></span><br><span class="line">shutdown -h now     <span class="comment">// 立刻关机(root用户使用)</span></span><br><span class="line">shutdown -h <span class="number">10</span>      <span class="comment">// 10分钟后自动关机</span></span><br><span class="line">                    <span class="comment">// 如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</span></span><br></pre></td></tr></table></figure></li><li><p>用户、用户组相关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加用户组</span></span><br><span class="line">groupadd groupName</span><br><span class="line">groupdel groupName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加用户</span></span><br><span class="line">useradd userName</span><br><span class="line">passwd userName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个用户添加到用户组中，千万不能直接用： </span></span><br><span class="line">usermod -G groupName userName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样做会使你离开其他用户组，仅仅做为这个用户组groupName的成员。 </span></span><br><span class="line"><span class="comment">// 应该用加上-a选项，a代表append，也就是将自己添加到用户组groupName中，而不必离开其他用户组</span></span><br><span class="line">usermod -a -G groupName userName</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当前登录用户所在的组</span></span><br><span class="line">groups</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看某个用户hmliao所在组</span></span><br><span class="line">groups hmliao</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除用户</span></span><br><span class="line">userdel -r username<span class="comment">// 为了在删除用户时完全删除家目录，我们可以使用 -r 选项</span></span><br></pre></td></tr></table></figure></li><li><p>Linux系统查看物理CPU个数、CPU核数及逻辑CPU个数<br>CPU总核数 = 物理CPU个数 <em> 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 </em> 每颗物理CPU的核数 * 超线程数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看CPU信息</span></span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看CPU信息（型号）</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">     <span class="number">28</span>  Intel(R) Xeon(R) CPU E5<span class="number">-2690</span> v4 @ <span class="number">2.60</span>GHz</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看物理CPU个数</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo| grep <span class="string">"physical id"</span>| sort| uniq| wc -l</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; grep 'physical id' /proc/cpuinfo | sort -u | wc -l</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看每个物理CPU中core的个数(即核数)</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo| grep <span class="string">"cpu cores"</span>| uniq</span><br><span class="line">cpu cores       : <span class="number">14</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; grep 'core id' /proc/cpuinfo | sort -u | wc -l</span><br><span class="line"><span class="number">14</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo |grep <span class="string">"cores"</span>|uniq</span><br><span class="line">cpu cores       : <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看逻辑CPU的个数(查看线程数)</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br><span class="line"><span class="number">28</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; grep 'processor' /proc/cpuinfo | sort -u | wc -l</span><br><span class="line"><span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看CPU型号</span></span><br><span class="line">sudo dmidecode -s processor-version</span><br></pre></td></tr></table></figure></li><li><p>查看显卡</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -v -s `lspci | awk '/VGA/&#123;print $1&#125;'`</span><br></pre></td></tr></table></figure></li><li><p>查看系统版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">lsb_release  -a</span><br><span class="line"></span><br><span class="line"><span class="comment">//lsb_release: command not found 解决</span></span><br><span class="line"><span class="comment">//解决方法：yum install redhat-lsb -y</span></span><br></pre></td></tr></table></figure></li><li><p>查看硬盘序列号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartctl -i /dev/sda</span><br></pre></td></tr></table></figure></li><li><p>查看硬盘大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -lh</span><br></pre></td></tr></table></figure></li><li><p>查看各文件夹大小</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h <span class="attribute">--max-depth</span>=1</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过ssh登陆linux服务器&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下批量运行测试算例的简单实现（二）</title>
    <link href="http://liaohuming.com/2016/08/22/notes/20160822-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://liaohuming.com/2016/08/22/notes/20160822-Linux下批量运行测试算例的简单实现（二）/</id>
    <published>2016-08-22T15:21:17.000Z</published>
    <updated>2019-09-08T04:13:20.185Z</updated>
    
    <content type="html"><![CDATA[<p>记录在Linux服务器上，批量创建、移动、启动、提取，命名规范的相关计算文件的简单实现。适用情况在<a href="http://liaohuming.com/2016/02/08/notes/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">Linux下批量运行测试算例的简单实现（一）</a>中有详细介绍，此处只对改进的代码做相应的更新，以为备忘。</p><p><strong>1、批量创建、移动</strong><br>创建shell脚本，例如<code>FileCreater.sh</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">floderName=$<span class="number">1</span>#输入参数<span class="number">1</span>，文件夹名称</span><br><span class="line">dir_id_start=$<span class="number">2</span>#输入参数<span class="number">2</span>，起始编号</span><br><span class="line">dir_id_end=$<span class="number">3</span>#输入参数<span class="number">3</span>，结束编号</span><br><span class="line">submitName=submit</span><br><span class="line">submitSuffix=.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> test $dir_id_start -le $dir_id_end</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $floderName$dir_id_start</span><br><span class="line">cp mesh_square.dat $floderName$dir_id_start/mesh.dat</span><br><span class="line">cp verification_oscillation.erosion $floderName$dir_id_start/$floderName$dir_id_start.erosion</span><br><span class="line">mv $submitName$dir_id_start$submitSuffix $floderName$dir_id_start</span><br><span class="line">cd $floderName$dir_id_start</span><br><span class="line">mkdir fluid</span><br><span class="line">mkdir solid</span><br><span class="line">chmod +x $submitName$dir_id_start$submitSuffix</span><br><span class="line">cd ..</span><br><span class="line">dir_id_start=`expr $dir_id_start + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行：<code>./FileCreater.sh test 1 100</code><br>功能：将当前目录存在的100份计算输入参数文件<code>submit1.sh, submit2.sh, ..., submit100.sh</code>分配到100个文件夹（名称通过输入参数floderName定义，本例中为<code>test1, test2, ..., test100</code>）中，并将计算所需的主程序按计算参数文件进行编号后分配至对应的文件夹，并拷贝及创建相应的文件及文件夹，修改权限。</p><p><strong>2、批量启动</strong><br>创建shell脚本，例如<code>ProcessStarter.sh</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dir_name=$<span class="number">1</span>#输入参数<span class="number">1</span>，文件夹名称</span><br><span class="line">dir_id=$<span class="number">2</span>#输入参数<span class="number">2</span>，起始编号</span><br><span class="line">dir_id_end=$<span class="number">3</span>#输入参数<span class="number">3</span>，结束编号</span><br><span class="line"></span><br><span class="line">submitName=./submit</span><br><span class="line">submitSuffix=.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $dir_id_end</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $dir_name$dir_id</span><br><span class="line">nohup $submitName$dir_id$submitSuffix $dir_name$dir_id.erosion &amp;</span><br><span class="line">cd ..</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行：<code>./ProcessStarter.sh test 1 100</code><br>功能：批量启动100份文件夹中的计算主程序<code>test1.erosion, test2.erosion, ..., test100.erosion</code>，运行方式：后台运行。</p><p><strong>3、批量提取</strong><br>创建shell脚本，例如<code>ResultGatherer.sh</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sourcePath=/home/hmliao/#数据源路径</span><br><span class="line">destinationPath=/home/hmliao/createFloder/#数据目标路径</span><br><span class="line">floderName=$<span class="number">1</span>#输入参数<span class="number">1</span>，文件夹名称</span><br><span class="line">floderStart=$<span class="number">2</span>#输入参数<span class="number">2</span>，N个测试文件中需要提取的范围（开始）</span><br><span class="line">floderEnd=$<span class="number">3</span>#输入参数<span class="number">3</span>，N个测试文件中需要提取的范围（结束）</span><br><span class="line">fluidStart=$<span class="number">4</span>#输入参数<span class="number">4</span>，每个份测试文件中M份结果数据，需要提取的结果范围（开始）</span><br><span class="line">fluidEnd=$<span class="number">5</span>#输入参数<span class="number">5</span>，每个份测试文件中M份结果数据，需要提取的结果范围（结束）</span><br><span class="line">fileName=fluid_0_</span><br><span class="line">submitSuffix=.vtu</span><br><span class="line"></span><br><span class="line">#创建目录，用于放置提取的结果</span><br><span class="line">dir_id1=$floderStart</span><br><span class="line"><span class="keyword">while</span> test $dir_id1 -le $floderEnd</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $destinationPath$floderName$dir_id1</span><br><span class="line">dir_id1=`expr $dir_id1 + <span class="number">1</span>`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#提取结果至前述创建的目录</span><br><span class="line">dir_id2=$floderStart</span><br><span class="line"><span class="keyword">while</span> test $dir_id2 -le $floderEnd</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">#Copy fluid files</span><br><span class="line">fileId=$fluidStart</span><br><span class="line"><span class="keyword">while</span> test $fileId -le $fluidEnd</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cp  $sourcePath$<span class="number">1</span>$dir_id2/fluid/$fileName$fileId$submitSuffix $destinationPath$<span class="number">1</span>$dir_id2/</span><br><span class="line">fileId=`expr $fileId + <span class="number">1</span>`</span><br><span class="line">done</span><br><span class="line">dir_id2=`expr $dir_id2 + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行：<code>./ResultGatherer.sh Result 1 100 1 30</code><br>功能：如前所述，批量运行100份测试程序，对于一份测试，其测试过程中计算步数很多，需要在计算过程中即对计算结果（假设已计算得到30份结果）进行可视化分析，以判断是否有必要继续进行下去。因此需要将100个文件夹中，各自的30份文件，提取到一个独立的文件夹Result，然后将Result下载到本地机器进行分析。通过这个简单的脚本，可以方便的提取自己所需要的数据，数据的筛选及收集就是一条命令的事情，最后将结果数据下载即可分析，提高效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录在Linux服务器上，批量创建、移动、启动、提取，命名规范的相关计算文件的简单实现。适用情况在&lt;a href=&quot;http://liaohuming.com/2016/02/08/notes/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>最近</title>
    <link href="http://liaohuming.com/2016/08/18/diary/20160818-%E6%9C%80%E8%BF%91/"/>
    <id>http://liaohuming.com/2016/08/18/diary/20160818-最近/</id>
    <published>2016-08-17T16:04:35.000Z</published>
    <updated>2020-02-23T05:12:08.870Z</updated>
    
    <content type="html"><![CDATA[<p>七月的生活可用纯粹、煎熬两个词来概括。</p><p><strong>纯粹</strong><br>这段时间美共和党在克利夫兰召开全国代表大会，正值土耳其政变、法国尼斯国庆恐怖袭击、南海仲裁、枪击警察、黑人游行…，各种烽火不息，加之川普支持反对者向来激进狂热的作风，内忧外患一时之间甚有草木皆兵危机四伏的感觉，为安全起见学校封校一周。至此，我正式开启了闭关修炼的一个月，七月的克利夫兰，炎炎夏日，白天甚至比黑夜还死寂，这种寂静令人心慌，令人兴奋。每天于闷热中从低质量的睡眠中挣扎醒来，泡浓浓一杯咖啡，咬两片干面包，而后伴着李志摇滚式民谣开始coding、simulation、literature research、writing，傍晚去Shaker lake跑三圈，释放一天积压下来的情绪以及思考所遇到的问题，晚餐一罐啤酒，洗漱完毕后重又有了精神，继续干活至凌晨睡觉，这样持续了两周，在<a href="https://github.com/liaohuming/LmeTestTools" target="_blank" rel="noopener">前期</a>积累的基础上，我顺利的完成了论文，这是一段非常纯粹的时光。</p><p><strong>煎熬</strong><br>黎老师风尘仆仆的从国内回来，到学校后立即着手指导我修改论文，涉及文章结构、引用内容、图表质量、行文措辞、语法勘误等方方面面，细节再细节，推倒重来再推倒，来来回回三五轮修改，最终在8月11号将论文投出，这是我第一篇SCI投稿希望会有好的结果。改论文的两周可谓煎熬，有煎熬之感即代表尚有提高之处，非常感谢能有这样的一次学习经历，这种直接向优秀的人学习的机会不可多得，不仅让我清楚明白地认识到自身水平的欠缺，同时也感受到了一名优秀学者严谨的治学态度和敏锐的科研思维，受益匪浅。</p><p><strong>释然</strong><br>八月的第二个周末和朋友去了传说中的世界过山车之都Cedar point，开始我惊愕于各种惊险的轨道路线及乘客歇斯底里的尖叫声。随后和朋友们一起去体验了这种急速超重失重，天旋地转，跌落万丈深渊的感觉，这真的非常刺激，同时也伴随着巨大的恐惧感，所以大家才会歇斯底里的尖叫以释放这种情绪。为什么会有恐惧感？这让我想起大学室友吴力曾经说过，人之所以对某件事感到恐惧或迷茫，是因为自身对这件事没有掌控力。我很赞同这个看法，一只逗比的哈士奇或是温顺忠诚的秋田犬，想必是人见人爱，但如果是一只疯狗，我想大家都可能会有所惧怕，因为它不受控制，随时可能给自己带来伤害。类似的，坐这种惊险的过山车恰恰就会给你提供无限大的无控感：你的身体像炮弹一样进行高速运动，行进路线百转千回，急速状态下的上升、坠落、旋转、俯冲、超重、失重，这些极限的运动状态会让我们脱离平日里舒适的状态，从而失去对自身身体的掌控，下一步会怎么样完全是未知的，换句话说，在这短短的几十秒甚至十几秒的过程中，眼睛所接受的急速影像和身体所承受的极限状态，这些信息给我们的印象是危险，而我们能控制身体来应对这种危险的能力几乎为0，所以抓紧座椅、闭眼和尖叫是绝大部分人的选择。其实并非不能控制，对于这种极限运动，对身体的安全性保护本身就很完善，除非小概率突发故障，否则没有必要担心。这个时候我们需要转换控制对象，要控制的不再是身体，而是情绪，即是说要淡定，知道这个东西它就这么飞，就这么转，它既不会掉下来也不会撞上去，一切可能的危险都是假象都是纸老虎，只要放下了这个担心，不用闭眼，无需尖叫，放松状态下得到的将会极限体验的快感，罗哩吧嗦这么多，其实这就是我在坐第一趟过山车无控感骤升、恐惧感爆表时闪过脑海的想法，现在要码下来还得费半天劲也无法贴切描述出那种感觉，人的大脑在遇到极度危险的时候思维速度之外真的是可以让时间缓若静止，这可以让平日里诸多的困惑在短短的几秒中即得到释然，也许这正是各种极限运动的魅力之所在吧！当然熟知了这些，能够直面恐惧之后，剩余的就是极限运动带来的极致体验了，后面我真的是开始享受这种刺激了。当然，上述这些都是我的个人体验，仅我有效。</p><p><img src="/img/20160818-1.jpg" alt=""></p><p><img src="/img/20160818-2.jpg" alt=""></p><p><img src="/img/20160818-3.jpg" alt=""></p><p><img src="/img/20160818-4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;七月的生活可用纯粹、煎熬两个词来概括。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯粹&lt;/strong&gt;&lt;br&gt;这段时间美共和党在克利夫兰召开全国代表大会，正值土耳其政变、法国尼斯国庆恐怖袭击、南海仲裁、枪击警察、黑人游行…，各种烽火不息，加之川普支持反对者向来激进狂热的作风，内忧外患
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>我们都需要改变</title>
    <link href="http://liaohuming.com/2016/05/01/diary/20160501-%E6%88%91%E4%BB%AC%E9%83%BD%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98/"/>
    <id>http://liaohuming.com/2016/05/01/diary/20160501-我们都需要改变/</id>
    <published>2016-05-01T01:39:33.000Z</published>
    <updated>2020-02-23T04:32:23.850Z</updated>
    
    <content type="html"><![CDATA[<p>“滑膜肉瘤”事件在网上传播有好些日子了，今早起来看到<strong><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;mid=2650968235&amp;idx=1&amp;sn=6c99a7f680af5679215ae09351bf9f1d&amp;scene=25#wechat_redirect" target="_blank" rel="noopener">「青年魏则西之死」</a></strong>在微信朋友圈传播了，每次看到这样的消息，心情都很复杂，想表达些什么，却有一种很深的无力感。“滑膜肉瘤”事件只是存在着的千万事件之一，再多想一点就会对这个社会多绝望一些，但是如果人人都不发声，不作为，那就不会有改变。我们都需要改变。</p><p>百度利益至上不客观(甚至错误导向)竞价排名的搜索是推波助澜的邪恶之手、社会上诸多缺乏有效监督的环节是本源。我们的生活环境很糟糕，「假、毒」的「信息、食品、环境」让我们时时刻刻小心翼翼地甄别着日常生活最基本的要素，即便如此也不能保证自己及身边的亲人好友能不受到伤害。当一个社会环境要求生活在其中的社会成员具备苛刻的辨识能力「才有可能」生存，当生存变得如此艰难时，那么这个社会环境是迫切需要改善了，让大家都成为辨识专家来避免不受各种虚假毒害信息的蛊惑终究是治标不治本的方法，<strong>社会中占主导地位的应该是真善美，传播真善美，不作恶不发不义财，是我们每个人心中都该有的一个基本原则。同时一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。体制要改善，要有作为。</strong>而现在我能做的，就是不用百度(至少在它变得客观之前不用)、不作恶、传播真善美。诸君共勉。</p><p>@2016年5月1日10:10:16</p><hr><p><strong>「魏则西事件」</strong>所引起广泛的<strong>「讨论，调查，还没有到究责，整改阶段」</strong>这股热潮已与以往无数股「骗、假、毒」热潮一般悄然褪去，禁的禁，删的删，挡也挡不住，拉也拉不回，昨一日还是口诛笔伐震惊网坛，今一日已是歌舞升平天下太平，明一日定是不了了之无人问津矣。不知道此次事件牵涉到的对象会有多少改进。社会的进步，体制的健全，真不是一朝一夕的事情，还是需要遵守客观规律，历史的巨轮前进一小步需要巨大的时间来积累矛盾，积累爆发的能量。</p><p>@2016年5月4日00:50:47</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“滑膜肉瘤”事件在网上传播有好些日子了，今早起来看到&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;amp;mid=2650968235&amp;amp;idx=1&amp;amp;sn=6c99a7f68
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>多思考，勤笔记</title>
    <link href="http://liaohuming.com/2016/03/31/notes/20160331-%E5%A4%9A%E6%80%9D%E8%80%83%EF%BC%8C%E5%8B%A4%E7%AC%94%E8%AE%B0/"/>
    <id>http://liaohuming.com/2016/03/31/notes/20160331-多思考，勤笔记/</id>
    <published>2016-03-31T13:49:21.000Z</published>
    <updated>2019-09-15T08:30:40.930Z</updated>
    
    <content type="html"><![CDATA[<p>好像有这么个说法：“代码都在网上，学会google你就学会了coding”，确实是如此，学会向搜索引擎提问，问得越到位，得到的答案越精准而且快速。这不仅限于coding，所有一切，只要有疑问的都可以向搜索引擎提问，或多或少都会有些帮助，前提是客观的搜索引擎。然而实际生活中，并不是人人都善于利用搜索引擎来解决问题，大多的时候都喜欢让人代工，我自己以前就常常这么干，明明自己上网搜一下就可以解决的问题，却总是问别人，想着谁能告诉你怎么做。这就是典型的不思考。虽然一般情况下强调学习要多提问，然而多提问很多时候并不一定就是好的，更要注重提问的质量。能自己解决的尽量自己解决，不要让自己成为一个一遇到问题就问人的问题机器，要多思考，注重独自解决问题的能力，求助别人的时候，要搞清楚自己要问的是什么，而不是稀里糊涂的把锅一甩，这不是提问，这是让别人给你做了。</p><p>对于coding这件事，不止于会问，如果想要有提高，夯实基础和总结积累是两个很重要的方面。夯实基础即是要多看书，看好书，看经典。把基本的原理，概念要理解透。总结积累即是要在实践的过程中，对每次遇到的问题、困难进行总结提炼，遇到的问题是什么，自己是怎么解决的，总结的一个好方式就是做笔记写备忘，所谓好记性不如烂笔头，与其相同的问题一次次重复地遇到不如把每次遇到的问题及解决方法都记录下来，一是加深了理解，二来把东西放在自家后院，那才是自己的，用起来或者平时翻出来看看也是方便。</p><p>刚刚开始写笔记的时候常常会觉得，这个东西太简单了，用一次就记住了，没有必要去写。其实并不是这样。简单又何妨，就我个人经验而言，只要是一开始把你难住的问题，往往还会有第二次，第三次。所以，多思考，勤笔记，下次再遇则有迹可循。只有足够努力，方显毫不费力。想做一件事，任何时候都不算太晚，除非只是想想而已。</p><p>呵呵。口号喊完了，该开始写笔记了。我将在这篇笔记中不断地记录自己平时在使用C++时遇到并解决的小问题，并不需要特意去花上半天一天来总结，记录这一动作就发生在平时遇到问题并解决后。</p><hr><p><strong>CString与string的区别及转化</strong></p><p><em>关于CString类型：</em>CString是MFC的类，利用MFC进行编程时会经常用到，而一些标准C/C++库函数是不能直接对CString类型进行操作的，所以经常遇到将CString类型转化char*等其他数据类型的情况。</p><p><em>关于string类型：</em>标准C中是不存在string类型的，string是标准C++扩充字符串操作的一个类，但是标准C中有<code>&lt;string.h&gt;</code>这个头文件，在里面定义了一些经常用到的操作字符串的函数，如：strcpy、strcat、strcmp等，这些函数的操作对象都是char*指向的字符串。 </p><p>而C++的string类（头文件是<code>&lt;string&gt;</code>）操作对象是string类型字符串，该类重载了一些运算符，添加了一些字符串操作成员函数，使得操作字符串更加方便。有时候需要将string串和char*串配合使用，因此也会涉及到这两个类型的转化问题。</p><p>上述是CSting、string.h和string的区别，要对CString和string类型的字符串进行转换，首先将类型转化为<code>char*</code>类型，因为<code>char*</code>是不同类型之间的桥梁。得到<code>char*</code>类型，转化为其他类型就非常容易了。</p><p>1、string to char</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"string to char"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(ch, str.c_str());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>2、string to char *<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *strChar;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line">strChar = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">str.copy(strChar,len,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,strChar);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;strChar;</span><br></pre></td></tr></table></figure></p><p>3、char to string</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">255</span>] = <span class="string">"ch to string"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(ch);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>4、string to CString（在Unicode和多字节字符集环境下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"string2CString"</span>;</span><br><span class="line">CString cstr;</span><br><span class="line">cstr = str.c_str();</span><br><span class="line">MessageBox(cstr);</span><br></pre></td></tr></table></figure><p>5、CString to string（在Unicode和多字节字符集环境下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CString cstr = _T(<span class="string">"Cstring2string"</span>);</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = (CStringA)cstr;</span><br></pre></td></tr></table></figure><p>6、string to double</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to double</span></span><br><span class="line"><span class="built_in">string</span> = <span class="string">"3.14159"</span>;</span><br><span class="line"><span class="keyword">double</span> PI=atof(str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将double值转换为string，string转double，或者其他类型</span></span><br><span class="line"><span class="keyword">double</span> length=<span class="number">5.38725</span>;</span><br><span class="line"><span class="built_in">string</span> tempStr;</span><br><span class="line"><span class="built_in">stringstream</span> ssStr;</span><br><span class="line">ssStr&lt;&lt;length;</span><br><span class="line">ssStr&gt;&gt;tempStr;</span><br><span class="line">CString msg;</span><br><span class="line">msg=tempStr.c_str();</span><br><span class="line">MessageBox(msg);</span><br><span class="line">ssStr.clear();</span><br></pre></td></tr></table></figure><p>7、将int转换为CString</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">123</span>;</span><br><span class="line">CString intStr;</span><br><span class="line">intStr.Format(_T(<span class="string">"%d"</span>),num);</span><br><span class="line">MessageBox(intStr);</span><br></pre></td></tr></table></figure><p>8、 CString转char*（解决在Unicode字符集环境下中文乱码问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unicode环境下将CString转换成char*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CStringToChar</span><span class="params">(CString inputStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取宽字节字符的大小，大小是按字节计算的</span></span><br><span class="line">    DWORD dwLength=WideCharToMultiByte(CP_ACP,<span class="literal">NULL</span>,inputStr,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为多字节字符数组申请空间，数组大小为按字节计算的宽字节字节大小</span></span><br><span class="line">    <span class="keyword">char</span> *charStr;</span><br><span class="line">    charStr = <span class="keyword">new</span> <span class="keyword">char</span>[dwLength];</span><br><span class="line">    <span class="keyword">if</span>(!charStr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []charStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//宽字节编码转换成多字节编码</span></span><br><span class="line">    WideCharToMultiByte(CP_ACP,<span class="literal">NULL</span>,inputStr,<span class="number">-1</span>,charStr,dwLength,<span class="literal">NULL</span>,FALSE);</span><br><span class="line">    <span class="keyword">return</span> charStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、MFC 多字节字符集环境下 CString转char*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString Length=<span class="string">"10"</span>;</span><br><span class="line"><span class="keyword">char</span> *LengthStr=Length.GetBuffer(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>10、Unicode环境下将 CString转int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString str=_T(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> i=_ttoi(str);</span><br></pre></td></tr></table></figure><hr><p><strong>C中字符串操作</strong></p><p>1、由于字符串是数组类型，所以两个字符串赋值运算不能直接用“=”（除了初始化时），字符串的比较也不能直接用”==”,，字符串的拼接也不能用”+”,在C中有专门的操作函数，如：strcpy、strcat、strcmp。</p><p>char <em>strcpy(char </em>strDest,const char *strSrc); //是字符串复制函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> strSrc[<span class="number">255</span>] = <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(strDest,strSrc); <span class="comment">// strDest=World!</span></span><br></pre></td></tr></table></figure><p>char <em>strcat(char </em>strDest,const char *strSrc);    //是字符串拼接函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> strSrc[<span class="number">255</span>] = <span class="string">" World!"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(strDest,strSrc); <span class="comment">// strDest=Hello World!</span></span><br></pre></td></tr></table></figure><p>int strcmp(const char <em>str1, const char </em>str2 ; //是字符串比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">255</span>] = <span class="string">" World!"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcat</span>(str1,str2)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 not equal to str2!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、字符串查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> setEndFindStr=<span class="string">"END SETS"</span>;</span><br><span class="line"><span class="keyword">if</span> (lineStr.find(nodesFindStr) &lt; lineStr.length())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; find <span class="string">"END SETS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>格式化字符串</strong></p><p>1、用sscanf</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getline(_inputFile, firstLineStr);</span><br><span class="line"><span class="keyword">char</span> setType[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">char</span> setName[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(firstLineStr.c_str(), <span class="string">"%*[^,],%[^,],%[^,],%*[^,]"</span>, &amp;(setName),&amp;(setType));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解释一下，在这里firstLineStr=CMBLOCK,ELESET1 ,ELEM,28 !users element component definition</span></span><br><span class="line"><span class="comment">//格式化字符串后，setName==ELESET1，setType==ELEM</span></span><br><span class="line"><span class="comment">//%[]类似于一个正则表达式。[a-z]表示读取a-z的所有字符，[^a-z]表示读取除a-z以外的所有字符。</span></span><br><span class="line"><span class="comment">//所以此处``%*[^,]``表示满足``[]``里的条件将被过滤掉，不会向目标参数中写入值。</span></span><br><span class="line"><span class="comment">//即：将在遇到第一个``,``之前的（不为``,``的）字符全部过滤掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他简单用法</span></span><br><span class="line"><span class="comment">//Splitting the string,e.g."*node(1,0.292676,0.078422,-0.07,0,0,0,5,86)"</span></span><br><span class="line"><span class="built_in">sscanf</span>(firstLineStr.c_str(), <span class="string">"*node(%d,%lf,%lf,%lf,%*s,%*s,%*s,%*s,%*s"</span>,</span><br><span class="line">&amp;(node.id), &amp;(node.coordinate[<span class="number">0</span>]), &amp;(node.coordinate[<span class="number">1</span>]), &amp;(node.coordinate[<span class="number">2</span>]));</span><br></pre></td></tr></table></figure><p>2、用strtok<br>strtok的函数原型为char <em>strtok(char </em>s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成中文就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string lineStr="3-4917-1926-2933-34"，以“ ”作为分隔符</span></span><br><span class="line"><span class="keyword">char</span> lineData[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(lineData, lineStr.c_str());</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *delimter = <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">char</span> *item;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; itemCounter;</span><br><span class="line">item = strtok(lineData, delimter);</span><br><span class="line"><span class="keyword">while</span> (item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把char类型的转换成int类型存入临时变量</span></span><br><span class="line"><span class="keyword">int</span> nodeInt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">nodeStr</span><span class="params">(item)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">nodeSs</span><span class="params">(nodeStr)</span></span>;</span><br><span class="line">nodeSs &gt;&gt; nodeInt;</span><br><span class="line">itemCounter.push_back(nodeInt);</span><br><span class="line">item = strtok(<span class="literal">NULL</span>, delimter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、用AfxExtractSubString</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考PDS系统代码，MatlabSample.cpp</span></span><br><span class="line"><span class="comment">//以tab键为分割符，将apdl几何变量存到容器</span></span><br><span class="line">CString tempName;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=ugVariableNum; i&lt;(ugVariableNum+apdlVariableNum); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//tempName得到的字符串，tempStr完整待分割的字符串，i取第几个放在tempName</span></span><br><span class="line">AfxExtractSubString(tempName,tempStr,i,<span class="string">'\t'</span>); </span><br><span class="line">apdlVariableName.push_back(tempName);</span><br><span class="line"><span class="comment">/*MessageBox(tempName);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、用Cstring中的Find()、Mid()、Replace()、Right()、Left()等用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考机场安保系统代码，Logical_Relationship.cpp</span></span><br><span class="line"><span class="keyword">int</span> charPOS=indexstr_old.Find(<span class="string">' '</span>);</span><br><span class="line">Cstring temp=indexstr_old.Right(indexstr_old.GetLength()-charPOS<span class="number">-1</span>);</span><br><span class="line">index=atoi(temp)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>写文件的几种方式</strong></p><p>1、用FILE<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *outputFile = <span class="literal">NULL</span>;</span><br><span class="line">outputFile = fopen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outputFile, <span class="string">"%d\t%d\t%d\t%d\n"</span>, dimension, <span class="number">3</span>, nodes.size(), tria3.size());</span><br><span class="line">fclose(outputFile);</span><br></pre></td></tr></table></figure></p><p>2、用ofstream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">"test.txt"</span>,ofstream::out)</span></span>;</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">"# vtk DataFile Version 2.0"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"VTK file"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"ASCII"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"DATASET UNSTRUCTURED_GRID"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"POINTS "</span> &lt;&lt; nodes.size() &lt;&lt; <span class="string">" float"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; nodes[i].coordinate[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> </span><br><span class="line">&lt;&lt; nodes[i].coordinate[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> </span><br><span class="line">&lt;&lt; nodes[i].coordinate[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、用CStdioFile</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CStdioFile outPutFile( _T("temp.txt"),CFile::modeCreate | CFile::modeWrite | CFile::typeText );</span><br><span class="line"></span><br><span class="line">CString headStr=_T(<span class="string">"!设置工作目录\n"</span>);</span><br><span class="line">outPutFile.WriteString(headStr);</span><br><span class="line"></span><br><span class="line">CString stressDataStr;</span><br><span class="line">stressDataStr.Format(_T(<span class="string">"*cfopen,DATA-stress-result,txt,'%s'"</span>),G_projectPath);</span><br><span class="line">outPutFile.WriteString(stressDataStr);</span><br><span class="line"></span><br><span class="line">outPutFile.Close();</span><br></pre></td></tr></table></figure><hr><p><strong>读文件的几种方式</strong></p><p>1、用ifstream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile;</span><br><span class="line">infile.open(filepath);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (!infile.eof()) </span><br><span class="line">&#123;</span><br><span class="line">getline(infile, line);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure><p>2、用CStdioFile</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CStdioFile apdlFile;</span><br><span class="line">CString apdlPath=_T(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!apdlFile.Open(apdlPath, CFile::modeRead))</span><br><span class="line">&#123;</span><br><span class="line">::AfxMessageBox(_T(<span class="string">"文件打开失败。"</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString apdlStr = _T(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算文件的行数</span></span><br><span class="line"><span class="keyword">int</span> lineCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (apdlFile.ReadString(apdlStr))</span><br><span class="line">&#123;</span><br><span class="line">lineCount++;</span><br><span class="line">&#125;</span><br><span class="line">apdlFile.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件写入一个动态数组</span></span><br><span class="line">CString *apdlArray=<span class="keyword">new</span> CString[lineCount];</span><br><span class="line">apdlFile.Open(apdlPath, CFile::modeRead)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> writeNumber=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (apdlFile.ReadString(apdlStr))</span><br><span class="line">&#123;</span><br><span class="line">apdlArray[writeNumber]=apdlStr;</span><br><span class="line">writeNumber++;</span><br><span class="line">&#125;</span><br><span class="line">apdlFile.Close();</span><br></pre></td></tr></table></figure><hr><p><strong>const 与 #define的比较 @2016年4月5日10:09:41</strong></p><p>C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：</p><ul><li>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</li><li>有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。<blockquote><p>「规则1」在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。</p></blockquote></li><li>常量定义规则<blockquote><p>「规则2」需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。<br>「规则3」如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。</p></blockquote></li></ul><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100 <span class="comment">// C语言的宏常量 </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>; <span class="comment">// C++ 语言的const常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159</span>; <span class="comment">// C++ 语言的const常量</span></span><br></pre></td></tr></table></figure></p><hr><p><strong>main函数中argc和argv参数的含义  @2016年4月10日 16:32:23</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="comment">//argc=argument count</span></span></span><br><span class="line"><span class="function"><span class="comment">//argv=argument value</span></span></span><br></pre></td></tr></table></figure><hr><p><strong>使用geline读文件时判断文件末尾的问题  @2016年4月17日00:35:15</strong></p><p>使用<code>getline(infile, lineStr);</code>时，如果infile文件中最后一行不是空行，则会死循环（跳不出循环），这可能是LmeTestTool中有空行没空行时计算出bug的症结之所在。有时间可以去检查一下代码，在这做个备忘。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile;</span><br><span class="line">infile.open(<span class="string">"RBF-Init-Data-Points.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> lineStr = <span class="string">""</span>;</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line"><span class="keyword">while</span> (lineStr != <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> lifeTemp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(lineStr.c_str(), <span class="string">"%d"</span>, &amp;(lifeTemp));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lifeTemp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">lifeVector.push_back(lifeTemp);</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line">&#125;</span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure></p><p>检测EOF：成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(infile.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"已经到达文件尾！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>const和static const的区别 @2016年5月2日16:11:21</strong></p><p>对于C/C++语言来讲，<br>const就是只读的意思，只在声明中使用；<br>static一般有2个作用，规定作用域和存储方式。<br>对于局部变量，static规定其为静态存储方式，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放；<br>对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见；<br>对于static函数也是在当前模块内函数可见。<br>static const 应该就是上面两者的合集。</p><p>下面分别说明：</p><p>全局：<br>const，只读的全局变量，其值不可修改。<br>static，规定此全局变量只在当前模块(文件)中可见。<br>static const，既是只读的，又是只在当前模块中可见的。</p><p>文件:<br>文件指针可当作一个变量来看，与上面所说类似。</p><p>函数:<br>const，返回只读变量的函数。<br>static，规定此函数只在当前模块可见。</p><hr><p><strong>double数组进行递增排序算法 @2016年5月5日11:32:14</strong></p><p>代码示例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">double</span> *)a &gt; *(<span class="keyword">double</span> *)b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcSample_H</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> *h_all = <span class="keyword">new</span> <span class="keyword">double</span>[x_sp.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x_sp.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> h_temp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">if</span> (DIM == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">h_temp = <span class="built_in">sqrt</span>((x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>])*(x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>]) +</span><br><span class="line">(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>])*(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>]));</span><br><span class="line">h_all[i] = h_temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DIM == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">h_temp = <span class="built_in">sqrt</span>((x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>])*(x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>]) +</span><br><span class="line">(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>])*(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>]) +</span><br><span class="line">(x_sp[id].x[<span class="number">2</span>] - x_sp[i].x[<span class="number">2</span>])*(x_sp[id].x[<span class="number">2</span>] - x_sp[i].x[<span class="number">2</span>]));</span><br><span class="line">h_all[i] = h_temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(h_all, x_sp.size(), <span class="keyword">sizeof</span>(h_all[<span class="number">0</span>]), Cmp);<span class="comment">// 从小到大排序</span></span><br><span class="line">x_sp[id].h_min = h_all[<span class="number">1</span>];<span class="comment">// 取第二个h作为该点的最小h，因为第一个是到该点本身的距离，为0</span></span><br><span class="line"><span class="keyword">delete</span>[]h_all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>C++ 函数参数的传递方式 @2016年5月14日13:57:47</strong></p><p>今天写个小程序时犯了个错误，具体表现为：在主函数里声明了一个变量，然后将这个变量传递给一个子函数，这个变量在子函数里进行赋值操作，然后在主函数里接着对该变量进行操作（本意是想对赋值后的变量进行操作的），结果当然是该变量只是初始化的状态，子函数中对该变量的赋值操作并不会对主函数中该变量产生影响。这要从函数参数的传递方式来分析：</p><p><strong>（1）值传递：</strong><br>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参 —&gt; 形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</p><p><strong>（2）指针传递：</strong><br>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p><p><strong>（3）引用传递：</strong><br>形参相当于是实参的「别名」，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><p>下面是之前的错误代码，贴上来做个备忘<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Elements&gt; elementVector;<span class="comment">//1、声明一个变量</span></span><br><span class="line">ReadElemet(elementVector);<span class="comment">//2、传递给子函数（值传递）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、主函数中再调用，该变量并没有赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; elementVector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Elements&gt; ReadElemet(<span class="built_in">vector</span>&lt;Elements&gt; elementVector)</span><br><span class="line">&#123;</span><br><span class="line">Elements tempElem;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.open(<span class="string">"elem_rat.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open \"elem_rat.txt\""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!infile.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> lineStr = <span class="string">""</span>;</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line"><span class="keyword">if</span> (lineStr != <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lineStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(lineStr.c_str(), <span class="string">"%d,%d,%d,%d,%d"</span>, </span><br><span class="line">&amp;(tempElem.id), </span><br><span class="line">&amp;(tempElem.node[<span class="number">0</span>]), </span><br><span class="line">&amp;(tempElem.node[<span class="number">1</span>]), </span><br><span class="line">&amp;(tempElem.node[<span class="number">2</span>]), </span><br><span class="line">&amp;(tempElem.node[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、子函数中做赋值操作，不影响主函数中的变量</span></span><br><span class="line">elementVector.push_back(tempElem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好像有这么个说法：“代码都在网上，学会google你就学会了coding”，确实是如此，学会向搜索引擎提问，问得越到位，得到的答案越精准而且快速。这不仅限于coding，所有一切，只要有疑问的都可以向搜索引擎提问，或多或少都会有些帮助，前提是客观的搜索引擎。然而实际生活中，
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Windows与Linux两种格式文件相互转化问题的简单解决方案</title>
    <link href="http://liaohuming.com/2016/02/18/notes/20160218-Windows%E4%B8%8ELinux%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://liaohuming.com/2016/02/18/notes/20160218-Windows与Linux两种格式文件相互转化问题的简单解决方案/</id>
    <published>2016-02-18T14:18:15.000Z</published>
    <updated>2020-02-23T05:18:06.377Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h3><p>在<a href="http://liaohuming.com/2016/02/08/notes/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">「Linux下批量运行测试算例的简单实现」</a>一文中介绍了批量运行测试算例的方案，在其中我提到了修改每次计算的输入参数时，如果参数没有什么规律，只能手动的去修改输入参数文件，然而对于大数量级的测试次数，如果真的要手动去改输入参数，那是非常低效的，在经过两轮的手动改参数后我真受不了了，即便输入参数没有多少规律，也应尽量让程序来代工，手动改就是机械的浪费时间没有任何意义，把手动的过程用代码来实现虽然开始可能会费点时间，但这是个先苦后甜的过程，再者，相比机械的手动改参数，写程序还能多少有点技术性的收获，岂不更好。</p><p>这次遇到的问题是写了个代工程序，叫做<code>SubmitUpdater</code>，通过它来更新及生成大批量的Shell脚本文件，它们叫做<code>Submit-1.sh</code>-<code>Submit-N.sh</code>，这N份输入参数文件需要放到Linux服务器上进行计算。在Linux中执行.sh脚本的时候出现异常，具体表现为<code>/bin/bash^M: bad interpreter: No such file or directory</code>。在此对这个问题的解决方案进行简单总结，以做备忘。</p><h3 id="二-具体表现"><a href="#二-具体表现" class="headerlink" title="二. 具体表现"></a>二. 具体表现</h3><p>先看一眼<code>Submit-1.sh</code>里面的内容，很简单的Shell脚本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br></pre></td></tr></table></figure><p>这是执行<code>Submit-1.sh</code>的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmliao@songdyn:~&gt; ./Submit<span class="number">-1.</span>sh</span><br><span class="line">-bash: ./Submit1.sh: /bin/bash^M: bad interpreter: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>很显然，是<code>/bin/bash^M</code>这里多了个<code>^M</code>导致在Linux下执行的时候无法识别命令，为什么会多出来一个<code>^M</code>呢？这得从Windows系统和Linux系统的换行标识符来说明。</p><p>在Windows系统下的换行标识为<code>\r\n</code>，而Linux格式的换行标识为<code>\n</code>。其中<code>\r</code>表示回车符，<code>\n</code>表示新的一行new line。为何Linux下的换行符不包含<code>\r</code>回车符呢？大概是因为在Linux下处理包含回车符的时候会引起一些程序出现问题，因此和Windows的格式不一致。显然Windows和Linux的格式不一致是众所周知的，然而没有在实际中真正遇到的时候，往往我们是不会意识到它们的差异。</p><p>回归正题，在Linux下，回车符显示为<code>^M</code>，而新换一行则用<code>$</code>表示，根据上面的分析，我们是在Windows环境下用<code>SubmitUpdater</code>生成<code>Submit-1.sh</code>-<code>Submit-N.sh</code>N份Shell脚本，Windows会给它们的行末加上换行标识<code>\r\n</code>，即便你在代码中明明写的是<code>\n</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中#!/bin/bash我是如下定义的， 虽然代码里用\n，然而由于是在Windows下生成，会被定义为\r\n</span></span><br><span class="line"><span class="keyword">char</span> firstLine[<span class="number">255</span>] = <span class="string">"#!/bin/bash\n"</span>;</span><br></pre></td></tr></table></figure><p>因此实际上，上面的<code>#!/bin/bash</code>末尾接了一个Windows下的换行标识<code>\r\n</code>，那么在Linux下显示的时候应该就是<code>#!/bin/bash^M$</code>，我们可以在Linux下通过<code>cat -A filename</code>命令来查看一个脚本文件是Windows格式还是Linux格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hmliao@songdyn:~&gt; cat -A Submit<span class="number">-1.</span>sh</span><br><span class="line">#!/bin/bash^M$</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br><span class="line">hmliao@songdyn:~&gt;</span><br></pre></td></tr></table></figure><p>从上面可以看到<code>#!/bin/bash^M$</code>这是Windows格式，显然不是Linux能够识别的<code>#!/bin/bash$</code>，既然是格式不对，能想到的解决方法不外乎就是<strong>进行格式转换</strong>或者<strong>直接生成Linux格式的文件</strong>。</p><h3 id="三-解决方案"><a href="#三-解决方案" class="headerlink" title="三. 解决方案"></a>三. 解决方案</h3><p><strong>1. 格式转换</strong><br>Google搜了搜格式转换的方法琳琅满目，很多都是这样的情况：用各种文本编辑器打开文件，然后转存为Linux格式。这当然是一种方法，然而对于我的问题并不适用，我有几千份Windows格式的文件，一份份去转存终究是不现实，如果再写个程序来批处理这样的行为显然就没有意义。</p><p>对于我这样的，已经有大批量Windows格式的文件的问题，一种可行的格式转换方法是通过Linux下的<code>dos2unix</code>命令（当然了，同样也有<code>unix2dos</code>），然后在Linux服务器上用<code>dos2unix</code>命令写个循环的脚本文件，就可以轻松的完成格式转换。然而又出现一个问题了，我的Linux服务器上出现<code>-bash: dos2unix: command not found</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmliao@songdyn:~&gt; dos2unix Submit<span class="number">-1.</span>sh</span><br><span class="line">-bash: dos2unix: command <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure><p>估计是得安装一下.</p><p>update： 2017年12月18日15:33:39</p><p>对于 Linux 操作系统，Dos2unix 程序已经被添加到系统的软件源内，可以直接从软件源进行安装。Fedora、CentOS 等 Linux 发行版的安装命令为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install dos2unix unix2dos</span><br></pre></td></tr></table></figure><p>然而我的账号并没有权限，由于我是通过cygwin/ssh的方式来连接Linux服务器，一个可行的办法是在cygwin模拟的Linux环境下安装<code>dos2unix</code>，然后批量转格式，然后上传到服务器进行计算。</p><ul><li>首先下载<a href="https://github.com/liaohuming/SubmitUpdater/blob/master/files/apt-cyg" target="_blank" rel="noopener">「apt-cyg」</a>保存的文件名为apt-cyg，没有后缀，然后放到你的cygwin安装目录下的/bin目录里面，然后修改apt-cyg给执行权限，参考以下命令</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /bin/apt-cyg</span><br></pre></td></tr></table></figure><ul><li>然后运行cygwin的安装包，在选择包的页面安装wget，如图，接着等待安装完成</li></ul><p><img src="/img/20160218.png" alt="安装wget"></p><ul><li>最后打开cygwin终端，执行<code>apt-cyg install dos2unix</code>进行安装。</li></ul><p>此方法经测试有效，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxl650@BoLi-PC /home</span><br><span class="line">$ dos2unix Submit<span class="number">-1.</span>sh</span><br><span class="line">dos2unix: converting file Submit<span class="number">-1.</span>sh to Unix format...</span><br></pre></td></tr></table></figure><p>可以看到转换后的文件，没有了<code>^M</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A Submit<span class="number">-1.</span>sh</span><br><span class="line">hxl650@BoLi-PC /home</span><br><span class="line">#!/bin/bash$</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br></pre></td></tr></table></figure></p><p>再通过写个循环脚本就可以实现批量转换了，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line">submitName=Submit-</span><br><span class="line">submitSuffix=.sh</span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $<span class="number">1</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">dos2unix $submitName$dir_id$submitSuffix</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>批量转换格式后上传到Linux服务器进行计算，则通过<strong>格式转换</strong>的途径解决了这个问题，但是这他妈的也实在是太繁琐了吧，简直不能忍，也就是一直不甘心一直想把它成功转换，我才坚持把这个方法做通，但是太繁琐了，不推荐。如果有兴趣倒不妨尝试一下。</p><p><strong>2. 直接生成Linux格式的文件</strong></p><p>前面说过了，不外乎转格式和直接生成正确格式两种方法。现在就简单说说直接生成Linux格式的文件的方法，前面说了半天那么详细的说，为什么到这里就简单说说了呢，那是因为这个方法太简单了。</p><p>第一，如果是用文本编辑器手动编辑的脚本文件，那在保存的时候注意一下保存的格式，比如说windows的文本编辑器notepad，在保存的时候，选择为Unix格式的，这样传到Linux服务器的时候格式就没有问题了。当然还有其他很多种文本编辑器了，一样的，就是保存格式设置一下。当然这种情况对我的需求并不适用，我有成百上千份文件，我不可能手动一份创建然后保存。所以需要写程序来做这些工作，也就是前面提到的<code>SubmitUpdater</code>，用<code>SubmitUpdater</code>来生成成百上千份的文件，似乎又回到了需要进行前面格式转换的问题了是不是？其实只要不要在Windows下编译<code>SubmitUpdater</code>即可，把编译工作放到Linux服务器上去做，然后在Linux下执行<code>SubmitUpdater</code>，直接生成Linux格式的脚本文件，这才是正道。不要纠结怎么进行格式转换了，虽然研究起来也蛮有意思。</p><p>第二，要把程序放到Linux上去编译，那得自己写makefile了，然而不写不知道，写了才知道makefile有多简单，下面是一个非常好的教程<a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">「跟我一起写Makefile:MakeFile介绍」</a>，推荐学习，此处不再赘述了。</p><p>update: 2017-6-5 10:36:21<br><strong>3. 在windows下生成用于linux计算用的文件时保证不输入\r即可</strong><br>详见：<a href="https://stackoverflow.com/questions/32143707/how-do-i-stop-fprintf-from-printing-rs-to-file-along-with-n-in-windows" target="_blank" rel="noopener">How do I stop fprintf from printing \r’s to file along with \n in Windows</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FILE *outputFile = <span class="literal">NULL</span>;</span><br><span class="line">outputFile = fopen(outputFileName, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output element sets data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementSets.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(outputFile, <span class="string">"8 %s %d\n"</span>,</span><br><span class="line">        elementSets[i].name,</span><br><span class="line">        elementSets[i].element.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; elementSets[i].element.size(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(outputFile, <span class="string">"%d\n"</span>, elementSets[i].element[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四-参考资料"><a href="#四-参考资料" class="headerlink" title="四. 参考资料"></a>四. 参考资料</h3><p><a href="http://bencane.com/2014/02/11/converting-files-from-windows-format-to-unix-format-with-dos2unix//" target="_blank" rel="noopener">1. Converting files from Windows format to Unix format with dos2unix</a><br><a href="http://www.wjxfpf.com/2015/10/486084.html" target="_blank" rel="noopener">2. cygwin $’\r’: command not found 解决 dos2unix</a><br><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">3. 跟我一起写Makefile:MakeFile介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-问题描述&quot;&gt;&lt;a href=&quot;#一-问题描述&quot; class=&quot;headerlink&quot; title=&quot;一. 问题描述&quot;&gt;&lt;/a&gt;一. 问题描述&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;http://liaohuming.com/2016/02/08/notes/201
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下批量运行测试算例的简单实现（一）</title>
    <link href="http://liaohuming.com/2016/02/08/notes/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://liaohuming.com/2016/02/08/notes/20160208-Linux下批量运行测试算例的简单实现（一）/</id>
    <published>2016-02-08T09:21:36.000Z</published>
    <updated>2020-02-23T05:21:05.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h3><p>在<a href="http://liaohuming.com/2016/02/01/notes/20160201-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%9A%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%97%B6getopt()%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/">「命令行多参数解析时getopt()函数的使用方法小结」</a>一文中介绍了如何用<code>getopt()</code>函数来进行多参数的解析，在该文的<strong>「三. 实例」</strong>中即用了<code>getopt()</code>函数对38个输入参数进行解析，这些参数用于测试某数值算法，而这些参数中的很大一部分，其参数的取值是有待寻优的，即是说，需要将这些参数在一定的取值范围内对各种取值的情况进行计算，最后分析计算结果找出最佳的参数组合，因而就需要不断的修改参数的取值，然后不断地提交计算。</p><p>该数值算法的测试程序为单线程且有若干输入文件及输出结构目录，为了减少测试过程中的手动操作，将采用一台64核Linux系统的服务器来进行测试。整个实现方案虽然很简单，由于平时Linux用得少，许多操作步骤用到一些不熟悉的指令，正所谓好记性不如烂笔头，为了避免日后出现再用到时又忘记而又需要重新花时间去琢磨的情况，在此就花一些时间把整个过程简单的梳理，做个备忘，以供日后参考。</p><h3 id="二-方案概述"><a href="#二-方案概述" class="headerlink" title="二. 方案概述"></a>二. 方案概述</h3><ul><li>测试文件：<code>submit.sh</code>启动程序（参数在此定义）、<code>vos.gcc_v714M.st</code>主程序、<code>mesh.dat</code>输入文件；<code>fluid</code>、<code>solid</code>输出目录，所有这些文件同在一个目录下，如下图所示：</li></ul><p><img src="/img/20160208-1.jpg" alt="测试文件"></p><ul><li><p>测试环境：64核Linux系统</p></li><li><p>测试方案：每次同时提交进行60份不同的参数进行测试计算</p></li></ul><h3 id="三-实现过程"><a href="#三-实现过程" class="headerlink" title="三. 实现过程"></a>三. 实现过程</h3><p><font color="red">1. 为submit.sh启动程序和vos.gcc_v714M.st主程序增加执行权限<font></font></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加执行权限</span></span><br><span class="line">chmod u+x submit.sh</span><br><span class="line">chmod u+x vos.gcc_v714M.st</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消执行权限</span></span><br><span class="line"><span class="comment">// chmod u-x submit.sh</span></span><br><span class="line"><span class="comment">// chmod u-x vos.gcc_v714M.st</span></span><br></pre></td></tr></table></figure><p>增加执行权限后的效果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r--. <span class="number">1</span> hmliao hmliao      <span class="number">460</span> Feb  <span class="number">6</span> <span class="number">02</span>:<span class="number">23</span> submit.sh*</span><br><span class="line">-rwxrw-r--. <span class="number">1</span> hmliao hmliao      <span class="number">460</span> Feb  <span class="number">6</span> <span class="number">02</span>:<span class="number">23</span> vos.gcc_v714M.st*</span><br></pre></td></tr></table></figure></p><p>说明：<br>第一列共有10个位置，即：<code>-rwxrw-r--</code><br>第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。<br>从第二个字符开始到第十个共9个字符，3个字符一组，上例中的三组分别是：<code>‘rwx’</code>,<code>‘rw-’</code>，<code>‘r--’</code>分别表示了<strong>u，g，o，3组用户</strong>对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。</p><p>u 代表所有者（user）<br>g 代表所有者所在的组群（group）<br>o 代表其他人，但不是u和g （other）<br>a 代表全部的人，也就是包括u，g和o<br>r 表示文件可以被读（read）<br>w 表示文件可以被写（write）<br>x 表示文件可以被执行（如果它是程序的话）</p><p><font color="red">2. 批量创建计算文件<font></font></font></p><p>每计算一次都需要<code>submit.sh</code>、<code>vos.gcc_v714M.st</code>、<code>mesh.dat</code>、<code>fluid</code>和<code>solid</code>这些文件，为了同时计算n次（本例中为60次，下面皆以60次为例进行说明），需要为每次计算准备独立的目录，所以接下来要做的事情是，批量生成60个计算文件夹，再将这5分文件批量复制到各个文件夹中，然后修改每次计算的输入参数<code>submit.sh</code>，输入参数这个得手动修改了，除非测试的参数满足某种规律便于写脚本自动修改，否则就根据测试需求手动慢慢改吧。</p><p>批量生成文件夹及批量复制的脚本，命名为<code>CreateFiles.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dir_id=1</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">test</span> <span class="variable">$dir_id</span> -le <span class="variable">$2</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir <span class="variable">$1</span><span class="variable">$dir_id</span></span><br><span class="line">cp -r copyFiles/*.* <span class="variable">$1</span><span class="variable">$dir_id</span></span><br><span class="line">cp -a fluid <span class="variable">$1</span><span class="variable">$dir_id</span></span><br><span class="line">cp -a solid <span class="variable">$1</span><span class="variable">$dir_id</span></span><br><span class="line">dir_id=<span class="string">'expr $dir_id + 1'</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>说明：</p><p><code>test</code>是Linux里的一个命令，在本例中<code>test</code>的作用是评估一个表达式<code>$dir_id -le $2</code>,如果条件为真，则返回一个 0 值，同时执行do下面的命令。如果表达式不为真，则返回一个大于 0 的值，也可以将其称为假值，结束执行，即done。</p><p><code>$dir_id -le $2</code>这个表达式中<code>dir_id=1</code>，表示从1开始计数，<code>$2</code>表示用户通过命令行输入的第二个参数，这个参数在本例中就是要计算的次数n=60次。那么就简单了，<code>$dir_id -le $2</code>的含义：如果 $dir_id 小于或等于 $2，则为真，执行do后面的命令，否则结束循环。</p><p><code>mkdir $1$dir_id</code>中的<code>$1</code>表示用户通过命令行输入的第一个参数，在本例中的含义是测试文件夹的名称，例如test，<code>$1$dir_id</code>就表示test1、test2、……、test60，mkdir通过while循环来创建这60个文件夹。</p><p><code>cp -r copyFiles/*.* $1$dir_id</code>、<code>cp -a fluid $1$dir_id</code>、<code>cp -a solid $1$dir_id</code>这三条命令是拷贝文件，由于目录下还有其他一些文件，为了方便，本例将<code>submit.sh</code>、<code>vos.gcc_v714M.st</code>、<code>mesh.dat</code>统一放在copyFiles这个文件夹下，这里面只有这3个文件，没有其他干扰文件，复制起来简单方便，将这个文件下的所有文件通过while循环分布拷贝至60个文件夹中，同时再将输出结果的两个文件夹，也通过while循环拷贝至60个文件夹中。</p><p><code>dir_id=&#39;expr $dir_id + 1&#39;</code>这个是更新表达式，不用多说了。</p><p>执行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./CreateFiles.sh test <span class="number">60</span><span class="comment">// test为文件夹名称，自行定义，60为数量，自行定义</span></span><br></pre></td></tr></table></figure></p><p>效果<br><img src="/img/20160208-2.jpg" alt="生成的60个文件夹，每个文件夹中含有上述的5份文件"></p><p><font color="red">3. 修改每次计算的输入参数<font></font></font></p><p>如前所述，输入参数这个得手动修改了，除非测试的参数满足某种规律便于写脚本自动修改，否则就根据测试需求手动慢慢改吧。</p><p><font color="red">4. 批量启动测试程序，并且这个测试需要后台运行<font></font></font></p><p>本例是用 Cgywin64 Terminal/ssh 登录了远程的 Linux 服务器，每一次的计算任务要花至少1天的时间，因此需要让命令提交后不受本地关闭终端窗口/网络断开连接的干扰。当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，一种简单有效的解决方法是让进程忽略 HUP 信号，60个文件夹下的计算程序都通过nohup的方式启动执行，把这个启动执行的过程同样也写成一个脚本，一键提交，这个脚本命名为<code>StartAll.sh</code></p><p>StartAll.sh<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dir_name=test</span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le <span class="number">60</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $dir_name$dir_id</span><br><span class="line">nohup ./submit.sh vos.gcc_v714M.st &amp;</span><br><span class="line">cd ..</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>说明：<br><code>nohup ./submit.sh vos.gcc_v714M.st &amp;</code>，<code>nohup</code>表示忽略HUP信号，标准输出和标准错误缺省会被重定向到 nohup.out 文件中；<code>./submit.sh</code>是每次计算的输入参数文件，60次各不相同的，<code>vos.gcc_v714M.st</code>是计算主程序，都是一样的；在结尾加上<code>&amp;</code>来将命令放入后台运行。</p><p>整个思路即是：首先进入test1文件夹，用后台运行的方式启动程序，然后退出至主目录，通过循环进入test2，又启动程序，由此循环实现n=60次的启动。在主目录执行<code>./StartAll.sh</code>后可以看到所有60个程序都已经启动且是后台运行，如下图所示：</p><p><img src="/img/20160208-3.jpg" alt="启动60个计算程序，后台运行"></p><p><font color="red">5. 计算完成后，必要的删除操作<font></font></font></p><p>计算完成后，可能需要批量删除文件及文件夹，下面的命令可能会用到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除目录，不管目录中有没有文件，会将一些隐藏的配置文件也删除，小心使用</span></span><br><span class="line">hmliao@songdyn:~&gt; rm -r /home/hmliao<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 强制删除，没有提示，会将一些隐藏的配置文件也删除，小心使用</span></span><br><span class="line"><span class="comment">hmliao@songdyn:~&gt; rm -rf /home/hmliao/*</span></span><br></pre></td></tr></table></figure><p><font color="red">6. Linux跨服务器复制文件<font></font></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp file1.txt hmliao@songdyn.<span class="keyword">case</span>.edu:/home/hmliao</span><br></pre></td></tr></table></figure><p>上述为实现过程的备忘，若有更多操作，后续再进行更新。</p><p>2016年2月9日17:27:10<br>于克利夫兰</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>前面顺利提交了测试算例，接下来是漫长繁琐的数据分析，然而数据分析并不一定要等到算例结束再开始，在算例计算的过程中，根据输出的数据，很容易就可以判别出哪些算例的结果是无效的，对于这些算例就没有必要再接着算下去，这个时候就需要把服务器上对应的进程给结束。那么现在问题来了，60个程序的名称都是一样的即<code>vos.gcc_v714M.st</code>，又是通过<code>./</code>的方式而不是绝对路径的形式提交，所以这个时候查看进程，无法分辨出60个<code>vos.gcc_v714M.st</code>分别属于哪个test，也即是无法轻易的找到对应关系，比如这个<code>vos.gcc_v714M.st</code>属于test1，而那个<code>vos.gcc_v714M.st</code>属于test2，类似这样。</p><p>不能轻易的分辨出对应关系，那么想要结束某个进程就不知道该如何下手了。</p><p>在Linux里查看进程，一般可用top和ps命令。top的效果如下图：</p><p><img src="/img/20160208-3.jpg" alt="Top查看进行信息"></p><p>PID是每个进程的ID，所有进行都有自己的ID且唯一。在COMMAND那一列，可以看到程序的名称，这个时候我们发现前面提交的60个任务所有都叫同一个名字<code>vos.gcc_v714M.st</code>，这样如果想结束某个进行显然不知道对应关系，没法下手。</p><p>于是想通过ps命令来查看每个进程所运行的主程序的路径，也就是说它们各自属于哪个文件夹，我们前面定义了60个文件，如果现在能看到各个进程运行的主程序来自于哪个文件夹，这样对应关系就清楚了。于是尝试用下面的方式来查看详细的路径信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep vos.gcc_v714M.st</span><br></pre></td></tr></table></figure><p>然而由于是通过<code>./</code>的方式提交的，所以依然看不到程序的路径信息。</p><p>当然，一个蠢方法是可以看到路径信息的，那就是通过已知的PID，然后挨个去看，但这没有任何意义，这没有办法一次把所有的信息列出来，60个要去看60次，也不是想看哪个就能找到哪个，没有人会愿意这么做的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/PID/exe</span><br></pre></td></tr></table></figure><p>所以，这个问题没有得到解决。从计算的结果来看，目前测试的60组数据都不行，那么就把所有的进程一起结束了吧，多简单，有两种方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall vos.gcc_v714M.st <span class="comment">// 这个指的是结束所有指定名称的进程，测试没成功</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -uhmliao <span class="comment">// -u指的是用户名，hmliao是对应的用户，代表把该用户的所有进程结束，测试成功</span></span><br></pre></td></tr></table></figure><p>接下来要做的是，在下次提交的任务的时候，使得进行自带分辨信息，能想到的办法有两种，第一，提交的时候用绝对路径，那样的话用<code>ps aux|grep vos.gcc_v714M.st</code>这样的方式就可以看到每一个进程程序的路径，这样的方法能想像出有多麻烦，首先，提交的指令加上了绝对路径之后肯定很不清晰了，一大串一大串的，其次，查看进行的时候也是有一大串的路径信息，看花眼哟，所以这是一种不可取的选择，也就没有去尝试了。</p><p>最简单的莫过于把60个程序改下名字，加上编号或者其他任意需要的信息，然后通过top一看便知，这样就轻易的能找到某个我们想要的进程的PID，再想对它做点什么，还不是分分钟的事。</p><p>这样，就在原来<code>CreateFiles.sh</code>的基础上，把原来的单纯拷贝的操作，改为拷贝并重命名即可实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $<span class="number">2</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $<span class="number">1</span>$dir_id</span><br><span class="line">cp -r copyFiles<span class="comment">/*.* $1$dir_id</span></span><br><span class="line"><span class="comment">cp -f vos.gcc_v714M.st $1$dir_id/$1$dir_id.st  //把原来在copyFiles里的vos.gcc_v714M.st复制并重命名</span></span><br><span class="line"><span class="comment">cp -a fluid $1$dir_id</span></span><br><span class="line"><span class="comment">cp -a solid $1$dir_id</span></span><br><span class="line"><span class="comment">dir_id=`expr $dir_id + 1`</span></span><br><span class="line"><span class="comment">done</span></span><br></pre></td></tr></table></figure><p>StartALL.sh也做相应的调整<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dir_name=test</span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le <span class="number">61</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $dir_name$dir_id</span><br><span class="line">nohup ./submit.sh $dir_name$dir_id.st &amp;  <span class="comment">// 启动的是对应的修改后的名称</span></span><br><span class="line">cd ..</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>最后通过top来查看，效果如下，对应信息一目了然，想结束哪个直接可以看到其对应的PID。</p><p><img src="/img/20160208-4.jpg" alt="Top查看进行信息"></p><p>若干参考资料：<br>1.<a href="http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/ps.html" target="_blank" rel="noopener">ps 进程查看器</a><br>2.<a href="http://www.ha97.com/2523.html" target="_blank" rel="noopener">Linux的pkill和pgrep命令详解</a><br>3.<a href="http://www.ahlinux.com/start/cmd/2610.html" target="_blank" rel="noopener">linux对文件进行复制、移动(重命名)、删除的命令详解</a><br>4.<a href="http://init7.blog.51cto.com/860934/180474" target="_blank" rel="noopener">一个很好的命令(pkill)，一次性杀死某用户所有进程。PS：其他杀进程命令</a></p><p>若有更多操作，后续再进行更新。<br>2016年2月11日13:46:13</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-问题描述&quot;&gt;&lt;a href=&quot;#一-问题描述&quot; class=&quot;headerlink&quot; title=&quot;一. 问题描述&quot;&gt;&lt;/a&gt;一. 问题描述&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;http://liaohuming.com/2016/02/01/notes/201
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于读书的随想</title>
    <link href="http://liaohuming.com/2016/02/05/diary/20160206-%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E9%9A%8F%E6%83%B3/"/>
    <id>http://liaohuming.com/2016/02/05/diary/20160206-关于读书的随想/</id>
    <published>2016-02-05T15:25:57.000Z</published>
    <updated>2020-02-23T04:32:32.801Z</updated>
    
    <content type="html"><![CDATA[<p>一直很喜欢阅读，但阅读对我而言已经是很遥远的事情了，能算得上阅读的，最近的也只能追溯到大二大三那会儿了，也就是2007，2008年那段时间，无事的时候便去学校那碉堡似的图书馆去找一些书来看，远离了浮躁，看完一个又一个故事，一时间好似回到了03年的那个夏天：中考结束了，一波三折后终于是被我们镇上的中学录取了。接下来的每天，白天和爸爸妈妈进大坪山里做事，晚上在家里看水浒看得热火朝天，兴奋得常常凌晨一两点都不睡，这在九、十点就是万籁俱寂的农村，真是别样的感受，那会哥哥已在县一中读书了，我整天一个人，劳作让我得到锻炼，阅读让我感到充实。长长的暑假结束后，依旧清晰的记得9月份开学后的第一个晚自习，黑乎乎的我突然见到很多的新同学，像是进城了一样，那天的晚霞很美。</p><p>倒是啊，在北航的这些年常常觉得孤独，常常觉着自己无趣，多少个风雨过后的黑夜，踉踉跄跄独自走过三馆前那片伸手不见五指的小树林，无数个这样的夜里，这条走过千遍万遍的路啊，在脚下却是高高低低总也踩不准，走着走着就撞上了周围的树木，这种感觉就和我现在被禁锢的日子一般，挣扎在铜墙铁壁里处处碰壁，这夜黑得似乎永远不会有黎明的到来，这片树林长得似乎无穷无尽永远都走不出去，而我的生活似乎总也回不到正轨。这样的时候啊，我或者亢奋的唱起许巍的“蓝莲花”释放胸中的豪情，或者呢喃着齐秦的“夜夜夜夜”舒尽心底的柔情，这样的光景，我便常常不好意思起来，担心会有人听到，但跌跌撞撞总归能走出这一片黑暗。呵，就是这样的黑夜，很有奋斗的感觉，也是这样的夜，觉着自己好孤独，更觉着自己是个无趣的人，我的精力和热情多半被繁杂的项目一点点消耗，于是我变得越来越孤独，也许孤僻更合适，越来越无趣，每天只想着怎么完成任务。很显然我和现实的关系有些紧张了，这是必然的结果，长期单调索然无味的生活工作，缺乏交流、缺乏阅读。缺乏交流的结果是对他人的现状缺乏了解以致交流中出现缺乏共同话题而产生厌倦社交的潜意识暗示；而缺乏阅读则更甚，现在大都只读工具书，工具书读了很多，虽是提升了技能，并不能给精神带来滋养，一个干涸扭曲的灵魂，是不可能带来美好的，这才是万恶的根源，而通过阅读、写作、经历、感悟等诸多途径的自我锻炼是有可能获得所期待的美好的，想必那会儿会把自身的这种美好称为修养了吧，是的，因为这是一个修炼的过程，然而要达到这样泰然自若的极佳状态，没有任何人能够帮助你，非得身体力行不可，庆幸向往美好是人的本性，就像肚子饿了本能地会去找食物一样，现在的我又对阅读有了如饥似渴的需求，而一旦开始，在每天的阅读里我非常轻易的就获得了快乐，每一天都收获着美好，书中自有黄金屋，书中自有颜如玉，书中还有美金书签呢。呵，多棒。</p><p>接下来我会持续在本篇博文中更新列出今年所读完的书，并简单附上一句两句若干句即时的随想，到16年年末，看看这一年都会看完了哪些书，看看有什么有趣的事情发生。</p><hr><p><strong>1.《春风沉醉的晚上》</strong></p><p>这是买来kindle后读完的第一本，郁达夫的短篇小说。很短，耐人寻味，常常都会带着一种美好去想邓脱路贫民窟的作者和陈二妹后面怎么样了，他们的生活是否都有好转？</p><p><strong>2.《活着》</strong></p><p>余华的长篇小说，我是在和师弟去Costco的路上开始看的，我不爱出去，来到这该死的克利夫兰之后，每周的超市购物尤其让我头疼，非要我一起去的时候索性在车上看书吧，去的路上有点堵，比往常慢了许多，故事就从爱骑着胖妓女去老丈人门口大声打招呼的败家子福贵身上开始了……，读着有味。逛完超市去理发的路上总觉着时间太短，按预约时间到了理发店见到乌泱泱的前来理发的人占了我们的预约我倒暗自高兴起来，可以接着读这个故事。那天后面，半夜睡不着，起来一口气把剩下的故事读完，好的作品就是有这样的魅力，可是读着读着就不那么美好了，福贵接下来的故事开始让人愤怒、鄙视、可怜、同情、感动、感慨，一系列的感情变化。故事里写出了人对苦难的承受能力，对世界乐观的态度，那种绝望中的希望是那么的有力量。</p><p>于2016年2月6日01:15:08</p><p><strong>3.《兄弟》</strong></p><p>余华的长篇小说，分上下两部。上半部分，在文革的浪潮中，兄弟俩的父亲成为了文革的牺牲品，兄弟俩的母亲成为了接下来艰苦生活的牺牲品，随着父母的离去，精神狂热，本能压抑和命运惨烈的文革时代过去了。下半部分是近现在的故事，是一个伦理颠覆、浮躁纵欲和众生万象的时代。在小说中连接这两个时代的纽带是这兄弟两人，他们的生活在裂变中裂变，他们的悲喜在爆发中爆发，他们的命运和这两个时代一样天翻地覆，最终他们恩怨交集地自食其果。人性是复杂的，自私的弟弟、没有主见的哥哥、善变的女人，是我能够想到的并不贴切的评价。</p><p>于2016年2月13日16:04:24</p><p><strong>4.《罗马不是一天造成的》</strong></p><p>罗马人在智力上比不上希腊人，体力也逊于高卢人或日耳曼人，工艺发展也不是伊特鲁里亚人的对手，经济力更不如迦太基人优秀，但是罗马人开放包容的性格正是它超越其他民族的地方。</p><p>军事及建筑方面的成就会随时间而消逝，但是人们对于古罗马的崇敬却是永不改变的。古代罗马遗留给后世最大的遗产就是他们开放的民族性格。</p><p>讽刺的是，二千年后的现代人非但在宗教上变得狭隘，连统治理念也变得拘泥，种族之间更存在着严重的排他意识，因此罗马可以说是离我们越来越远了。</p><p>于2016年4月29日23:57:38</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直很喜欢阅读，但阅读对我而言已经是很遥远的事情了，能算得上阅读的，最近的也只能追溯到大二大三那会儿了，也就是2007，2008年那段时间，无事的时候便去学校那碉堡似的图书馆去找一些书来看，远离了浮躁，看完一个又一个故事，一时间好似回到了03年的那个夏天：中考结束了，一波三
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>命令行多参数解析时getopt()函数的使用方法小结</title>
    <link href="http://liaohuming.com/2016/02/01/notes/20160201-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%9A%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%97%B6getopt()%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://liaohuming.com/2016/02/01/notes/20160201-命令行多参数解析时getopt()函数的使用方法小结/</id>
    <published>2016-02-01T04:13:48.000Z</published>
    <updated>2017-12-13T01:36:22.078Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中，用命令行执行可执行文件时，常常涉及到：<strong>大量、不同类型、不同形式的</strong> 输入参数问题。从简单的说起，现在假设有我们一个用户定义的可执行程序，名为<code>test.sh</code>，它需要3个输入参数，于是我们通过命令行去执行它的时候，往往通过如下的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="一-main函数"><a href="#一-main函数" class="headerlink" title="一. main函数"></a>一. main函数</h3><p>上面的<code>./test.sh</code>是执行程序，<code>1、2、3</code>是<code>test.sh</code>的输入参数，这些命令项通过传递给程序的main函数进行处理，main函数的一般形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>argc是一个整型，argv是一个指针数组，argc记录argv的大小，例如<code>./test.sh 1 2 3</code>将被以如下的方式传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argc=<span class="number">4</span>；</span><br><span class="line">argv[<span class="number">0</span>]=./test.sh;</span><br><span class="line">argv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">argv[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">argv[<span class="number">3</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="二-getopt函数"><a href="#二-getopt函数" class="headerlink" title="二. getopt函数"></a>二. getopt函数</h3><p>现在我们考虑更复杂一些的输入要求，还是以<code>test.sh</code>为例，不过这时它的输入参数要更多一些了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> -a <span class="number">4</span> -b <span class="number">5</span> -c <span class="number">6</span> -Q -S -T  <span class="comment">// 此处仅作为示例，还可以有更多更复杂参数，见后续实例</span></span><br></pre></td></tr></table></figure><p>先说说这一行参数表示什么意思，这里的破折号<code>-</code>表示这是一个控制选项，例如<code>-1</code>，在此处1是单字符选项，而<code>-a 4</code>表示带参数的选项，a是该选项的标识符，4是随同该选项一同传入的参数，<code>-Q</code>，与<code>-1</code>一样，Q也是单字符选项，没有随同的输入参数。通过定义不同的选项，我们可以在<code>test.sh</code>中定义丰富的操作完成各种各样的计算任务，但是这个时候main函数可没有办法给你完成上面的解析工作，main函数只是将<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>传递进来，保存在argc和argv里，至于这些参数如何分配并对应什么操作则是需要用户自行定义了，当然，自己写解析函数是可行的，但是有更好的选择。</p><p>在C语言中，<code>unistd.h</code>提供的<code>getopt()</code>这个函数，结合<code>switch</code>语句，可以帮助我们方便实现参数解析。</p><p>先看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ( (opt=getopt(argc, argv, <span class="string">"123a:b:c:QST"</span>)) != <span class="number">-1</span> ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">      para1 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">      para2 = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">      para3 = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">      para4 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">      para4 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">      para5 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">      definedOption1 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">      definedOption2 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">      definedOption3 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>getopt()函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure><p>使用getopt函数需要包含以下头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>有几个全局变量与getopt函数解析参数有关:<br>optind：int型， 指示下一个要解析的参数位置，初始时为1。<br>optarg：char *， 必须接参数的选项元素的参数， optarg 就指向参数字符串。<br>opterr： int 型， 设为0将不打印错误信。</p><p><code>int argc, char * const argv[]</code>一般是直接通过读取main函数的argc和argv，而optstring则是用户定义的选项字符，例如在上面的例子中，optstring是 <code>123a:b:c:QST</code> ，它用来解析输入参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>，并且是由用户定义。</p><p>字符串optstring的元素一般可分为下面几种：</p><ul><li>单个字符，表示选项，<code>123a:b:c:QST</code>中的1、2、3、Q、S、T都是单字符选项</li><li>单个字符后接一个冒号<code>:</code>表示该选项后必须跟一个参数。参数紧跟在选项后以空格隔开。该参数的指针赋给optarg。<code>123a:b:c:QST</code>中的<code>a:</code>, <code>b:</code>, <code>c:</code> 都表示它们需要附加指定输入参数，这就是为什么在输入参数时是<code>-a 4 -b 5 -c 6</code>的缘故</li><li>单个字符后跟两个冒号<code>::</code>表示该选项后<strong>可选地</strong>跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张，本例中不作介绍）。</li></ul><p><em>update@2016年5月17日17:11:51</em><br>一个选项的识别符号只能是单个字符（或加上与一个冒号<code>:</code>或两个冒号<code>::</code>的组合），不能用多个字符来表示一个选项。<br>例如这样做就会识别出错：<br>用户输入的参数<code>./test.sh -1 -2 -3 -a1 4 -b 5 -c 6 -Q -S -T</code>，那么它对应的optstring则是 <code>123a1:b:c:QST</code>，显然其中<code>a1</code>为两个字符，想让它表示一个选项，是会出现问题的。</p><p>同时，getopt()在unistd.h中的相关定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">extern</span> <span class="keyword">char</span> *optarg;  <span class="comment">//选项的参数指针</span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> optind,    <span class="comment">//下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 </span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> opterr,    <span class="comment">//当opterr=0时，getopt不向stderr输出错误信息。</span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> optopt;    <span class="comment">//当命令行选项字符不包括在optstring中或者选项缺少必要的参数时,</span></span><br><span class="line">                        <span class="comment">//该选项存储在optopt中，getopt返回'?'</span></span><br></pre></td></tr></table></figure><p>那么现在就清楚用户输入的参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>是怎么进行传递和解析的了：</p><ul><li>通过main函数将输入参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>保存在argc和argv</li><li>getopt()按照<code>123a:b:c:QST</code>这个规则去解析argc和argv中保存的数据</li><li>例如，首先去<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>读取到的选项是<code>-1</code>（第一个输入参数./test.sh是执行程序是名称不予考虑），于是就去<code>123a:b:c:QST</code>中检查是否有<code>1</code>这个选项，有的话就返回该选项（这个时候就会转入相应的case执行对应的操作），同时将选项索引optind更新为输入参数的下一个位置(此处为<code>-2</code>的位置)作为下次搜索的开始位置，如果在optstring里没有找到<code>1</code>，例如我们的optstring是<code>23a:b:c:QST</code>，即当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回<code>&#39;?&#39;</code>，并从optind开始进行下一个输入参数的解析</li><li><p>继续解析，当解析到<code>-a</code>时，这个时候getopt()发现optstring里的<code>a</code>后面跟着<code>:</code>于是它知道a是还需要传递进来一个指定的参数，于是就将指针*optarg指向-a后面的一个参数即是4，这样返回选项a的时候，a所对应的参数值此时由optarg指向，这样转入<code>case &#39;a&#39;</code>的时候就可以对该参数进行相应的操作了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">  para4 = atof(optarg);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li><p>接着往下走，-Q -S -T与前面的-1是一样的，都是不带参数的单字符选择，当检查完-T后，返回-1，表示检查完毕，这个时候就完成了对<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>中所有参数的分配工作。</p></li></ul><p>上述简单介绍了命令行多参数解析时getopt()函数的用法，若有错误，欢迎斧正与探讨；若干概念引自文献[1]，若有需要相关概念更详细的解释，可前往阅读。</p><h3 id="三-实例"><a href="#三-实例" class="headerlink" title="三. 实例"></a>三. 实例</h3><p>在Eureka中进行的FSI数值算例中用到如下控制选项，整理出来作为备忘。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">500</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> -M <span class="number">0.01</span> </span><br><span class="line">-U -Q -t <span class="number">0.1</span> -T <span class="number">0.1</span> -d <span class="number">1000</span> -v <span class="number">513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> -g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> </span><br><span class="line">-i <span class="number">0.1</span> -l <span class="number">10.0</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> -K <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line">解析</span><br><span class="line">getopt(argc, argv, <span class="string">"23L:H:W:J:h:D:r:c:x:b:q:R:M:SQUt:T:d:v:f:G:k:p:g:m:s:i:l:I:A:E:P:N:n:K:"</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>控制符</strong></th><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>./$1</td><td></td><td>执行程序名称，e.g. verification_oscillation_structure.gcc_v714M.st</td><td></td></tr><tr><td>-2</td><td>2</td><td>二维</td><td></td></tr><tr><td>-3</td><td>3</td><td>三维</td><td></td></tr><tr><td>-L</td><td>290</td><td>Length</td><td></td></tr><tr><td>-H</td><td>120</td><td>Height</td><td></td></tr><tr><td>-W</td><td>0</td><td>Width</td><td></td></tr><tr><td>-J</td><td>0.1</td><td>critical_shear/maximum shear strain</td><td></td></tr><tr><td>-h</td><td>8</td><td>element size that determines the patch thickness 入口单元尺寸</td><td></td></tr><tr><td>-D</td><td>500</td><td>Domain_End 计算域终点，计算域起点为0.0</td><td></td></tr><tr><td>-r</td><td>1.5</td><td>searchRange, parameters for the shape function</td><td></td></tr><tr><td>-c</td><td>1.0e-5</td><td>cutoff, parameters for the shape function</td><td></td></tr><tr><td>-x</td><td>3.1</td><td>extension, parameters for the shape function</td><td></td></tr><tr><td>-b</td><td>1.6</td><td>beta, parameters for the shape function</td><td></td></tr><tr><td>-q</td><td>1</td><td>integration_order q=1表示单元的中心插入1个质量点</td><td></td></tr><tr><td>-R</td><td>1</td><td>nRing 邻域控制，1表示从单元本身节点开始，如果变形大，可以设置为2</td><td></td></tr><tr><td>-M</td><td>0.01</td><td>mass_factor</td><td></td></tr><tr><td>-S</td><td>true</td><td>adaptive_search</td><td></td></tr><tr><td>-Q</td><td>true</td><td>adaptive_beta</td><td></td></tr><tr><td>-U</td><td>true</td><td>updateNeighbor</td><td></td></tr><tr><td>-t</td><td>0.1</td><td>time step ratio 0.1表示10%</td><td></td></tr><tr><td>-T</td><td>0.1</td><td>total_time simulation time</td><td></td></tr><tr><td>-d</td><td>1000</td><td>dump，number of time steps to visualize the results</td><td></td></tr><tr><td>-v</td><td>513</td><td>max velocity of inflow，speed</td><td></td></tr><tr><td>-f</td><td>1.0</td><td>parameters for the rupture of solids，epsilon_h=1 包含裂纹扩展</td><td></td></tr><tr><td>-G</td><td>1.0e7</td><td>parameters for the rupture of solids</td><td></td></tr><tr><td>-k</td><td>1.42e5</td><td>the bulk modulus of fluid (2.1e9 Pa for water) 体积模量</td><td></td></tr><tr><td>-p</td><td>1.18e-6</td><td>the density of fluid (1.0e3 kg/m^3 for water)</td><td></td></tr><tr><td>-g</td><td>1.4</td><td>Gruneisen parameter in the equation of state of the fluid</td><td></td></tr><tr><td>-m</td><td>0</td><td>nuf，poisson’s ratio of the fluid</td><td></td></tr><tr><td>-s</td><td>1.82e-5</td><td>the shear viscosity coefficient of fluid (1.82e-5kg/(m.s))动力粘度</td><td></td></tr><tr><td>-i</td><td>0.1</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-l</td><td>10</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-I</td><td>0.0</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-A</td><td>0.0</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-E</td><td>2.5e6</td><td>E_Solid，Young’s modulus of solid 固体材料弹性模量</td><td></td></tr><tr><td>-P</td><td>1.0e-4</td><td>rho_Solid，density of solid 固体材料密度</td><td></td></tr><tr><td>-N</td><td>0.35</td><td>nu_Solid，Poisson’s ratio of solid 固体材料泊松比</td><td></td></tr><tr><td>-n</td><td>8</td><td>number of threads 线程数</td><td></td></tr><tr><td>-K</td><td>10</td><td></td><td></td></tr></tbody></table><h3 id="四-参考文献"><a href="#四-参考文献" class="headerlink" title="四. 参考文献"></a>四. 参考文献</h3><p>[1] <a href="http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt" target="_blank" rel="noopener">http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt</a></p><p>2016年2月1日16:18:12<br>于克利夫兰</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux中，用命令行执行可执行文件时，常常涉及到：&lt;strong&gt;大量、不同类型、不同形式的&lt;/strong&gt; 输入参数问题。从简单的说起，现在假设有我们一个用户定义的可执行程序，名为&lt;code&gt;test.sh&lt;/code&gt;，它需要3个输入参数，于是我们通过命令行去执行
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我所理解的C++类设计中private成员变量和返回const引用类型</title>
    <link href="http://liaohuming.com/2016/01/21/notes/20160121-%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84C++%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%ADprivate%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%94%E5%9B%9Econst%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liaohuming.com/2016/01/21/notes/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/</id>
    <published>2016-01-20T16:57:23.000Z</published>
    <updated>2019-09-15T08:26:24.004Z</updated>
    
    <content type="html"><![CDATA[<p>从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。</p><p>简单说说现在的需求：为了测试数值算法，需将有限元前处理器HyperMesh生成的网格文件按Eureka格式进行转换，网格文件格式已知，目标文件格式已知，那么要做的事情就是把网格文件解析，然后按目标格式存储即可实现目标，这是一般的做法。</p><p>如果以后换了一种格式，那么可能又要重新写过转换程序了，并没有通用性。能想到的解决方法，自然是设计一个类，这个类和输出什么格式没有任何关系，这个类只是单纯的将网格文件的所有有效数据（例如：nodes、elements、sets等等）保存在类中，用户只需要直接引用或继承这个类，就可以访问到所有的网格数据，进而根据自己的需求输出想要的格式。</p><p>这样的思路，其实是数据解析、数据存储（类来保存）、数据重组（用户自定义）的过程，由于输出不是这个类考虑的，而是由用户来决定，因此有了通用性。</p><p>在设计这个类的时候遇到了几个问题，下面说说：</p><h3 id="一-将成员变量声明为private"><a href="#一-将成员变量声明为private" class="headerlink" title="一. 将成员变量声明为private"></a>一. 将成员变量声明为private</h3><p>最开始我是用public的，简单嘛，这也是我一直以来的做法，[黎老师][2] 看了之后提出了修改要求，作为一个完善、安全、高效的类，必须把成员变量声明为私有类型，即private，如果你没有用过，你就一直没有概念，我就是这样，于是我找了《C++ Primer》和《Effective C++》相关的内容补充了一下概念，最重要的是封装性。</p><p><strong>封装性</strong></p><p>成员变量声明为private后，只能通过成员函数进行访问，因此如果以后对成员变量有改动，例如以某个计算替换这个成员变量或者是其他的一些改动，使用这个类的用户并不知道，也不会受到影响，顶多重新编译一下。</p><p>将成员变量声明为private后就对使用这个类的用户隐藏了成员变量，即封装，这样便确保了class的约束条件总是会获得维护，因为只有成员函数可以影响它们，并且保留了日后变更实现的权利。如果不隐藏它们，我们很快会发现，即使拥有class原始代码，改变任何public事物的能力还是极端受到束缚，因为那会破坏太多的用户代码。public意味着不封装，不封装意味着不可改变，特别是对被广泛使用的classes而言。</p><p>假设我们有一个public成员变量，而我们修改甚至最终取消了它，那么多少代码会被破坏呢？取决于该class被使用的范围，如果就你自己用，可能修改代码的工作量是可以接受的，如果有更多一些人用，那么被破坏的代码就是一个未知量，往往是很大的。</p><p>一旦你将一个成员变量声明为public而用户开始使用它，就很难改变那个成员变量涉及的一切，太多的代码需要重写、重新测试、重新编写文档和重新编译，可见在一个类的设计之初，考虑周全是多么的重要。</p><p>除了public类型之外，protected类型同样也存在封装问题（此处不展开），因此从封装的角度，就只有两种访问权限：<strong>private提供封装</strong> 和 <strong>其他不提供封装</strong>。</p><p>上述封装讨论源自参考文献[1]并结合我的理解。</p><h3 id="二-将访问private成员变量的成员函数定义为“返回const引用类型”"><a href="#二-将访问private成员变量的成员函数定义为“返回const引用类型”" class="headerlink" title="二. 将访问private成员变量的成员函数定义为“返回const引用类型”"></a>二. 将访问private成员变量的成员函数定义为“返回const引用类型”</h3><p>前面讲到了将成员变量声明为private，通过提供成员函数来访问这些private变量。那么现在就有一个问题，这些成员函数怎么设计才合适呢？基于本文的目的是想将这个class设计成适用于各种有限元计算，这个类只要将Hypermesh网格文件作为输入，这个类便完全提取并保存了数据，这些数据可以直接被用户在各自的有限元计算代码中调用，也可以按用户的指定的格式输出。对于第一种直接应用的情况，由于网格数量巨大，计算过程中有大数量级的数据操作，因此我们需要从成员函数访问private变量的效率方面进行考虑。</p><p><font color="red"><strong>首先说说引用类型</strong><font></font></font></p><p>“引用类型”（reference type）是C++的一种<strong>变量类型</strong>，它的作用是为变量起一个别名。<br>假如有一个变量a，想给它起一个别名，可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure></p><p>这就表明了b是a的“引用”，即a的别名。经过这样的声明，使用a或b的作用相同，都代表同一变量。在上述引用中，&amp;是“引用声明符”，并不代表地址，可以这样理解：在这里int&amp;是一种变量类型，它和int、double、string一样，都是一种变量的类型。不要理解为“把a的值赋给b的地址”。</p><p><font color="red"><strong>其次说说函数返回值</strong><font></font></font></p><p>在这里主要讨论返回值的类型为：引用类型和非引用类型</p><p>函数返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值拷贝给临时对象，这样的话，每调用一次该函数就会得到一个新的拷贝值。因此如果我们设计的成员函数，获得的是private变量的一个拷贝，那么在大数级量的操作中就会消耗不可估量的内存，因此对于这种问题，需要我们的成员函数获得的是private变量的一个引用，由于计算过程中的调用，并没有拷贝变量，而是直接引用原对象，因此能节约内存同时不需要拷贝也提高了效率。</p><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; AskElementData(<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3);</span><br><span class="line"></span><br><span class="line">上面复杂的函数其实是以下这个形式：</span><br><span class="line"></span><br><span class="line"><span class="function">type&amp; <span class="title">FunctionName</span><span class="params">(type&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>type&amp; FunctionName()</strong>即代表，函数返回的是引用类型，这样，成员函数返回的则是引用。</p><p><font color="red"><strong>然后说说返回const引用类型</strong><font></font></font></p><p>试想，类中保存着诸多的数据，单元节点、节点坐标等，由于我们提供的成员函数是对原private变量的直接引用，用户对该引用的任何修改都是直接对原变量的修改，这样会导致数据的不安全，即便一般情况下用户不会主动去修改原始数据，但是不排除误操作的情况，从数据安全角度，应该从类的设计上杜绝这种修改的可能性，而不是靠用户的自律性来维护。<strong>在这里突然很想说个个人观点，一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。</strong>只是突然想到的。回归正题，那么const关键字则提供了这样的功能，const类型的引用，既避免了复制的低效高耗操作又能防止用户直接对引用变量进行修改的可能，多么好，是吧。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line"><span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>接下来谈谈对type&amp; functionName(type&amp;)中形参type&amp;的困惑</strong><font></font></font></p><p>由于我之前的编程经验都是野路子，并没有太多系统的知识，在明白了<strong>const type&amp; functionName()</strong>之后，还有一个困惑，那就是为什么函数的形参中需要一个引用类型的参数<strong>(type&amp;)</strong>呢？</p><p>这还得从返回的变量说起，如果我们的成员函数定义的是返回非引用类型，那么它是可以返回局部变量的，因为返回非引用类型，返回的是原变量的一个拷贝值，所以，当成员函数执行完毕，在它函数体内定义的局部变量虽然被销毁，但是返回的是该局部变量的一个拷贝值，这个拷贝值独立于原变量，所以这样用是没有问题的。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; tria3; <span class="comment">// 局部变量</span></span><br><span class="line">tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line"><span class="keyword">return</span> tria3; </span><br><span class="line"><span class="comment">// 返回的是tria3的一个拷贝，所以当AskElementData()执行完毕，</span></span><br><span class="line"><span class="comment">// tria3被销毁，AskElementData()返回的拷贝值是依然存在可用的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们定义的成员函数是返回引用类型，当成员函数执行完毕时，将释放分配给局部变量的存储空间，此时对局部变量的引用就会指向不确定的内存，返回指向局部变量的指针也是一样的，当函数结束时，局部变量被释放，返回的指针就变成了不再存在的变量的悬垂指针。</p><p>例如下面这种做法是错误的：返回局部变量的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; element_tria3; <span class="comment">// 局部变量</span></span><br><span class="line">tria3 = element_tria3; <span class="comment">// 对局部变量的引用</span></span><br><span class="line"><span class="keyword">return</span> tria3; <span class="comment">// 返回的是对局部变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么就明确了，如果你的成员函数要返回的是对变量的引用，那么它不可以是局部变量。</strong></p><p><strong>而，返回非局部变量的引用时，要求在函数的形参中，包含有以引用方式或指针方式存在的，需要被返回的参数。</strong></p><p>例如我们现在所讨论的类中的private成员变量，下面的做法也是错误的，因为它的形参中没有提供以引用方式或指针方式存在的，需要被返回的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3 = _element_tria3; <span class="comment">// 对private变量的引用</span></span><br><span class="line"><span class="keyword">return</span> tria3; <span class="comment">// 引用类型变量tria3是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的用法应该是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3) <span class="comment">// 提供一个引用方式存在的需要返回的参数</span></span><br><span class="line">&#123;</span><br><span class="line">tria3 = _element_tria3;</span><br><span class="line"><span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>最后总结一下</strong><font></font></font></p><p>根据前面的需求分析，本文设计的类需要：</p><ul><li>类的成员变量为私有类型private</li><li>用来访问private成员变量的是返回const引用类型的成员函数</li></ul><p>所以最后采用的是下面这个形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">tria3 = _element_tria3;</span><br><span class="line"><span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> type&amp; <span class="title">FunctionName</span><span class="params">(type&amp; xx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">xx = privateObject;</span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于这方面的总结大概就是这些了，日后若有进一步的理解再进行补充。<br>以上内容皆为个人理解，有错之处欢迎斧正和讨论。</p><p>2016年1月21日03:23:06<br>于克利夫兰</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 《Effective C++》第三版，条款22。<br>[2]: <a href="http://engineering.case.edu/emae/Faculty/Bo_Li" target="_blank" rel="noopener">http://engineering.case.edu/emae/Faculty/Bo_Li</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。&lt;/p&gt;
&lt;p&gt;简单说说现在的需求：为了测
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>If you never try, you will never know.</title>
    <link href="http://liaohuming.com/2016/01/06/diary/20160106-If%20you%20never%20try,%20you%20will%20never%20know/"/>
    <id>http://liaohuming.com/2016/01/06/diary/20160106-If you never try, you will never know/</id>
    <published>2016-01-06T15:34:52.000Z</published>
    <updated>2020-02-23T04:32:38.480Z</updated>
    
    <content type="html"><![CDATA[<p>2015-12-7<br>Writing</p><p>2015-12-8<br>Writing</p><p>2015-12-9<br>Reading</p><p>2015-12-10-?<br>I don’t know where is the end, I felt very discouraged.<br>Still reading and writing.</p><p>go on and on and on ……</p><p>……</p><p>2016-1-6<br>Done.</p><p>My first paper,<br>twenty-eight pages, ten thousand words.<br>If you never try, you will never know what you can do.<br>I am ready for the next challenge.</p><hr><p>正所谓一鼓作气，再而衰，三而竭。PDS这篇论文，修修改改大半年，今天论文投出去了，没有一点高兴。没有<a href="http://liaohuming.com/2016/08/18/diary/20160818-%E6%9C%80%E8%BF%91/">LME</a>论文一个月搞定时的那种兴奋感。<br>Anyway，两篇SCI，在一年访学行将结束之际总算都投出去了，不管结果如何，至少压在心头的两块大石头暂时先抛出去了。接下来等待评审的消息了。</p><p>@2016年9月12日21:06:25</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2015-12-7&lt;br&gt;Writing&lt;/p&gt;
&lt;p&gt;2015-12-8&lt;br&gt;Writing&lt;/p&gt;
&lt;p&gt;2015-12-9&lt;br&gt;Reading&lt;/p&gt;
&lt;p&gt;2015-12-10-?&lt;br&gt;I don’t know where is the end, I felt
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>重拾</title>
    <link href="http://liaohuming.com/2015/04/02/diary/20150402-%E9%87%8D%E6%8B%BE/"/>
    <id>http://liaohuming.com/2015/04/02/diary/20150402-重拾/</id>
    <published>2015-04-02T13:13:38.000Z</published>
    <updated>2020-02-23T04:32:50.968Z</updated>
    
    <content type="html"><![CDATA[<p>13年5月后我就再也没有只言片语了，感觉把自己抛弃了一般，实是不应该。</p><p>与自己内心对话是非常重要的，虽然现在回看过去，感觉自己就是个神经病，但是我却非常怀念这样的状态。</p><p>嗯。重拾。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;13年5月后我就再也没有只言片语了，感觉把自己抛弃了一般，实是不应该。&lt;/p&gt;
&lt;p&gt;与自己内心对话是非常重要的，虽然现在回看过去，感觉自己就是个神经病，但是我却非常怀念这样的状态。&lt;/p&gt;
&lt;p&gt;嗯。重拾。&lt;/p&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>就像一个被抛弃的孩子一样无助</title>
    <link href="http://liaohuming.com/2012/08/06/diary/20120806-%E5%B0%B1%E5%83%8F%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%8A%9B%E5%BC%83%E7%9A%84%E5%AD%A9%E5%AD%90%E4%B8%80%E6%A0%B7%E6%97%A0%E5%8A%A9/"/>
    <id>http://liaohuming.com/2012/08/06/diary/20120806-就像一个被抛弃的孩子一样无助/</id>
    <published>2012-08-06T11:49:48.000Z</published>
    <updated>2020-02-23T04:32:59.407Z</updated>
    
    <content type="html"><![CDATA[<p>去年的时候，一个老同学好朋友，向我买淘宝账号，说想开个小店。</p><p>自从上研后，我便不再繁于业务，虽是不再用了，但是这相伴我多年的账号，这许些年的生活费都是它卖力挣得，这即是另一个我。我断然是不会卖的，只是老朋友开口，又不好拒绝，于是就提出借用，并叮嘱一定好生照顾好这个账号。</p><p>只要想起来时就会去点击收藏夹中店铺的网址。就看看。<br>这种感觉就好像，每次回乡，心底里希望家乡的面貌越变越美好。</p><p>可是，说过的小店，从没成功出现过，隐约记得有过几个出售的商品，破烂不堪。<br>并不是卖的东西不好，只是一眼就可以令人看出，这是一个没有用心做事的人。<br>我想，也许，还不熟悉吧。</p><p>后来，点击网址，已是什么都没有了。<br>再后来，收到哥哥的电话，问我的号是不是被盗了，一直给他发不良信息。</p><p>当即，我便测试了账号，已是被锁定了，而据上次正常登陆时间也是大半年之前，近期被盗被用于群发广告。<br>想必老同学已是非常久都没登过了。</p><p>打了个电话过去，问是否还在用，却回答说，一直都在用，前几天都还在传东西上去。<br>我说号被盗了，很久都没有登陆过了。<br>于是改口说，上个月还用过。<br>我说你还要用就用吧，被盗了，你先把号找回来吧，别一直发骗人的信息。<br>好好好。</p><p>好多天，过去了，好好好，也不见动静。<br>见你于如此水深火热，我还指望着他人。<br>突然对自己的愚蠢感到无尽的愤怒。<br>通过与客服的各种验证，终于要回了账号。</p><p>这一登陆，已是面目全非，所有分组下的好友显示名，都被程序加上数字编号，用于群发信息。<br>看着一个个熟悉的id，竟然都成了这样，心痛不已。</p><p>我曾经是那么的爱惜你，多少次追着那些愚蠢的买家解释，各种赔偿，只为保持住你100%的好评。<br>而如今我却将你抛弃，我不曾想到这是让你过起了有后妈的日子，我更不曾想到，会是这么糟蹋你。</p><p>我把一切信息都修改回我自己的信息。<br>对不起，我让你这么长一段时间，像一个被抛弃的孩子一样无助。</p><p>如果觉得自己坦诚相待是没有错的，那么也不要觉得别人占有欲太强也是有错的。<br>如果觉得自己善始善终是没有错的，那么别人就是做事有头无尾就有错吗？</p><p>老同学还是老同学，好朋友还是好朋友。<br>对自己有意义的东西，不见得对别人就有。<br>正确的处事方式，不见得别人就认同。</p><p>自己能做到的事，每次都做到即可，也不能强求别人就一定也要这么做。</p><p>无论如何，将心爱的东西借给别人，而遭受迫害。<br>罪魁祸首都应该是自己。</p><p>只是，如果是我借到了朋友心爱的东西，我想我会倍加珍爱的。<br>没有什么是不可以拒绝的，该拒绝的就拒绝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年的时候，一个老同学好朋友，向我买淘宝账号，说想开个小店。&lt;/p&gt;
&lt;p&gt;自从上研后，我便不再繁于业务，虽是不再用了，但是这相伴我多年的账号，这许些年的生活费都是它卖力挣得，这即是另一个我。我断然是不会卖的，只是老朋友开口，又不好拒绝，于是就提出借用，并叮嘱一定好生照顾好
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>愿今天的傻逼会成为明日的弥足珍贵</title>
    <link href="http://liaohuming.com/2012/04/16/diary/20120416-%E6%84%BF%E4%BB%8A%E5%A4%A9%E7%9A%84%E5%82%BB%E9%80%BC%E4%BC%9A%E6%88%90%E4%B8%BA%E6%98%8E%E6%97%A5%E7%9A%84%E5%BC%A5%E8%B6%B3%E7%8F%8D%E8%B4%B5/"/>
    <id>http://liaohuming.com/2012/04/16/diary/20120416-愿今天的傻逼会成为明日的弥足珍贵/</id>
    <published>2012-04-16T09:58:58.000Z</published>
    <updated>2020-02-23T05:08:45.895Z</updated>
    
    <content type="html"><![CDATA[<p>上周六，秋嫂考研成功宴请在京人士，秋哥也终有闲暇，给我过起生日来了，众人大喜，豪饮醉归。<br>第二天醒来，头晕脑胀，不知昨夜如何归来，只觉饥肠辘辘，于是三步并作两步走，于路就近找了些东西填肚子。</p><p>吃完饭，想起昨夜是骑单车去赴宴的，现在它却不知在何处了，一时情感泛滥，内心愧疚无限。<br>于是信步来到东北虎菜馆，看看小车尚在否，放眼扫去，目及之处，并无你的身影。<br>于是又来到教学区北门看了看，亦不在此，无奈醉意未退，头晕的很，拖着疲惫的身子便回去了。</p><p>晚上吃饭的时候，秋哥说，明天你去买车，买过一辆新的。<br>我却没有萌生这样的想法，倒是不缺这三五百块钱。<br>总是觉着，事情不该是这样的，甚至我都还没搞明白是被偷了还是被我遗失在哪个角落了。<br>我要找到你，即便最后没有结果，我也要让自己内心拥有一份曾经努力过的平静。</p><p>新欢有的仅仅是欢，旧爱虽旧却是爱。</p><p>于是中午又来到东北虎菜馆，此次甚为仔细，盯着每辆车子看，都觉得像，如果车子是人，我敢保证其中的一些都被我盯得不好意思了。<br>可却是没有你。</p><p>我想想，还会在哪呢？就还剩东南门的车棚和教学区小南门没去了。<br>我纵身越过天桥楼梯的栅栏，跳上天桥楼梯，快速穿过天桥，来到东南门车棚。</p><p>眼前一亮，眼前又一亮，终究不是。</p><p>拖着疲惫的脚步，沿着北航新建的还未命名的艺术馆走着，懒懒的看着楼前破旧的车子。<br>看看你们失魂落魄的样子吧，想必你们也是被主人抛弃了。</p><p>看着路上匆匆行人，感受头上灼灼烈日，突然一种孤独寂寞冷涌上心头。<br>心里不禁害臊想到，找一辆单车至于弄得像找情人似的落魄么。</p><p>在逸夫楼前，我说，算了吧，回去。<br>可脚步却迈向了最后一个未去的地方。</p><p>现实版的众里寻你千百度，走着看着，终见你在小南门栅栏停车处。<br>再见到暖暖阳光下灰头土脸的你，安静如斯。<br>此刻，不是拥有新欢的激动和快乐，而是找回旧爱的平静和踏实。</p><p>你是否曾埋怨过我，骑在你身上这么多年，只一个晚上工夫就把你抛弃了呢？<br>呵，这么形容有点花花公子无情郎的味道。我想我不是，所以我出现了。</p><p>还记得有多少次，你在努力的最后时刻因为没有坚持下去而放弃了？<br>还记得有多少人，你在懵懵懂懂间就莫名其妙的不欢而散了呢？</p><p>也许，只要再多坚持一会，就成功了。<br>也许，只要一回头，就会发现，其实那人一直都在，从未走远。</p><p>在哪里跌倒的在哪里爬起来，在哪里失去的在哪里找寻回来。<br>愿今天的傻逼会成为明日的弥足珍贵。</p><p><img src="/img/20120416.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周六，秋嫂考研成功宴请在京人士，秋哥也终有闲暇，给我过起生日来了，众人大喜，豪饮醉归。&lt;br&gt;第二天醒来，头晕脑胀，不知昨夜如何归来，只觉饥肠辘辘，于是三步并作两步走，于路就近找了些东西填肚子。&lt;/p&gt;
&lt;p&gt;吃完饭，想起昨夜是骑单车去赴宴的，现在它却不知在何处了，一时情
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>疲惫的一天</title>
    <link href="http://liaohuming.com/2012/04/09/diary/20120409-%E7%96%B2%E6%83%AB%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <id>http://liaohuming.com/2012/04/09/diary/20120409-疲惫的一天/</id>
    <published>2012-04-09T11:30:54.000Z</published>
    <updated>2020-02-23T04:33:10.582Z</updated>
    
    <content type="html"><![CDATA[<p>四月份的北京城，天气大好，饥肠辘辘的忙了一天，拖着疲惫的身体，穿过洒满斜阳的校园…<br>吃完饭，回寝室冲个凉，又是精神焕发，于是整装再出发<br>路上，路过蛋糕店，买了些，路过饮料店，买了些…</p><p>踩着单车，听着亢奋的曲子，享受着这美妙的时光…<br>还有，教学区北门，锁车时遇到的那个天然呆的小女孩…</p><p>一切都是那么的美妙，我想，用不了多久，我就会开始怀念这样的生活了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;四月份的北京城，天气大好，饥肠辘辘的忙了一天，拖着疲惫的身体，穿过洒满斜阳的校园…&lt;br&gt;吃完饭，回寝室冲个凉，又是精神焕发，于是整装再出发&lt;br&gt;路上，路过蛋糕店，买了些，路过饮料店，买了些…&lt;/p&gt;
&lt;p&gt;踩着单车，听着亢奋的曲子，享受着这美妙的时光…&lt;br&gt;还有，教学
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>坚强与脆弱</title>
    <link href="http://liaohuming.com/2012/03/01/diary/20120301-%E5%9D%9A%E5%BC%BA%E4%B8%8E%E8%84%86%E5%BC%B1/"/>
    <id>http://liaohuming.com/2012/03/01/diary/20120301-坚强与脆弱/</id>
    <published>2012-03-01T12:37:58.000Z</published>
    <updated>2020-02-23T04:33:14.190Z</updated>
    
    <content type="html"><![CDATA[<p>总是在病痛的时候才想起健康的重要，<br>也总是在病痛的时候方才意识到自己是多么的脆弱，<br>我的脆弱则体现在从小到大我总是不断的生病不断的生病。</p><p>这几天总是噩梦连连，<br>每天早上起来，对着镜中的自己，笑笑。<br>新的一天，多美好。</p><p>如果可以将每个人的身体比作一个世界，<br>那么在我的世界里每天都进行着世界大战，<br>我的坚强则体现在我依然好好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总是在病痛的时候才想起健康的重要，&lt;br&gt;也总是在病痛的时候方才意识到自己是多么的脆弱，&lt;br&gt;我的脆弱则体现在从小到大我总是不断的生病不断的生病。&lt;/p&gt;
&lt;p&gt;这几天总是噩梦连连，&lt;br&gt;每天早上起来，对着镜中的自己，笑笑。&lt;br&gt;新的一天，多美好。&lt;/p&gt;
&lt;p&gt;如果
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
