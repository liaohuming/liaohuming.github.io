<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huming</title>
  
  <subtitle>生活是一种慢，慢慢就会懂</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaohuming.com/"/>
  <updated>2022-11-18T12:58:33.182Z</updated>
  <id>http://liaohuming.com/</id>
  
  <author>
    <name>廖祜明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git使用笔记</title>
    <link href="http://liaohuming.com/2022/04/20/20220420-Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://liaohuming.com/2022/04/20/20220420-Git使用笔记/</id>
    <published>2022-04-20T07:40:47.000Z</published>
    <updated>2022-11-18T12:58:33.182Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>强制覆盖本地代码（与git远程仓库保持一致）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all<span class="comment">//拉取所有更新，不同步</span></span><br><span class="line">git reset --hard origin/master<span class="comment">//本地代码同步线上最新版本，会覆盖本地所有与远程仓库上同名的文件</span></span><br><span class="line">git pull<span class="comment">//再更新一次，其实也可以不用，第二步命令其实做过了 </span></span><br><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull</span><br><span class="line"><span class="comment">//命令连接符“&amp;&amp;”的意思是前一条命令执行成功才执行后一条命令</span></span><br><span class="line"><span class="comment">//命令连接符“;;”的意思是不论前一条是否执行成功都继续执行后一条命令</span></span><br></pre></td></tr></table></figure></li><li><p>删除本地文件/文件夹，并提交到远程仓库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm test.txt<span class="comment">//先删除工作区中的test.txt文件，如果是删除某个目录，则要执行：git -rm test -rf</span></span><br><span class="line">git status<span class="comment">//可以通过status查看变化</span></span><br><span class="line">git checkout<span class="comment">//如果是误删，可从本地库中检出恢复</span></span><br><span class="line"><span class="comment">//git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除</span></span><br><span class="line">git rm test.txt<span class="comment">//删除本地库中的test.txt文件</span></span><br><span class="line">git commit -m <span class="string">"del test.txt"</span><span class="comment">//提交本地版本库</span></span><br><span class="line">git push origin master<span class="comment">//将本地版本库的修改，提交到远程仓库</span></span><br></pre></td></tr></table></figure></li><li><p>修改文件/文件夹名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git mv -f oldfolder newfolder</span><br><span class="line">git add -u newfolder<span class="comment">//-u会更新已经追踪的文件和文件夹</span></span><br><span class="line">git commit -m <span class="string">"rename folder"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li><p>增加文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add filename<span class="comment">//或者git add *</span></span><br><span class="line">git commit -m <span class="string">"add files"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li><p>增加文件夹</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add directoryName/</span><br><span class="line">git add -f directoryName/<span class="comment">//或者对于一些可能不建议同步的文件，需要强制添加 </span></span><br><span class="line">git commit -m <span class="string">"add dir"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;强制覆盖本地代码（与git远程仓库保持一致）&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://liaohuming.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Definition of kinds of boundary conditions</title>
    <link href="http://liaohuming.com/2020/02/23/20200223-Definition%20of%20kinds%20of%20boundary%20conditions/"/>
    <id>http://liaohuming.com/2020/02/23/20200223-Definition of kinds of boundary conditions/</id>
    <published>2020-02-23T04:37:01.000Z</published>
    <updated>2022-11-18T11:47:53.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Boundary-conditions"><a href="#1-Boundary-conditions" class="headerlink" title="1. Boundary conditions"></a>1. Boundary conditions</h3><p>There are many type of boundary conditions, most widely used are <strong>Natural</strong> boundary conditions, <strong>Essential</strong> boundary conditions, <strong>Dirichlet</strong> boundary conditions and <strong>Neumann</strong> boundary conditions. In a boundary value problem, what’s the difference between Essential boundary condition and Natural boundary conditions?</p><p>The two types of boundary conditions are used:</p><ul><li>Essential or geometric boundary conditions which are imposed on the primary variable like displacements, and</li><li>Natural or force boundary conditions which are imposed on the secondary variable like forces and tractions.</li></ul><p>Essential boundary conditions are conditions that are imposed explicitly on the solution and natural boundary conditions are those that automatically will be satisfied after solution of the problem. In the case of Finite Element approximations, the essential conditions will be exactly satisfied but the natural conditions only up to the order of the method. In many cases, the essential conditions correspond to Dirichlet boundary conditions when the problem is written as a boundary value problem for a partial differential equation. The natural condition corresponds to a Neumann condition, a stress-free condition, or something similar, depending on the problem. However, there are cases that are not so clear cut, so to identify $Dirichlet=essential$ and $Neumann=natural$ is not really correct. For instance, Dirichlet conditions can be assigned as natural conditions using Nitsche’s method, and Neumann conditions can be transformed to essential conditions using so-called mixed methods.</p><p>E.g. I am looking at the Ritz method for the following problem<br>$$<br>    -\frac{d^{2}u}{dx^{2}}-u+x^{2}=0, 0&lt;x&lt;1<br>$$<br>with boundary conditions $u(0)=0$ and $\displaystyle\frac{du}{dx}\mid_{x=1}=1$. </p><p>The last derivative term, how do I know whether that is a natural or essential BC? I have googled the following guidelines but I am still confused. Specification of the primary variable ($u$ in this case) is an essential BC. Specification of a secondary variable (like a force $F$, not present in this example) is a natural boundary condition. If a boundary condition involves one or more variables in a <strong>direct</strong> way it is essential otherwise it is natural. Direct implies excluding derivative of the primary function.</p><p>As I understand the difference: what is meant is that direct gives an expression that yields a definite value for (in this case) $u$. </p><p>For example,<br>$$<br>    u(0) = 0,<br>$$<br>says that at $x=0$ the value of $u$ is $0$. This is contrasted by natural expression which does not lead to a definite value of $u$.</p><p>For example,<br>$$<br>    \left[ \frac{du}{dx}\right]_{x=1}=1,<br>$$<br>does not yield a definite value for $u$ at $x = 1$ since a curve of slope $1$ can be drawn through any value of $u$.</p><h3 id="2-Local-Maximum-Entropy-shape-function"><a href="#2-Local-Maximum-Entropy-shape-function" class="headerlink" title="2. Local Maximum Entropy shape function"></a>2. Local Maximum Entropy shape function</h3><p>The Local Maximum Entropy shape function have a weak Kronecker-delta property at the boundary. Here the weak Kronecker-delta property at the boudary means at the boundary, the shape function value of a specified point equal to $1$ and the shape function values of other points equal to $0$. This property ensures that the values of the peformance function equal to what they should be (as user defined or as the engineering deifined) at the boundary. This is essential boundary condition/Dirichlet. So we say LME shape function enalbes the direct imposition of boundary conditions and furnishes automatic compatibility between fluids and solids or structures.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Boundary-conditions&quot;&gt;&lt;a href=&quot;#1-Boundary-conditions&quot; class=&quot;headerlink&quot; title=&quot;1. Boundary conditions&quot;&gt;&lt;/a&gt;1. Boundary conditions
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数值计算" scheme="http://liaohuming.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统下采用命令行编译C++ MPI程序</title>
    <link href="http://liaohuming.com/2020/02/22/20200222-Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%87%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91C++%20MPI%E7%A8%8B%E5%BA%8F/"/>
    <id>http://liaohuming.com/2020/02/22/20200222-Windows系统下采用命令行编译C++ MPI程序/</id>
    <published>2020-02-22T12:34:05.000Z</published>
    <updated>2022-11-18T11:48:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-目的"><a href="#一-目的" class="headerlink" title="一. 目的"></a>一. 目的</h3><p>目标程序比较大，之前主要是在Liunx下进行程序的开发、编译与使用，现在想在Windows下进行开发、编译与使用。为了实现跨平台，程序的编译过程不宜采用Visual Studio IDE建立的Solution进行编译，否则更换编译器时，VS的Soultion就用不了了。</p><p>理想的方式是自己编写程序编译的脚本文件，采用命令行编译的方式，程序使用的开发语言是C++，并采用MPI进行并行化。为此，本文记录如何在Windows系统下采用命令行编译C++ MPI程序。</p><h3 id="二-C-编译过程"><a href="#二-C-编译过程" class="headerlink" title="二. C++ 编译过程"></a>二. <a href="https://blog.csdn.net/leonliu06/article/details/78229534" target="_blank" rel="noopener">C++ 编译过程</a></h3><p>一般而言，对于 C++ 程序编译有以下4个阶段：</p><p><strong>预处理（preprocessing）</strong><br>对源程序中的伪指令（以#开头的指令）和特殊符号进行处理。伪指令包括宏定义、条件编译指令、头文件包含指令等。</p><p><strong>编译（compilation）</strong><br>将预处理后的文件编译生成后缀为.s的汇编语言文件，。编译程序所要做的工作是通过记法分析和语法分析，在确认所有指令都符合语法规则后，将其翻译成等价的中间代码或汇编代码。</p><p><strong>汇编（assembly）</strong><br>将汇编文件汇编生成后缀为.o的目标文件（二进制）。汇编过程实际上是指把汇编语言代码翻译成目标机器指令的过程。</p><p><strong>链接（linking）</strong><br>将多个目标文件和库连接生成后缀为.out或.exe的可执行文件。链接程序的主要工作就是将有关的目标文件彼此相连接，即将在一个文件中引用的符号现该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><p><strong>链接处理</strong><br>静态链接（static linking）:指链接器在链接时将库（静态库）的内容拷贝到可执行程序中。<br>动态链接（dynamic linking）:指程序运行时才将库（动态链接库）连接到程序中。</p><h3 id="三-环境"><a href="#三-环境" class="headerlink" title="三. 环境"></a>三. 环境</h3><ol><li>Windows 10 操作系统</li><li>安装Visual Studio Professional 2017</li><li>安装MSMPI，安装路径为：<code>D:\Program Files (x86)</code>，具体的安装教程可参考<a href="https://zhuanlan.zhihu.com/p/109402594?utm_source=wechatMessage_article_bottom" target="_blank" rel="noopener">Win10下Microsoft MPI（MSMPI）的下载安装</a>这篇文章.</li><li>将要编译程序的版本为：x64</li></ol><h3 id="四-编译方法"><a href="#四-编译方法" class="headerlink" title="四. 编译方法"></a>四. 编译方法</h3><ol><li>方法一：Visual Studio Professional 2017 IDE环境下的编译，详见<a href="https://blog.csdn.net/hsajas/article/details/80103414" target="_blank" rel="noopener">VS2017配置MPI</a>文章介绍</li><li>方法二：命令行编译C++ MPI程序。参考：<a href="https://stackoverflow.com/questions/50195657/how-to-compile-and-run-c-c-mpi-codes-in-cmd-on-windows-without-visual-studio" target="_blank" rel="noopener">How to compile and run C/C++ MPI codes in cmd on windows without Visual Studio</a></li></ol><p>具体步骤为：</p><ol><li><p>建立一个简单的mpi c++代码，如：MpiHelloWorld.cpp，并保存，例如：E:\Desktop\MPI_Test\MpiHelloWorld.cpp，接下来就采用命令行对此源代码进行编译</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#include<span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> myid, numprocs;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Init</span>(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(<span class="built_in">MPI_COMM_WORLD</span>, &amp;myid);</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(<span class="built_in">MPI_COMM_WORLD</span>, &amp;numprocs);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%d Hello world from process %d \n"</span>, numprocs, myid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开开始菜单中的<code>x64 Native Tools Command Prompt for VS 2017</code>工具，用vs自带的命令行工具，可以方便地调用cl.exe和link.exe，如果不想用vs自带的命令行工具，也可以使用windows原始的cmd命令行工具，不过这种情况下需要自己手动定义好vs的引用目录和库文件目录的环境变量。此处采用的是vs提供的命令行工具。<br><img src="/img/20200222-1.jpg" alt=""></p></li><li><p>切换至MpiHelloWorld.cpp文件所在目录</p></li></ol><p>首先编译，在该目录下执行以下命令：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl -I"D:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft SDKs<span class="symbol">\M</span>PI<span class="symbol">\I</span>nclude" -I"D:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft SDKs<span class="symbol">\M</span>PI<span class="symbol">\I</span>nclude<span class="symbol">\x</span>64" -c MPIHelloWorld.cpp</span><br></pre></td></tr></table></figure></p><p>其中，cl为cl.exe编译器，-I（大写的i）表示指定第一个寻找头文件的目录（如果指定多个目录，则使用多个-I），在本例中要将MPI的两个Include目录包含进去。-c表示只编译不链接。编译完之后可以看到当前目录下生成了MPIHelloWorld.obj汇编文件<br><img src="/img/20200222-2.jpg" alt=""></p><p>然后链接，在该目录下执行以下命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">link</span> <span class="selector-tag">-machine</span><span class="selector-pseudo">:x64</span> <span class="selector-tag">-out</span><span class="selector-pseudo">:MpiHelloWorld.exe</span> <span class="selector-tag">-dynamicbase</span> "<span class="selector-tag">msmpi</span><span class="selector-class">.lib</span>" <span class="selector-tag">-libpath</span><span class="selector-pseudo">:"D</span>:\<span class="selector-tag">Program</span> <span class="selector-tag">Files</span> (<span class="selector-tag">x86</span>)\<span class="selector-tag">Microsoft</span> <span class="selector-tag">SDKs</span>\<span class="selector-tag">MPI</span>\<span class="selector-tag">Lib</span>\<span class="selector-tag">x64</span>" <span class="selector-tag">MPIHelloWorld</span><span class="selector-class">.obj</span></span><br></pre></td></tr></table></figure></p><p>其中，link为link.exe链接器，-machine:x64表示x64版本，-out表示指定输出文件名，-dynamicbase表示包含附加依赖项msmpi.lib，而-libpath表示设置库目录，最后MPIHelloWorld.obj表示要链接的汇编文件。链接完之后可以看到当前目录下生成了MPIHelloWorld.exe可执行文件<br><img src="/img/20200222-3.jpg" alt=""></p><p>最后，执行该程序，例如本例中采用10个核<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mpiexec</span> <span class="selector-tag">-n</span> 10 <span class="selector-tag">MPIHelloWorld</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/20200222-4.jpg" alt=""></p><p>至此，完成了Windows系统下采用命令行编译C++ MPI程序，参考此编译过程，可以将其应用到复杂的程序编译过程中，此是后话了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-目的&quot;&gt;&lt;a href=&quot;#一-目的&quot; class=&quot;headerlink&quot; title=&quot;一. 目的&quot;&gt;&lt;/a&gt;一. 目的&lt;/h3&gt;&lt;p&gt;目标程序比较大，之前主要是在Liunx下进行程序的开发、编译与使用，现在想在Windows下进行开发、编译与使用。为了实
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>大道平直，努力向前</title>
    <link href="http://liaohuming.com/2018/03/06/20180306-%E5%A4%A7%E9%81%93%E5%B9%B3%E7%9B%B4%E5%8A%AA%E5%8A%9B%E5%90%91%E5%89%8D/"/>
    <id>http://liaohuming.com/2018/03/06/20180306-大道平直努力向前/</id>
    <published>2018-03-06T14:02:41.000Z</published>
    <updated>2020-02-23T04:32:19.883Z</updated>
    
    <content type="html"><![CDATA[<p>嚯，这篇博文居然还空着。</p><p>记得是去年的春天，即将要毕业，认识了心仪的女孩，一时间春回大地，万物复苏，未来的一切令我振奋与向往。这篇博客就是那时候想写的，想描述的也就是那样的心情。小时候总觉得日子好漫长，越长大时间走的越快。瞧，弹指一挥间，一年多过去了，这一年每天都过得跟打仗似的，非常累，非常充实，也学习到了很多，当然也有令人沮丧的事情与时候，归结起来都是收获。毕业了、工作了、心仪的女孩现在成了我的妻子。</p><p>拖了一年半之久，最初有想法的时候总想着等有个空闲的时间了，好好写一写，殊不知到了后面因为忙碌，或者因为记不起来，等等原因，这事情就搁浅了，再提笔已是一年半之后了，当初的心潮澎湃，也再不能描述出来了。</p><p>拖延症往往也是完美主义者，总是恐惧自己做出来的东西不够完美。比如有些想法迟迟不动笔写下来，因为总是希望写出一个完美的东西！其实先硬着头皮把最想表达的写下来，然后再反复迭代修改先有一个拙劣作品远胜过迟迟不肯动手。</p><p>所以啊，凡事都及时行动。The journey of a thousand miles begins with a single step.</p><p>update@2019年9月8日11:13:27<br>北航沙河校区三号教学楼，教师之家</p><p><img src="/img/20190908.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嚯，这篇博文居然还空着。&lt;/p&gt;
&lt;p&gt;记得是去年的春天，即将要毕业，认识了心仪的女孩，一时间春回大地，万物复苏，未来的一切令我振奋与向往。这篇博客就是那时候想写的，想描述的也就是那样的心情。小时候总觉得日子好漫长，越长大时间走的越快。瞧，弹指一挥间，一年多过去了，这一年每
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下安装paraview和totalview</title>
    <link href="http://liaohuming.com/2017/12/12/20171212-Linux%E4%B8%8B%E5%AE%89%E8%A3%85paraview%E5%92%8Ctotalview%E6%97%A5%E5%BF%97/"/>
    <id>http://liaohuming.com/2017/12/12/20171212-Linux下安装paraview和totalview日志/</id>
    <published>2017-12-12T06:26:36.000Z</published>
    <updated>2022-11-18T13:00:08.334Z</updated>
    
    <content type="html"><![CDATA[<p>Paraview和Totalview在Linux下是免安装的，分别下载程序压缩包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParaView<span class="number">-5.4</span><span class="number">.0</span>-Qt5-OpenGL2-MPI-Linux<span class="number">-64b</span>it.tar.gz</span><br><span class="line">和</span><br><span class="line">toolworks.tar.gz</span><br></pre></td></tr></table></figure><p>解压，各自的文件夹中的 /bin 目录下即有可执行程序 paraview 和 totalview，用户需要运行该程序时需要定位至该目录，然后在终端输入调用命令，运行程序。由于每次运行程序都要去找bin文件夹太麻烦，可以把paraview（totalview）的bin文件夹加入path环境变量。然后直接在终端运行paraview。方法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在用户根目录下的 .bash_profile 文件中改变环境变量PATH，例如：</span><br><span class="line">PARAVIEW_DIR=/home/software/ParaView<span class="number">-5.4</span><span class="number">.1</span><span class="number">-822</span>-g597adef-Qt5-MPI-Linux<span class="number">-64b</span>it</span><br><span class="line"><span class="keyword">export</span> PATH=$PARAVIEW_DIR/bin:$PATH</span><br><span class="line"></span><br><span class="line">在终端命令行窗口可以通过</span><br><span class="line">echo $PATH</span><br><span class="line">命令进行查看</span><br></pre></td></tr></table></figure><p>上述设置了环境变量，在本文中采用Cygwin/X来实现Linux服务器上运行程序GUI，首先需要使用XTerm终端登陆Linux，登陆命令为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@servername -Y</span><br></pre></td></tr></table></figure><p>登陆之后，可以直接在终端命令窗口输入paraview进行程序调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paraview</span><br><span class="line">但是出现错误</span><br><span class="line">Fontconfig warning: line <span class="number">146</span>: blank doesn't take any effect anymore. please remove it from your fonts.conf</span><br></pre></td></tr></table></figure><p><a href="https://public.kitware.com/pipermail/paraview/2017-June/040381.html" title="[Paraview] [EXTERNAL] FW: paraview error." target="_blank" rel="noopener">查询之后，paraview at paraview.org 有回复说采用如下调用命令：</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paraview --mesa-llvm</span><br></pre></td></tr></table></figure><p>采用上述命令之后，可以成功启动paraview，但是整个GUI界面是黑色的，所有菜单几乎看不到，有若干菜单可以看到，能看到的菜单可以正常使用，比如，“打开”可以正常打开文件浏览窗口。而终端命令行窗口则不断提示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fontconfig warning: line <span class="number">146</span>: blank doesn't take any effect anymore. please remove it from your fonts.conf</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br><span class="line">Xlib:  extension <span class="string">"MIT-SHM"</span> missing on display <span class="string">"localhost:10.0"</span>.</span><br></pre></td></tr></table></figure><p>目前还不知道什么原因引起，有可能是Xsever没安装好，这个问题需要进一步解决。</p><p>此外，按上述的方式设置PATH之后，Totalview亦可成功调用，目前存在的问题是Totalview没有破解，需要license才能使用，这个问题也需要进一步解决。</p><hr><p><a href="http://shunfengwei.blog.163.com/blog/static/17522511720122299241143/" title="linux下.bashrc文件 /PATH环境变量修改 /提示符修改" target="_blank" rel="noopener">linux下.bashrc文件 /PATH环境变量修改 /提示符修改</a></p><p><strong>1）<code>.bashrc</code>文件</strong></p><p>在linux系统普通用户目录（cd /home/xxx）或root用户目录（cd /root）下，用指令ls -al可以看到4个隐藏文件，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bash_history   记录之前输入的命令</span><br><span class="line">.bash_logout    退出时执行的命令</span><br><span class="line">.bash_profile   登入shell时执行</span><br><span class="line">.bashrc         登入shell时执行</span><br></pre></td></tr></table></figure><p>注意后两个的区别：<code>.bash_profile</code>只在会话开始时被读取一次，而<code>.bashrc</code>则每次打开新的终端时，都要被读取。这些文件是每一位用户对终端功能和属性设置，修改<code>.bashrc</code>可以改变环境变<code>PATH</code>、别<code>alias</code>和提示符</p><p>除了可以修改用户目录下的<code>.bashrc</code>文件外，还可以修改如<code>/etc/profile</code>文件、<code>/etc/bashrc</code>文件及目录<code>/etc /profile.d</code>下的文件。但是修改<code>/etc</code>路径下的配置文件将会应用到整个系统，属于系统级的配置，而修改用户目录下的<code>.bashrc</code>则只是限制在用户应用上，属于用户级设置。两者在应用范围上有所区别，建议如需修改的话，修改用户目录下的<code>.bashrc</code>，即无需<code>root</code>权限，也不会影响其他用户。</p><p><strong>2） PATH环境变量修改</strong></p><p>PATH变量决定了shell 将到哪些目录中寻找命令或程序。如果要执行的命令的目录在 <code>$PATH</code> 中，您就不必输入这个命令的完整路径，直接输入命令就可以了。一些第三方软件没有将可执行文件放到 Linux 的标准目录中。因此，将这些非标准的安装目录添加到 <code>$PATH</code> 是一种解决的办法。</p><p>首先，作为惯例，所有环境变量名都是大写。由于 Linux 区分大小写，第二点是变量名有时候以<code>$</code>开头，但有时又不是。当设置一个变量时，直接用名称，而不需要加<code>$</code>，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/bin:/usr/local/bin:/bin</span><br></pre></td></tr></table></figure></p><p>假如要获取变量值的话，就要在变量名前加<code>$</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure></p><p>则会显示当前设置的PATH变量<code>/usr/bin:/usr/local/bin:/bin</code></p><p>否则的话，变量名就会被当作普通文本了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo PATH</span><br></pre></td></tr></table></figure></p><p>显示PATH</p><p>处理 <code>$PATH</code> 变量要注意的第三点是：不能只替换变量，而是要将新的字符串添加到原来的值中。在大多数情况下，不能用<code>PATH=/some /directory</code>，因为这将删除 <code>$PATH</code> 中其他的所有目录，这样在该终端运行程序时，就不得不给出完整路径。所以，只能作添加：<code>PATH=$PATH:/some/directory</code>，假如你要添加<code>/usr/local/arm/3.4.1/bin</code>交叉编译命令，则操作为<code>PATH=$PATH:/usr/local/arm/3.4.1/bin</code><br>这样，PATH 被设成当前的值（以 <code>$PATH</code> 来表示）＋新添的目录。</p><p>到目前为止，只为当前终端设置了新的 <code>$PATH</code> 变量。如果打开一个新的终端，运行 <code>echo $PATH</code> ，将显示旧的 <code>$PATH</code> 值，而看不到你刚才添加的新目录。因为你先前定义的是一个局部环境变量（仅限于当前的终端）。</p><p>要定义一个全局变量，使在以后打开的终端中生效，您需要将局部变量输出，可以用<code>export</code>命令：<br><code>export PATH=$PATH:/some/directory</code></p><p>现在如果打开一个新的终端，输入<code>echo $PATH</code> ，也能看到新设置的<code>$PATH</code>了。请注意，命令<code>export</code>只能改变当前终端及以后运行的终端里的变量。对于已经运行的终端没有作用。为了将目录永久添加到 <code>$PATH</code> ，只要将<code>export</code>的那行添加到<code>.bashrc或/etc/bashrc</code>文件中。</p><p><strong>3) alias别名</strong></p><p>一般在<code>.bashrc</code>或<code>/etc/bashrc</code>文件里有几句话</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias rm='rm -i'</span><br><span class="line">alias cp='cp -i'</span><br><span class="line">alias mv='mv -i'</span><br></pre></td></tr></table></figure><p>有了这几句话，当在终端中输入<code>mv test.c led.c</code>实际上输入的是<code>mv -i test.c led.c</code>，所以说alias是一个别名。你可以在该配置文件中添加自己风格的别名，如<code>alias ll=&#39;ls -l&#39;</code>，只需要在终端中输入<code>ll</code>就实现了<code>ls -l</code>的功能。还可以添加其他语句，随自己喜好。</p><p><strong>4） 提示符</strong></p><p>当打开一个控制台(console) 时，最先看到的就是提示符(prompt)，如：<code>[root@localhost ~]#</code></p><p>在默认设置下，提示符将显示用户名、主机名（默认是<code>localhost</code>）、当前所在目录（在 Unix 中，<code>~</code>表示 home 目录）。按照传统，最后一个字符可以标识普通用户<code>$</code>，还是root<code>#</code>。可以通过 <code>$PS1</code> 变量来设置提示符。</p><p>命令<code>echo $PS1</code>，将显示当前的设定。其中可用字符的含义在 <code>man bash</code> 的<code>PROMPTING</code>部分有说明。</p><p>如何才能完成理想的设置呢？对于健忘的初学者来讲，默认设定有些不友好，因为提示符只显示当前目录的最后一部分。如果你看到象这样的提示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wsf@localhost bin]$</span><br></pre></td></tr></table></figure></p><p>则当前目录可能是<code>/bin</code>、<code>/usr/bin</code>、<code>/usr/local/bin</code>及<code>/usr/X11R6/bin</code>。当然，你可以用<br>pwd （输出当前目录，print working directory），能不能叫 shell 自动告诉你当前目录呢？当然可以。这里我将提到的设定，包括提示符，大都包含在文件<code>/etc/bashrc</code>中。可以通过编辑各自 home 目录下的<code>.bash_profile</code>和<code>.bashrc</code>来改变设置。</p><p>在<code>man bash</code> 中的<code>PROMPTING</code>部分，对这些参数(parameter)有详细说明。可以加入一些小玩意，如不同格式的当前时间，命令的历史记录号，甚至不同的颜色。</p><p>一种更适当的设定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">"[\u: \w]\\$ "</span></span><br></pre></td></tr></table></figure><p>这样，提示符就变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wsf: /usr/bin]$</span><br></pre></td></tr></table></figure><p>可以通过命令 export 来测试不同的设置（比如，<code>export PS1=&quot;\u: \w\\$ &quot;</code>）。如果找到了适合的提示符，就将设置放到<code>.bashrc</code>中。这样，每次打开控制台或终端窗口时，都会生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Paraview和Totalview在Linux下是免安装的，分别下载程序压缩包：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>显式时间积分与隐式时间积分的区别</title>
    <link href="http://liaohuming.com/2017/10/19/20171019-%E6%98%BE%E5%BC%8F%E6%97%B6%E9%97%B4%E7%A7%AF%E5%88%86%E4%B8%8E%E9%9A%90%E5%BC%8F%E6%97%B6%E9%97%B4%E7%A7%AF%E5%88%86/"/>
    <id>http://liaohuming.com/2017/10/19/20171019-显式时间积分与隐式时间积分/</id>
    <published>2017-10-19T04:37:01.000Z</published>
    <updated>2022-11-18T13:01:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>随着国内各种动力弹塑性的兴起，对动力时程分析中提到的方法多有各种说法，对于设计院的人来说更是云里雾里的多，今天看到一篇文章讲得不错，于是结合下自己的看法大概说说显式和隐式动力分析的差别。</p><p>首先简单的解释下：</p><p>显式分析：用上一步的结果和当前步的结果计算下一步的计算结果。有条件收敛，要求时间步较小。通常做动力分析用这种方法。</p><p>隐式分析：用当前步结果和下一步未知结果反复迭代下一步结果，必须通过迭代得到。无条件收敛。是一种能量平衡的结果。通常做静力分析用这种方法。</p><p>两者均是求解动力方程，只是显式求解的每一步不是绝对平衡，而隐式求解是在每一步都是近似绝对平衡的。</p><p>显式算法：</p><p>显式算法最大优点是有较好的稳定性。</p><p>动态显式算法采用动力学方程的一些差分格式（如广泛使用的中心差分法、线性加速度法等），不用直接求解切线刚度，不需要进行平衡迭代，计算速度快，时间步长只要取的足够小，一般不存在收敛性问题。 显式算法不需要迭代，也不需要组集总刚，因此需要的内存也比隐式算法要少。并且数值计算过程可以很容易地进行并行计算，程序编制也相对简单。但显式算法要求质量矩阵为对角矩阵，而且只有在单元级计算尽可能少时速度优势才能发挥, 因而往往采用减缩积分方法，容易激发沙漏模式，影响应力和应变的计算精度。”</p><p>静态显式法基于率形式的平衡方程组与Euler向前差分法，不需要迭代求解。由于平衡方程式仅在率形式上得到满足，所以得出的结果会慢慢偏离正确值。为了减少相关误差，必须每步使用很小的增量。这个方法目前应用比较少。</p><p>总之显式方法不需要迭代是个利好，每步的时间基本是固定的，可以根据设置的波长和分析步长估算出计算总时间。根据上面论述可以看出，一般多采用动态显式，一般有中心差分法、线加速度法等，也有人列出精细积分法为显式算法。其中中心差分法的变种也非常多，有蛙跳式、向后差分式等。由于其算法上当前步结果只跟上一步结果有关，因此只要对角化质量矩阵和阻尼矩阵即可不需要联立动力方程，可解耦到每个单元的差分公式，大大简化了计算过程。但为了保持好的精度，需要当前步和上两步之间尽量是线性关系，因此需要很小的时间步长，通常算法也就用于高速冲击、碰撞上，这些运动可天然的弥补其步长短的问题，但现在随着计算机硬件的能力提升，也开始用到普通运动求解上。</p><p>隐式算法 ：</p><p>在每一增量步内都需要对静态平衡方程进行迭代求解，并且每次迭代都需要求解大型的线性方程组，这以过程需要占用相当数量的计算资源、磁盘空间和内存。该算法中的增量步可以比较大，至少可以比显式算法大得多，但是实际运算中上要受到迭代次数及非线性程度的限制，需要取一个合理值。通常在一个时间增量下，隐式算法在弹塑性后期此时刚度比较奇异了，难以收敛，也就需要采用二分法把当前的分析步折半继续解方程，并且不断二分下去直到方程求解完成，所以隐式算法时在前面计算速度还不错，但越往后越慢，时间也是不可估量的，可能在地震波20s就算不下去了等等。但是隐式算法有个好处就是只要算了步数其结果一般一定是正确的，不会像显式那样虽然算完了，其结果可能是发散的。</p><p>隐式算法在求解运动方程时是当前步结果除了更上一步有关外还跟当前步有关，因此不能解耦大型方程组，需要组集刚度，用得多是newmark法和wilson-theta法，其中的beta、alpha和theta值的确定可改变方法的稳定性、计算效率等。隐式求解法的最大优点是它具有无条件稳定性，即时间步长可以任意大。</p><p>计算时间：</p><p>上面大致说了下，不过一般经验表明：</p><p> 使用显式方法，计算成本消耗与单元数量成正比，并且大致与最小单元的尺寸成反比</p><p>应用隐式方法，经验表明对于许多问题的计算成本大致与自由度数目的平方成正比，这是在保证能计算完的情况下，  因此如果网格是相对均匀的，随着模型尺寸的增长，显式方法表明比隐式方法更加节省计算成本。</p><p>通常认为两者有此区别：</p><p>=============================================================</p><p>​                      显式算法            隐式算法</p><p>-————————————————————</p><p>  (01)适用问题        动力学（动态）      静力学（静态）</p><p>  (02)阻尼               人工阻尼            数值阻尼</p><p>-————————————————————</p><p>  (03)每步求解方法    矩阵乘法            线性方程组</p><p>  (04)大矩阵（总刚）  否                  是</p><p>  (05)数据存贮量      小                  大</p><p>  (06)每步计算速度    快                  慢</p><p>  (07)迭代收敛性      无                  有</p><p>  (08)确定解          有确定解            可能是病态无确定解</p><p>-———————————————————–</p><p>  (09)时步稳定性      有条件              无条件</p><p>  (10)时间步          小                  大 </p><p>  (11)计算精度        低                  高</p><p>=============================================================</p><p>从上面大致可以出，有些认识只是表象而已，其中（1）是明显的错误，因为两种方法都可以用于动力学和静力学问题，只是一种选择而已，（2）也是错误的，阻尼的选择不是算法本身，而是求解需求。（03）是算法的本质，也决定了（04）（05）（06）（07）（08），这是算法的特点所在，04~08并非算法本身的特点而是每一步求解方法的特征。同理（09）是算法的特点，决定了（10）（11）。</p><p>过(03)(09)可以得到两种方法的计算特点，显式算法是每一步求解为矩阵乘法，时间步选择为条件稳定；隐式算法是每一步求解为线性方程组求解，时间步选择为无条件稳定。</p><p>附加说明：</p><p>{1)求解线性静力学问题，虽然求解线性方程组，但是没有时步的关系，所以不应将其看作隐式算法。而是静力学隐式方程求解问题。</p><p>(2)求解非线性静力学问题，虽然求解过程需要迭代，或者是增量法，但是没有明显的时步问题，所以不应将其看作隐式算法。仍归结为隐式方程求解问题</p><p>3)静态松弛法，可以认为是将动力学问题看作静力学问题来解决，每一步达到静力平衡，需要数值阻尼。</p><p>4)动态松弛法，可以认为是将静力学问题或者动力学问题，分为时步动力学问题，采用向后时步迭代的思想计算。对于解决静力学问题时，需要人工阻尼。</p><p>最后说下软件：</p><p>abaqus中是既有隐式也有显式算法的，隐式采用的是改进的newmark法，是HHT方法，显式采用的是中心差分法。目前来说abaqus吧这两种方法都做到了极致</p><p>LS-dyna：显式算法的鼻祖，有隐式算法和显式算法，newmark wilson（这个不确定）和中心差分</p><p>sausage：采用中心差分法，没有隐式算法</p><hr><p>以下 内容转自abaqus版面的总结：</p><p>显式一般用于动态问题的分析, 对于大型问题, 或复杂的接触情况可能需要几百万的增量步的计算, 所用时间可能是几天或更长. 而隐式的增量步长要长得多, 一般用于静态问题的求解.<br>显式算法别explicit method use direct iterative method, which has small cost in each<br>time increment but require relatively small increment. Abaqus pre-determine<br>the time increment based on wave propagation speed and minimum mesh<br>size. This method could be efficient for highly nonlinear and contact problem.<br>For quasi-static problem, properly adjust model parameter as density and total<br>time is important to achieve good computation time.</p><p>standard-隐式算法Implicit method use newton method for iteration, which means high cost for<br>each time increment but could mean large time increment. Convergence<br>could be a problem in this case. It could be efficient for linear and some nonlinear  problem. More materials, elements and procedures are available in standard.</p><p>所谓显式和隐式，是指求解方法的不同，即数学上的出发点不一样。并不是说显式只能求动力学问题，隐式只能求静力学问题，只是求解策略不通。<br>显式求解是对时间进行差分，不存在迭代和收敛问题，最小时间步取决于最小单元的尺寸。过多和过小的时间步往往导致求解时间非常漫长，但总能给出一个计算结果。解题费用非常昂贵。因此在建模划分网格时要非常注意。</p><p>隐式求解和时间无关，采用的是牛顿迭代法（线性问题就直接求解线性代数方程组），因此存在一个迭代收敛问题，不收敛就的不到结果。</p><p>两者求解问题所耗时间的长短理论上无法比较。实际应用中一般感觉来说显式耗时多些。<br>由于两者解题的出发点，所以一般来说显式用于求解和时间相关的动力学问题。隐式用来求解和时间无关的静力学问题。但也不是绝对的。比如，用隐式求解时，为了克服迭代不收敛，改用显式算，但是要多给点时间，这样虽然克服了不收敛的问题，但是求解的时间费用也是相当客观的。另外，隐式也可以求解动力学问题。abaqus就有一个用隐式积分求解动力学的选项。</p><p>n+1个时间步的量可以由第n个时间步的量直接求得，称为显式<br>例如：<br>an+1=bn+cn<br>bn+1=an+cn<br>cn+1=an+bn<br>优点是计算量比较小<br>缺点是有累积误差 </p><p>n+1个时间步的量不可以由第n个时间步的量直接求得，称为隐式<br>例如：<br>an+1+bn+1=cn<br>bn+1+cn+1=an<br>an+1+cn+1=bn<br>优点是计算量比较大，需要通过方程组求解<br>缺点是没有累计误差</p><p>显示算法不进行刚度矩阵的重新计算，只在开始形成以后不变，是时间的显示积分。而隐式算法没进行一次计算都要重新计算刚度矩阵，然后进行迭代，是无条件收敛的。</p><p>Q: What is the difference between implicit and explicit dynamics? (Difference between regular ANSYS and ANSYS/LS-DYNA?)<br>A:For computers, matrix multiplication isn’t difficult. Matrix inversion is the more computationally expensive operation. The equations we solve in nonlinear, dynamic analyses in ANSYS and in LS-DYNA are:<br>[M]{a} + [C]{v} + [K]{x} = {F} </p><p>Hence, in ANSYS, we need to invert the [K] matrix when using direct solvers (frontal, sparse). Iterative solvers use a different technique from direct solvers which I won’t get into here, but, basically, the inversion of [K] is the CPU-intensive operation for any ‘regular’ ANSYS solver, direct or iterative. We then can solve for displacements {x}. Of course, with nonlinearities, [K(x)] is also a function of {x}, so we need to use Newton-Raphson method to solve for [K] as well. (material nonlinearities and contact get thrown into [K(x)])</p><p>In LS-DYNA, on the other hand, we solve for accelerations {a} first. Now, in LS-DYNA, we assume that the mass matrix is lumped. This basically forces us to use lower-order elements – that is why, for all explicit dynamics codes (ANSYS/LS-DYNA, MSC.Dytran, ABAQUS/Explicit), we can only use lower-order elements. Also, the benefit of doing lumped mass is that, if we solve for {a}, then [M], if lumped, is a diagonal mass matrix. This means that inversion of [M] is trivial (diagonal terms only) – another way to view it is that we now have N set of <em>uncoupled</em> equations. Hence, we just have to do matrix multiplication, which isn’t nearly as CPU-intensive. It’s also worthwhile to note that [K] does not need to be inverted, and accounting for material nonlinearties and contact is easier.</p><p>Now, as for time integration, the terms ‘implicit’ and ‘explicit’ refer to time integration – for example, if you might recall something like backward Euler method, that is an example of an implicit time integration scheme, whereas central difference or forward Euler are examples of explicit time integration schemes. It relates to when you calculate the quantities – either based on current or previous time step. In any case, this is a very simplified explanation, and the main point is that implicit time integration is unconditionally stable, whereas explicit time integration is not (there is a critical time step your delta(t) needs to be smaller than). As a result, ‘regular’ ANSYS allows for much larger time steps, but LS-DYNA requires much tinier time steps. Also, LS-DYNA requires very tiny steps, so that is why it is usually good for impact/short-duration events, not usually things like maybe creep where the model’s time scale may be on the order of hours or more.</p><p>In summary:<br>‘Regular’ ANSYS uses implicit time integration. This means that {x} is solved for, but we need to invert [K], which means that each iteration is computationally expensive. However, because we solve for {x}, it is implicit, and we don’t need very tiny timesteps (i.e., each iteration is expensive, but we usually don’t need too many iterations total). The overall timescale doesn’t affect us much (although there are considerations of small enough timesteps for proper momentum transfer, capturing dynamic response, etc., but I’m getting ahead of myself).<br>ANSYS/LS-DYNA uses explicit time integration. This means that {a} is solved for, and inverting [M] is trivial – each iteration is very efficient. However, because we solve for {a}, then determine {x}, it is explicit, and we need very small timesteps (many, many iterations) to ensure stability of solution since we get {x} by calculating {a} first. (i.e., each iteration is cheap, but we usually need many, many iterations total)</p><p>Anyways, this is a very simplified (maybe over-simplified) explanation, but I hope it may help clear the distinction between these two methods. For very high-impact, nonlinear events of <em>short</em> duration, ANSYS/LS-DYNA is usually the better choice. For events which are of long duration, ‘regular’ ANSYS is usually the preferred method. For quasi-static events, there are ways in which you can use either solution method (e.g., mass-scaling for explicit). However, you can solve most problems with either method – I’m just referring to which ones are more <em>efficient</em>. [Note that I haven’t talked about mode-superposition transient analyses, which is an efficient subset of ‘regular’ ANSYS for mostly linear behavior, but it is efficient because we uncouple the equations in the frequency domain rather than time domain, but I’ve probably digressed enough already…]</p><p>隐式与显示最重要的区别在于是否对于整体刚度矩阵求逆，而这一过程也就决定了两者对于模型的要求，由于隐式算法要求逆，所以计算时要求整体刚度阵不能奇异，而显示就没有这一问题啦。而对于动力学问题来将，从数学上看它属于微分方程中初边值问题，如果采用显示求解，很容易发生总纲奇异的问题，所以很多时候求解动力学问题都采用explicit来做。但是explicit也有自身的问题，由于要对于时间积分，如果时间积分步长取得太长，计算结果很有可能是不精确的，但是太短了，还会使得计算时间大幅度增加，并且动力学问题中还存在应力波效应影响，所以使得显示问题更为复杂，但是abaqus中提供了最小单元尺寸限制时间步长的方法，还是可以很好地解决这问题。</p><p>显式和隐式的区别很多人都讲了，说一下计算效率的问题，隐式需要解线性方程组，而对于显式，当我们使用集中质量矩阵时，不需要求解线性方程组，所以对于大规模问题，虽然显式的时间步长较小，但显式会比隐式更有效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着国内各种动力弹塑性的兴起，对动力时程分析中提到的方法多有各种说法，对于设计院的人来说更是云里雾里的多，今天看到一篇文章讲得不错，于是结合下自己的看法大概说说显式和隐式动力分析的差别。&lt;/p&gt;
&lt;p&gt;首先简单的解释下：&lt;/p&gt;
&lt;p&gt;显式分析：用上一步的结果和当前步的结果
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数值计算" scheme="http://liaohuming.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Apache安装日志</title>
    <link href="http://liaohuming.com/2017/09/06/20170906-Apache%E5%AE%89%E8%A3%85%E6%97%A5%E5%BF%97/"/>
    <id>http://liaohuming.com/2017/09/06/20170906-Apache安装日志/</id>
    <published>2017-09-06T04:37:01.000Z</published>
    <updated>2022-11-18T13:10:47.184Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了在Linux服务器上安装Escaas代码开发文档—doxygen，我打算在服务器上搭建个网站，于是选用Apache，结果安装的过程却不太顺利，走了不少弯路，浪费许多时间，此以为记，便于日后参考。</p></blockquote><p><strong>安装步骤</strong></p><ol><li><p>下载 apache，例如：<a href="https://httpd.apache.org/download.cgi" target="_blank" rel="noopener">httpd-2.2.34.tar.gz</a></p></li><li><p>解压httpd-2.2.34.tar.gz</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf httpd<span class="number">-2.2</span><span class="number">.34</span>.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入解压后的目录httpd-2.2.34，进行安装，<a href="https://www.bbsmax.com/A/pRdB8jK1Jn/" target="_blank" rel="noopener">关于linux下的压缩文件</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd httpd<span class="number">-2.2</span><span class="number">.34</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>在上述中，如果./configure后不添加参数则按默认路径安装，如果需要指定路径可以采用：./configure –prefix=/home/software/httpd-2.2.34 指定路径的方式进行安装。</p><p>在本例中采用的是默认路径，因此安装程序会自动在/usr/local中创建 apache2 目录，Apache服务器软件的所有配置文件和可执行文件就都保存在这里。如果要卸载，只需将 apache2 目录删除即可。</p></li><li><p>接下来要修改配置文件/usr/local/apache2/conf/httpd.conf，要修改的有如下几项：</p><ul><li><p>Listen</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改Listen行，确定服务的IP地址和端口号：</span><br><span class="line">Listen <span class="number">192.168</span><span class="number">.3</span><span class="number">.33</span>:<span class="number">80</span></span><br><span class="line">说明：<span class="number">192.168</span><span class="number">.3</span><span class="number">.33</span>是当前计算机的IP地址，通过<span class="number">80</span>端口提供Web服务。 此项不特意设也可，默认端口就<span class="number">80</span>。</span><br></pre></td></tr></table></figure></li><li><p>ServerName</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerName localhost</span><br><span class="line">或者</span><br><span class="line">ServerName <span class="number">192.168</span><span class="number">.3</span><span class="number">.33</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>DocumentRoot</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改DocumentRoot ，根据需要自行设定主页所在的根目录。</span><br><span class="line">DocumentRoot <span class="string">"/var/www/html/doxygen_doc/developer"</span></span><br></pre></td></tr></table></figure></li><li><directory ""=""><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory <span class="string">"/var/www/html/doxygen_doc/developer"</span>&gt;</span><br><span class="line">    #</span><br><span class="line">    # Possible values <span class="keyword">for</span> the Options directive are <span class="string">"None"</span>, <span class="string">"All"</span>,</span><br><span class="line">    <span class="meta"># or any combination of:</span></span><br><span class="line">    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews</span><br><span class="line">    #</span><br><span class="line">    # Note that <span class="string">"MultiViews"</span> must be named *explicitly* --- <span class="string">"Options All"</span></span><br><span class="line">    # doesn't give it to you.</span><br><span class="line">    #</span><br><span class="line">    # The Options directive is both complicated <span class="keyword">and</span> important.  Please see</span><br><span class="line">    <span class="meta"># http:<span class="comment">//httpd.apache.org/docs/2.2/mod/core.html#options</span></span></span><br><span class="line">    <span class="meta"># for more information.</span></span><br><span class="line">    #</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    # AllowOverride controls what directives may be placed in .htaccess files.</span><br><span class="line">    # It can be <span class="string">"All"</span>, <span class="string">"None"</span>, <span class="keyword">or</span> any combination of the keywords:</span><br><span class="line">    #   Options FileInfo AuthConfig Limit</span><br><span class="line">    #</span><br><span class="line">    AllowOverride None</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    # Controls who can get stuff from <span class="keyword">this</span> server.</span><br><span class="line">    #</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line"></span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></directory></li><li><p>DirectoryIndex</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule dir_module&gt;</span><br><span class="line">    DirectoryIndex index.html</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动httpd服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure><p>如果一切正常，那么现在打开浏览器，输入：http:\\localhost 或者 http:\\192.168.3.33 就应该可以打开index.html网页了，此处即是我遇到问题的地方，一开始执行<code>./apachetl start</code>提示ServerName不明确，也就是前面提到的要给ServerName明确的定义或者是localhost或者是指定的ip，其次又遇到80端口被占用的问题，于是换端口，换了端口也提示被占用，后面把这些端口都kill了，但是依然不行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef<span class="comment">//可以看到有若干个httpd，占着若干个刚刚修改的端口，把这些都kill</span></span><br><span class="line">kill pid<span class="comment">//pid是通过ps -ef 看到的进程id</span></span><br></pre></td></tr></table></figure><p>无论配置文件怎么改，端口怎么设置都不行，原来是电脑没重启的缘故，昨天北配停电，今早开机就可以用了，自己电脑上装了一遍，windows服务器上装了一遍，linux服务器上装了一遍，唯独linux不行，就没想过重启一下，应该是一些服务没有生效，没有重启虽然执行<code>./apachetl start</code>但实际上httpd服务并没有生效，这才导致无法在浏览器上访问。</p></li><li><p>自动启动httpd服务</p><p>上面只是当前启动了httpd服务，如果电脑重启或者关机重开时候，httpd服务是没有自动启动的，下面是一种自动启动的方式，已在服务器上设置，但还未验证：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在<span class="regexp">/etc/</span>rc.d<span class="regexp">/rc.local中增加启动apache的命令，例如：/u</span>sr<span class="regexp">/local/</span>httpd<span class="regexp">/bin/</span>apachectl start</span><br><span class="line">chmod u+x rc.local</span><br></pre></td></tr></table></figure><p>​</p><p>总归遇到的所有问题都解决了，开心。</p><p>by：Huming</p><p>@2017年9月6日10:59:53</p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为了在Linux服务器上安装Escaas代码开发文档—doxygen，我打算在服务器上搭建个网站，于是选用Apache，结果安装的过程却不太顺利，走了不少弯路，浪费许多时间，此以为记，便于日后参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>What does &quot;arg inf sup&quot; mean?</title>
    <link href="http://liaohuming.com/2017/08/29/20170829-What%20does%20arg%20inf%20sup%20mean/"/>
    <id>http://liaohuming.com/2017/08/29/20170829-What does arg inf sup mean/</id>
    <published>2017-08-29T04:37:01.000Z</published>
    <updated>2022-11-18T13:02:48.041Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>arg</strong>: argument</li><li><strong>inf</strong>: infimum</li><li><strong>sup</strong>: supremum</li></ul><p>arg inf refers to the argument of the function such that the function attains its infimum (or minimum). For example, let $f(x)=x^2-x$. Then arg inf $f(x)=\frac{1}{2}$ because $f(x)$ attains its minimum at $x=\frac{1}{2}$.</p><p>When $f$ is a function on a set $A$, the notation: arg $\max\limits_{x \in A}f(x)$ donates the set of elements of $A$ for which $f$ attains its maximum value. This set may be empty, for example, if $f(x)=x$ and $A=(0,1)$, then $f$ has no maximum on $A$, so: arg $\max\limits_{x \in (0,1)} f(x)= \emptyset$. However, $f$ has a supermum:  arg $\sup\limits_{x \in (0,1)} f(x)= {1}$. </p><p><a href="https://en.wikipedia.org/wiki/User:Paolo.dL" target="_blank" rel="noopener">Paolo.dL</a> asked me about the difference between arg sup/inf and arg max/min, but I was not able to give a complete answer. Help appreciated! <a href="https://en.wikipedia.org/wiki/User:Rinconsoleao" target="_blank" rel="noopener">Rinconsoleao</a> (<a href="https://en.wikipedia.org/wiki/User_talk:Rinconsoleao" target="_blank" rel="noopener">talk</a>) 11:10, 19 July 2011 (UTC)</p><p>The min is the smallest value in a set. The inf is the greatest lower bound on the set. Frequently the two are the same, but in tricky cases there is an inf even if the min fails to exist. The relation between max and sup is analogous. Examples:</p><p>minimize $y=x^2+5$ by choosing $x$ in $-1 \leq x \leq 1$. In this case the min is $y=5$ at the arg min $x=0$. Also the arg inf $x=0$.</p><p>minimize $y=x^2+5$ by choosing $x$ in $1 &lt; x \leq 2$. In this case the min and tthe arg min do not exit because you would like to choose $x=1$, but that’s not in the choice set. In this case the inf is 6, which is the largest number less than or equal to $x^2+5$ for all $x$ in $1&lt;x \leq 2$.</p><p>Unfortunately in this second example, I’m not sure whether it’s technically correct to say that the arg inf is 1, or that the arg inf is undefined. <a href="https://en.wikipedia.org/wiki/User:Rinconsoleao" target="_blank" rel="noopener">Rinconsoleao</a> (<a href="https://en.wikipedia.org/wiki/User_talk:Rinconsoleao#top" target="_blank" rel="noopener">talk</a>) 10:57, 19 July 2011 (UTC)</p><p>Summarizing: arg inf and arg sup are not synonyms for arg min and arg max, but in the cases when they fail to be equivalent I am not sure whether arg inf and arg sup are well-defined. Help appreciated. <a href="https://en.wikipedia.org/wiki/User:Rinconsoleao" target="_blank" rel="noopener">Rinconsoleao</a> (<a href="https://en.wikipedia.org/wiki/User_talk:Rinconsoleao#top" target="_blank" rel="noopener">talk</a>) 11:07, 19 July 2011 (UTC)</p><p>Probably we need a separate article Argument (mathematics) to sort this out. According to MathWorld, “An argument of a function $f(x_1, \dots, x_n)$ is one of the $n$ parameters on which the function’s value depends.” Since in your example there is only one argument $x$, I guess arg inf $f(x)$, where $f(x)=y$, is well defined.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;arg&lt;/strong&gt;: argument&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inf&lt;/strong&gt;: infimum&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sup&lt;/strong&gt;: supremum&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;arg inf
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数值计算" scheme="http://liaohuming.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>water_landing_mt时间步计算代码分析</title>
    <link href="http://liaohuming.com/2017/08/23/20170823-waterlanding%20mt%E7%89%88%E6%9C%AC%E6%97%B6%E9%97%B4%E6%AD%A5%E8%AE%A1%E7%AE%97/"/>
    <id>http://liaohuming.com/2017/08/23/20170823-waterlanding mt版本时间步计算/</id>
    <published>2017-08-23T08:45:50.000Z</published>
    <updated>2022-11-18T13:17:10.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间步计算"><a href="#时间步计算" class="headerlink" title="时间步计算"></a>时间步计算</h3><blockquote><p>configure.dat输入参数：</p><ul><li>fluid（水）<ul><li>Density (kg/m^3) : 1000</li><li>Bulk modulus (Pa) : 220000</li></ul></li><li>float（浮筒）<ul><li>Density (kg/m^3) : 6000</li><li>Elastic modulus (Pa): 1.5e12</li><li>Thickness (m): 0.01</li></ul></li><li>gas（浮筒内空气）<ul><li>Density (kg/m^3) : 12.6</li><li>Initial pressure (Pa): 120000</li></ul></li><li>strip（绑带）<ul><li>Density (kg/m^3): 3500</li><li>Elastic modulus (Pa): 1.5e9</li><li>Thickness (m): 0.01</li></ul></li><li>dt（CFL stable condition）<ul><li>dt = 0.1</li></ul></li></ul></blockquote><p>按照介质中波速的计算公式，手动计算得到的结果为：</p><p>$wave_{fluid}=\sqrt{\frac{Bulk}{\rho}}=\sqrt{\frac{220000}{1000}}=14.8324 m/s=14832.4mm/s$</p><p>$wave_{gas}=\sqrt{\frac{Bulk}{\rho}}=\sqrt{\frac{120000}{12.6}}=14.8324 m/s=97.59m/s=97590mm/s$</p><p>$wave_{float}=\sqrt{\frac{E}{\rho}}=\sqrt{\frac{1.5e12}{6000}}=1.58114e4 m/s=1.58114e7mm/s$</p><p>$wave_{strip}=\sqrt{\frac{E}{\rho}}=\sqrt{\frac{1.5e9}{3500}}=654.64 m/s=654654mm/s$</p><p>code中进行了单位转换，实际用于计算的单位为mm，并且在计算浮筒和绑带波速时，杨氏模量乘以了相应的thickness=0.01，因此：</p><p>$wave_{fluid}=\sqrt{\frac{Bulk}{\rho}}=\sqrt{\frac{220000}{1000}}=14.8324 m/s=14832.4mm/s$</p><p>$wave_{gas}=\sqrt{\frac{Bulk}{\rho}}=\sqrt{\frac{120000}{12.6}}=14.8324 m/s=97.59m/s=97590mm/s$</p><p>$wave_{float}=\sqrt{\frac{E}{\rho}}=\sqrt{\frac{1.5e12 \times 0.01}{6000}}=1.58114e3 m/s=1.58114e6mm/s$</p><p>$wave_{strip}=\sqrt{\frac{E}{\rho}}=\sqrt{\frac{1.5e9 \times 0.01}{3500}}=65.464 m/s=65465.4mm/s$</p><p>这与cmdline输出的wavespeed一致，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Minimal element size: <span class="number">0.0124994</span> (m)</span><br><span class="line">Time step (s) : 7.90533e-07</span><br><span class="line">Wavespeed: fluid=<span class="number">14832.4</span>; airplane=<span class="number">25000</span>; gas=<span class="number">97590</span>; membrane=<span class="number">25000</span>; <span class="keyword">float</span>=<span class="number">1.58114e+06</span>; strip=<span class="number">65465.4</span><span class="comment">//此处的Wavespeed的单位是mm/s</span></span><br></pre></td></tr></table></figure><p>现在按cmdline输出的参数来计算code里的timestep：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> unit_factor = <span class="number">1.0e3</span>;</span><br><span class="line">Cs *= unit_factor; <span class="comment">// Cs = 25 * 1000 = 25000 mm/s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> C_fluid = <span class="built_in">sqrt</span>(Bulk_fluid/rho_fluid); <span class="comment">//14832.4 mm/s</span></span><br><span class="line"><span class="keyword">double</span> C_gas = <span class="built_in">sqrt</span>(Bulk_gas/rho_gas); <span class="comment">//97590 mm/s</span></span><br><span class="line"><span class="keyword">double</span> C_float = <span class="built_in">sqrt</span>(E_float/rho_float); <span class="comment">//1.58114e6 mm/s</span></span><br><span class="line"><span class="keyword">double</span> C_strip = <span class="built_in">sqrt</span>(E_strip/rho_strip); <span class="comment">//65465.4 mm/s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> wavespeed = C_fluid &gt; Cs ? C_fluid : Cs;<span class="comment">// wavespeed = Cs = 25000 mm/s</span></span><br><span class="line"><span class="keyword">if</span> ( pFloat != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">  wavespeed = wavespeed &gt; C_gas ? wavespeed : C_gas; <span class="comment">// wavespeed = C_gas =97590 mm/s</span></span><br><span class="line">  wavespeed = wavespeed &gt; C_float ? wavespeed : C_float; <span class="comment">// wavespeed = C_float =1.58114e6 mm/s</span></span><br><span class="line">  wavespeed = wavespeed &gt; C_strip ? wavespeed : C_strip; <span class="comment">// wavespeed = wavespeed =1.58114e6 mm/s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dt *= hc / wavespeed; <span class="comment">// dt = 0.1, hc =12.4994 mm</span></span><br></pre></td></tr></table></figure><p>按照上述波速：</p><p>$wave_{float}&gt;wave_{gas}&gt;wave_{strip}&gt;wave_{airplane}=wave_{membrane}&gt;wave_{fluid}$</p><p>$d_t = dt \times \frac{hc}{wave_{float}} = 0.1 \times \frac{0.0124994 \times 1000}{1.58114e6}=7.90533 \times 10^{-7}$</p><p>这与cmdline输出的结果是一致的。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>存在的问题是计算浮筒和绑带的波速时为何要将其杨氏模量乘以thickness，不乘以thickness的话它们的波速应该大10倍：$wave_{float}=1.58114e7mm/s$，$wave_{strip}=654654mm/s$，进而时间步会缩小10倍：</p><p>$$<br>d_t = dt \times \frac{hc}{wave_{float}} = 0.1 \times \frac{0.0124994 \times 1000}{1.58114e7}=7.90533 \times 10^{-8}<br>$$</p><ul><li>thickness的作用是什么？</li><li>code中单位换算、时间步计算以及cmdline中输出信息的代码实现比较乱；</li><li>不过感觉时间步不是主要的问题，从测试结果来看，浮筒材料和绑带材料的变形还不太正确，可能需要将绑带的材料属性增加进去。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时间步计算&quot;&gt;&lt;a href=&quot;#时间步计算&quot; class=&quot;headerlink&quot; title=&quot;时间步计算&quot;&gt;&lt;/a&gt;时间步计算&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;configure.dat输入参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fluid（水）&lt;ul&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OTM" scheme="http://liaohuming.com/tags/OTM/"/>
    
  </entry>
  
  <entry>
    <title>OTM代码学习笔记</title>
    <link href="http://liaohuming.com/2017/06/12/20170612-OTM%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://liaohuming.com/2017/06/12/20170612-OTM代码学习笔记/</id>
    <published>2017-06-12T13:01:23.000Z</published>
    <updated>2022-11-18T13:53:02.575Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下3种提交计算任务的方式：<br>(1) 直接提交，例如：/submit.sh vos.gcc_v714M.st<br>(2) 直接提交，将计算过程中的输出信息保存到一个文件中，例如：./submit.sh vos.gcc_v714M.st &amp;&gt; output，用这种方式提交后，计算过程中输出的信息都被保存在output中，可以通过再打开一个命令窗口，用：tail -f output命令来查看<br>(3) 后台计算，例如：nohup ./submit.sh vos.gcc_v714M.st &amp;</p><p>在OTM中<br>(1) Euclidean::Orthonormal::Point，代表没有边界条件的点<br>(2) Euclidean::Cartesian::Point，代表有边界条件的点<br>(3) ModelBuilder.cpp在目录：Eureka_dist\patches\factoryPattern\下<br>(4) PatchBackNodes的生成方式：分为Initialzation和InsertPatch</p><pre><code>* Initialzation：首先拷贝frontNodes，这些frontNodes往x轴方向变动translation距离，形成PatchBackNodes，而PatchBackNodes与frontNodes的连接关系采用vtkDelaunay2Eureka进行初始化，用这两列点重新建立了一层的mesh，即形成新的cell* InsertPatch：初始化之后，后续再插入新的patchNodes采用reflecttion的方式，被reflect的点与原来的点的连接关系是已知的，因此新得到点将按照这样的连接关系形成新的mesh（视频中67分钟：20170612-blasius平板边界层边界条件改进.exe）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux下3种提交计算任务的方式：&lt;br&gt;(1) 直接提交，例如：/submit.sh vos.gcc_v714M.st&lt;br&gt;(2) 直接提交，将计算过程中的输出信息保存到一个文件中，例如：./submit.sh vos.gcc_v714M.st &amp;amp;&amp;gt; o
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OTM" scheme="http://liaohuming.com/tags/OTM/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装openmpi</title>
    <link href="http://liaohuming.com/2017/05/16/20170516-Linux%E4%B8%8B%E5%AE%89%E8%A3%85openmpi/"/>
    <id>http://liaohuming.com/2017/05/16/20170516-Linux下安装openmpi/</id>
    <published>2017-05-15T17:00:05.000Z</published>
    <updated>2022-11-18T11:50:43.865Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://blog.sina.com.cn/s/blog_872ecf9f01013dpe.html" target="_blank" rel="noopener">openmpi在centos上的安装</a></p><ul><li>下载openmpi-1.8.8.tar.gz</li><li>上传openmpi-1.8.8.tar.gz到服务器指定目录，例如：/home/software</li><li><p>解压</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openmpi<span class="number">-1.8</span><span class="number">.8</span>.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>同级目录创建安装目录openmpi_install</p></li><li><p>进入解压后的目录openmpi-1.8.8，在该目录下配置安装路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/software/openmpi_install</span><br></pre></td></tr></table></figure></li><li><p>执行make</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure></li><li><p>执行make install</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>在用户目录下设置mpi的路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi .bash_profile</span><br><span class="line"><span class="keyword">export</span> OPENMPI=/home/software/openmpi_install</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$OPENMPI/lib</span><br><span class="line"><span class="keyword">export</span> PATH=$OPENMPI/bin:$PATH</span><br></pre></td></tr></table></figure></li></ul><p>在linux系统普通用户目录（cd /home/xxx）或root用户目录（cd /root）下，用指令ls -al可以看到4个隐藏文件，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bash_history   <span class="comment">//记录之前输入的命令</span></span><br><span class="line">.bash_logout    <span class="comment">//当你退出时执行的命令</span></span><br><span class="line">.bash_profile   <span class="comment">//当你登入shell时执行</span></span><br><span class="line">.bashrc         <span class="comment">//当你登入shell时执行</span></span><br></pre></td></tr></table></figure></p><p>请注意后两个的区别：’.bash_profile’只在会话开始时被读取一次，而’.bashrc’则每次打开新的终端时，都要被读取。</p><ul><li><p>使更新后的配置生效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></li><li><p>卸载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make uninstall</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;http://blog.sina.com.cn/s/blog_872ecf9f01013dpe.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;openmpi在centos上的安装&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载op
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装mpich</title>
    <link href="http://liaohuming.com/2017/05/15/20170515-Linux%E4%B8%8B%E5%AE%89%E8%A3%85mpich/"/>
    <id>http://liaohuming.com/2017/05/15/20170515-Linux下安装mpich/</id>
    <published>2017-05-15T05:33:10.000Z</published>
    <updated>2022-11-18T13:12:47.996Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://blog.csdn.net/houqd2012/article/details/8053796" target="_blank" rel="noopener">Linux Centos下安装MPICH以及运行第一个并行程序</a></p><ul><li>下载mpich <a href="http://www.mpich.org/downloads/" target="_blank" rel="noopener">http://www.mpich.org/downloads/</a></li><li>上传mpich-3.2.tar.gz到服务器指定目录，例如：/home/software</li><li><p>解压</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxv -f mpich<span class="number">-3.2</span>.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>同级目录创建安装目录mpich_install</p></li><li><p>进入解压后的目录mpich-3.2，在该目录下配置安装路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix=/home/software/mpich_install</span><br></pre></td></tr></table></figure></li><li><p>执行make</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>执行make install</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>在用户目录下设置mpi的路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi .bash_profile</span><br><span class="line"><span class="keyword">export</span> PATH=/home/software/mpich_install/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>使更新后的配置生效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></li><li><p>卸载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make uninstall</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;http://blog.csdn.net/houqd2012/article/details/8053796&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Centos下安装MPICH以及运行第一个并行程序&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++中“/”的非整除用法</title>
    <link href="http://liaohuming.com/2017/04/19/20170419-C++%E4%B8%AD%E2%80%9C%E6%96%9C%E6%9D%A0%E2%80%9D%E9%9D%9E%E6%95%B4%E9%99%A4%E7%94%A8%E6%B3%95/"/>
    <id>http://liaohuming.com/2017/04/19/20170419-C++中“斜杠”非整除用法/</id>
    <published>2017-04-19T08:19:17.000Z</published>
    <updated>2020-02-27T05:53:58.327Z</updated>
    
    <content type="html"><![CDATA[<ul><li>C++中除号的用法错误，在C++中如果“/”两端皆为整数，那么将执行整除运算，即仅取除法运算中的整数部分（并不会四舍五入），要想做非整除运算，需要在“/”两端接float或者double类型的非整型数据类型，这样“/”将进行非整除运算，如下。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">300</span>/<span class="number">180</span>*<span class="number">3.14159</span>);    <span class="comment">// cos(3.14159)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">3.14159</span>*<span class="number">300</span>/<span class="number">180</span>);   <span class="comment">// cos(5.23598)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">300.0</span>/<span class="number">180.0</span>*<span class="number">3.14159</span>);   <span class="comment">// cos(5.23598)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;C++中除号的用法错误，在C++中如果“/”两端皆为整数，那么将执行整除运算，即仅取除法运算中的整数部分（并不会四舍五入），要想做非整除运算，需要在“/”两端接float或者double类型的非整型数据类型，这样“/”将进行非整除运算，如下。&lt;figure cl
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Windows下OTM开发环境配置</title>
    <link href="http://liaohuming.com/2016/12/12/20161219-Windows%E4%B8%8BOTM%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://liaohuming.com/2016/12/12/20161219-Windows下OTM开发环境配置/</id>
    <published>2016-12-11T16:34:16.000Z</published>
    <updated>2016-12-19T12:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>开发工具包含：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Visual studio <span class="number">2013</span>、NetBeans <span class="number">7.4</span>、VCC4N_0<span class="number">.3</span><span class="number">.3</span>_beta、cygwin</span><br></pre></td></tr></table></figure></li><li><p>在NetBeans 7.4 IDE下，通过VCC4N_0.3.3_beta调用Visual studio 2013进行C++编译</p></li><li><p>黎老师提供的Escaas_win库文件是Visual studio 2013编译的，在利用这些库文件编译主程序时，编译器的版本要一致，所采用的C++编译器需要是Visual studio 2013，否则会出现 _MSC_VER 错误</p></li></ul><p>在NetBeans中&gt;工具&gt;选项&gt;C/C++&gt;构建工具</p><ul><li><p>设置基目录为，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Software\netbeans<span class="number">-7.4</span>\VCC4N_0<span class="number">.3</span><span class="number">.3</span>_beta\tools</span><br></pre></td></tr></table></figure></li><li><p>设置C编译器为，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Software\netbeans<span class="number">-7.4</span>\VCC4N_0<span class="number">.3</span><span class="number">.3</span>_beta\tools\msvc_caller.exe</span><br></pre></td></tr></table></figure></li><li><p>设置C++编译器为，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Software\netbeans<span class="number">-7.4</span>\VCC4N_0<span class="number">.3</span><span class="number">.3</span>_beta\tools\msvc_caller.exe</span><br></pre></td></tr></table></figure></li><li><p>设置Make命令为，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\cygwin64\bin\make.exe</span><br></pre></td></tr></table></figure></li></ul><p>在项目属性中</p><ul><li><p>C++编译器中常规，设置包含目录和头文件，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">../../include</span><br><span class="line">../../patches</span><br><span class="line">../../external/jama</span><br><span class="line">../../external/stlib</span><br><span class="line">../../external/SuperLU_4<span class="number">.3</span></span><br><span class="line">../../external/tnt</span><br><span class="line">../../external/stlib/packages</span><br></pre></td></tr></table></figure></li><li><p>在链接器中常规，设置其他库目录，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../lib/x64/Release</span><br></pre></td></tr></table></figure></li><li><p>在库中，添加库文件（黎老师提供的Escaas_win库文件是Visual studio 2013编译的，在利用这些库文件编译主程序时，编译器的版本要一致，所采用的C++编译器需要是Visual studio 2013，否则会出现 _MSC_VER 错误）例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">../../lib/x64/Release/libeurekaclock.a</span><br><span class="line">../../lib/x64/Release/libeurekacrystalplasticity.a</span><br><span class="line">../../lib/x64/Release/libeurekaelement.a</span><br><span class="line">../../lib/x64/Release/libeurekageometry.a</span><br><span class="line">../../lib/x64/Release/libeurekamaterial.a</span><br><span class="line">../../lib/x64/Release/libeurekamodel.a</span><br><span class="line">../../lib/x64/Release/libeurekamodel_st.a</span><br><span class="line">../../lib/x64/Release/libeurekapatch.a</span><br><span class="line">../../lib/x64/Release/libeurekapotential.a</span><br><span class="line">../../lib/x64/Release/libeurekaset.a</span><br><span class="line">../../lib/x64/Release/libeurekasolver.a</span><br><span class="line">../../lib/x64/Release/libeurekautils.a</span><br><span class="line">../../lib/x64/Release/libfemap2eureka.a</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;开发工具包含：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OTM" scheme="http://liaohuming.com/tags/OTM/"/>
    
  </entry>
  
  <entry>
    <title>Linux下OTM运行环境配置</title>
    <link href="http://liaohuming.com/2016/12/12/20161212-Linux%E4%B8%8BOTM%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://liaohuming.com/2016/12/12/20161212-Linux下OTM运行环境配置/</id>
    <published>2016-12-11T16:34:16.000Z</published>
    <updated>2016-12-19T11:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>制作U盘安装盘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//vickyzhang.blog.51cto.com/5930715/1751000</span></span><br></pre></td></tr></table></figure></li><li><p>安装gcc、make、git、Gtk2.0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++ </span><br><span class="line">yum -y install make</span><br><span class="line">yum -y install git</span><br><span class="line">yum -y groupinstall <span class="string">"Development Tools"</span></span><br><span class="line">yum -y kernel-devel</span><br><span class="line">yum -y install libgnomeui-devel    <span class="comment">//解决 No package ‘gtk+-2.0′ found问题</span></span><br><span class="line">yum -y install libX*    <span class="comment">//有时，Linux/CentOS系统没有g++包或g++的部分包</span></span><br></pre></td></tr></table></figure></li><li><p>安装cmake</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake </span><br><span class="line">sudo yum install cmake-gui</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//cmake.org/files/v3.6/cmake-3.6.0.tar.gz    //下载</span></span><br><span class="line"></span><br><span class="line">tar -xzvf cmake<span class="number">-3.6</span><span class="number">.0</span>.tar.gz <span class="comment">//解压</span></span><br><span class="line"></span><br><span class="line">cd cmake<span class="number">-3.6</span><span class="number">.0</span>  <span class="comment">//进入目录</span></span><br><span class="line"></span><br><span class="line">./bootstrap --prefix=/home/software/cmake_install <span class="comment">//设置安装路径</span></span><br><span class="line"></span><br><span class="line">gmake</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line">    <span class="comment">//在文件末尾处增加一下三行代码</span></span><br><span class="line">    #cmake tools</span><br><span class="line">    PATH=/home/software/cmake_install/bin:$PATH</span><br><span class="line">    <span class="keyword">export</span> PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile <span class="comment">//source命令使刚修改的文件生效</span></span><br><span class="line"></span><br><span class="line">echo $PATH  <span class="comment">//接着使用echo命令查看PATH的值</span></span><br><span class="line"></span><br><span class="line">cmake --version <span class="comment">//检查cmake是否成功安装</span></span><br></pre></td></tr></table></figure><ul><li><p>安装openGL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="built_in">list</span> mesa*      <span class="comment">// 它会列出所有可用的mesa包 </span></span><br><span class="line">yum install mesa*   <span class="comment">// 安装所有可用的mesa包</span></span><br></pre></td></tr></table></figure></li><li><p>安装freeglut</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install freeglut*</span><br></pre></td></tr></table></figure></li><li><p>安装python</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python-devel</span><br></pre></td></tr></table></figure></li><li><p>安装tcl、tk</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf tcl8<span class="number">.5</span><span class="number">.9</span>-src.tar.gz</span><br><span class="line">cd tcl8<span class="number">.5</span><span class="number">.9</span>/</span><br><span class="line">cd unix/</span><br><span class="line">./configure --prefix=/usr/local/tcl/ --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">tar -zxvf tk8<span class="number">.5</span><span class="number">.9</span>-src.tar.gz</span><br><span class="line">cd tk8<span class="number">.5</span><span class="number">.9</span>/</span><br><span class="line">cd unix/</span><br><span class="line">./configure --prefix=/usr/local/tk/ --with-tcl=/usr/local/tcl/lib/ --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装XCB:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum whatprovides <span class="string">"*/libxcb-xlib.so"</span></span><br><span class="line"></span><br><span class="line">tar -xvzf libxcb<span class="number">-1.11</span><span class="number">.1</span>.tar</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装qt-everywhere-opensource-src-5.7.0.tar</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf qt-everywhere-opensource-src<span class="number">-5.7</span><span class="number">.0</span>.tar</span><br><span class="line">vi .bash_profile</span><br><span class="line"></span><br><span class="line">    QTDIR=/home/software/qt-everywhere-opensource-src<span class="number">-5.7</span><span class="number">.0</span></span><br><span class="line">    <span class="keyword">export</span> PATH=$QTDIR/bin:$PATH</span><br><span class="line">    <span class="keyword">export</span> MANPATH=$QTDIR/man:$MANPATH</span><br><span class="line">    <span class="keyword">export</span> LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH</span><br><span class="line">    <span class="keyword">export</span> LIBGL_ALWAYS_INDIRECT=y</span><br><span class="line">source .bash_profile</span><br><span class="line"></span><br><span class="line">cd qt-everywhere-opensource-src<span class="number">-5.7</span><span class="number">.0</span></span><br><span class="line">./configure</span><br><span class="line">gmake</span><br><span class="line">gmake install</span><br></pre></td></tr></table></figure></li><li><p>安装vtk</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官网（http://vtk.org/VTK/resources/software.html#latest）下载</span></span><br><span class="line">VTK<span class="number">-6.0</span><span class="number">.0</span>.tar.gz <span class="comment">//source</span></span><br><span class="line">VTKData<span class="number">-6.0</span><span class="number">.0</span>.tar.gz    <span class="comment">//data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压 VTK-6.0.0.tar.gz和VTKData-6.0.0.tar.gz至VTK-6.0.0</span></span><br><span class="line">tar -xzvf VTK<span class="number">-6.0</span><span class="number">.0</span>.tar.gz </span><br><span class="line">tar -xzvf VTKData<span class="number">-6.0</span><span class="number">.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同级目录建立VTK-build目录并进入执行makefile的创建</span></span><br><span class="line">mkdir VTK-build</span><br><span class="line">cd VTK-build</span><br><span class="line">cmake ../VTK<span class="number">-6.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//跳出配置页面进行配置后，执行make</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">//出现错误，In file included from /usr/include/GL/glx.h:333:0,from /home/mildred/Work/3DKF/VTK/Rendering/vtkXOpenGLRenderWindow.cxx:31:/usr/include/GL/glxext.h:480:143: error: ‘GLintptr’ has not been declared</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The solution is to define GLX_GLXEXT_LEGACY during the build. This is done but commented in the file Rendering/vtkXOpenGLRenderWindow.cxx for VTK 5.x or Rendering/OpenGL/vtkXOpenGLRenderWindow.cxx for VTK 6.x.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Either uncomment the line (this is for example an ArchLinux patch for the package):</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--- a/Rendering/OpenGL/vtkXOpenGLRenderWindow.cxx.orig  2014-11-23 22:16:50.000000000 +0100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+++ b/Rendering/OpenGL/vtkXOpenGLRenderWindow.cxx   2014-11-23 22:16:59.000000000 +0100 @@ -27,7 +27,7 @@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define GLX_GLXEXT_LEGACY to prevent glx.h to include glxext.h provided by</span></span><br><span class="line"><span class="comment">// the system</span></span><br><span class="line"><span class="comment">// #define GLX_GLXEXT_LEGACY</span></span><br><span class="line"><span class="comment">// #define GLX_GLXEXT_LEGACY</span></span><br><span class="line"> <span class="comment">// #include "GL/glx.h"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// #include "vtkgl.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Or, if you don't want to be invasive on the source code, you can add the flags to the compiler command line. For example by adding -DCMAKE_C_FLAGS=-DGLX_GLXEXT_LEGACY -DCMAKE_CXX_FLAGS=-DGLX_GLXEXT_LEGACY to your cmake command line. Your cmake command will look like:</span></span><br><span class="line"></span><br><span class="line">cmake -DCMAKE_C_FLAGS=-DGLX_GLXEXT_LEGACY -DCMAKE_CXX_FLAGS=-DGLX_GLXEXT_LEGACY -Wno-dev ../VTK<span class="number">-6.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></li></ul><p>//编译完后，执行安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>//在用户目录下设置vtk-lib的路径<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi .bash_profile</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=/usr/lib:/usr/lib64:/usr/local/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure></p><p>//使更新后的配置生效<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></p><p>Ok, 终于成功运行。</p><p>@2016年12月14日21:16:30，北配楼402</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;制作U盘安装盘&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Red hat 配置</title>
    <link href="http://liaohuming.com/2016/12/09/20161209-Red%20hat%20%E9%85%8D%E7%BD%AE/"/>
    <id>http://liaohuming.com/2016/12/09/20161209-Red hat 配置/</id>
    <published>2016-12-09T09:45:31.000Z</published>
    <updated>2021-01-12T01:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>验证网络管理器状态，Active: active (running)表示正在运行，一般RHEL7都默认安装了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="meta"># systemctl status NetworkManager.service</span></span><br></pre></td></tr></table></figure></li><li><p>查看网络设备以及状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="meta"># nmcli dev</span></span><br><span class="line">enp0s25  ethernet  连接的  enp0s25</span><br><span class="line">lo      loopback  未管理  --</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该设备状态不是连接的，则启用它</span></span><br><span class="line">[root@localhost ~]<span class="meta"># nmcli con up id enp0s25 <span class="comment">//enp0s25 不一定叫这个名字</span></span></span><br></pre></td></tr></table></figure></li><li><p>编辑/etc/sysconfig/network-scripts/ifcfg-enp0s25这个配置文件，如果没有就新建一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="meta"># vi /etc/sysconfig/network-scripts/ifcfg-enp0s25</span></span><br><span class="line">TYPE=ethernet           <span class="comment">// 类型为ethernet（以太网）的设备</span></span><br><span class="line">BOOTPROTO=<span class="keyword">static</span>        <span class="comment">// 启用静态IP地址</span></span><br><span class="line">NAME=enp0s25 </span><br><span class="line">ONBOOT=yes              <span class="comment">// 开启自动启用网络连接</span></span><br><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.3</span><span class="number">.31</span>     <span class="comment">// 设置IP地址</span></span><br><span class="line">NETMASK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   <span class="comment">// 设置子网掩码</span></span><br><span class="line">GATEWAY=<span class="number">192.168</span><span class="number">.3</span><span class="number">.1</span>     <span class="comment">// 设置网关</span></span><br><span class="line">DNS1=<span class="number">202.112</span><span class="number">.128</span><span class="number">.51</span>     <span class="comment">// 设置主DNS</span></span><br><span class="line">DNS2=<span class="number">202.112</span><span class="number">.128</span><span class="number">.50</span>     <span class="comment">// 设置备DNS</span></span><br></pre></td></tr></table></figure></li><li><p>重启网络服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="meta"># systemctl restart network</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">[root@localhost ~]<span class="meta"># service network restart</span></span><br></pre></td></tr></table></figure></li><li><p>设置ok，ping</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;验证网络管理器状态，Active: active (running)表示正在运行，一般RHEL7都默认安装了&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令备忘</title>
    <link href="http://liaohuming.com/2016/09/02/20160902-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/"/>
    <id>http://liaohuming.com/2016/09/02/20160902-Linux常用命令备忘/</id>
    <published>2016-09-02T14:28:11.000Z</published>
    <updated>2023-01-06T06:07:51.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="持续更新"><a href="#持续更新" class="headerlink" title="持续更新"></a>持续更新</h3><ul><li><p>通过ssh登陆linux服务器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -y -l username serveraddress</span><br><span class="line"><span class="comment">// username为用户名</span></span><br><span class="line"><span class="comment">// serveraddress为服务器地址</span></span><br></pre></td></tr></table></figure></li><li><p>使用cygwin远程连接linux服务A后，通过A访问远程linux服务器B</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -y -l username server_A_address    <span class="comment">// 先登录远程服务器A</span></span><br><span class="line"></span><br><span class="line">ssh -y -l username server_B_address     <span class="comment">// 再在A上登录远程服务器B</span></span><br></pre></td></tr></table></figure></li><li><p>使用cygwin连接linux服务器时，让cygwin客户端始终保持连接，本实现参考自<a href="https://www.liaohuqiu.net/cn/posts/keep-alive-terminal-connection/" target="_blank" rel="noopener">命令行终端保持连接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls -a   <span class="comment">// 当前用户主目录下，执行查看，看到隐藏的.ssh文件夹</span></span><br><span class="line">cd .ssh     <span class="comment">// 进入.ssh文件夹</span></span><br><span class="line">vi config   <span class="comment">// 打开配置文件（若不存在则创建）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用vi编辑器，在配置文件中输入以下配置，其中时间间隔可自行设置</span></span><br><span class="line">Host *hostname.com</span><br><span class="line">   ServerAliveInterval <span class="number">60</span></span><br><span class="line"><span class="comment">// 保存退出</span></span><br><span class="line"></span><br><span class="line">chmod +x config <span class="comment">// 为其增加执行权限，完成设置</span></span><br></pre></td></tr></table></figure></li><li><p>通过scp跨服务器复制文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scp file1.txt username@serveraddress:/home/username</span><br><span class="line"><span class="comment">// file1.txt 为复制源</span></span><br><span class="line"><span class="comment">// username@serveraddress:/home/username为目标路径</span></span><br><span class="line"></span><br><span class="line">scp -r test username@serveraddress:/home/username</span><br><span class="line"><span class="comment">// -r表示复制的是文件夹，test为文件夹</span></span><br><span class="line"></span><br><span class="line">scp -r -P <span class="number">20782</span> test username@serveraddress:/home/username</span><br><span class="line"><span class="comment">// -P 20782 表示端口号，对于有指定端口需求的，需要采用这种方式</span></span><br></pre></td></tr></table></figure></li><li><p>复制指定目录下的全部文件到另一个目录中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设复制源目录为dir1，目标目录为dir2，怎样才能将dir1下所有文件复制到dir2下？</span></span><br><span class="line"><span class="comment">// 如果dir2目录不存在，则可以直接使用</span></span><br><span class="line">cp -r dir1 dir2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果dir2目录已存在，则需要使用</span></span><br><span class="line">cp -r dir1/. dir2</span><br><span class="line"><span class="comment">// 如果这时使用cp -r dir1 dir2，则也会将dir1目录复制到dir2中，明显不符合要求。</span></span><br></pre></td></tr></table></figure></li><li><p>通过pkill终止指定用户的所有进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill -uusername</span><br><span class="line"><span class="comment">// -u为指定用户的命令，username为指定的用户</span></span><br></pre></td></tr></table></figure></li><li><p>运行目录下的可执行程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./submit.sh test.st</span><br><span class="line"><span class="comment">// ./代表当前路径下，submit.sh是输入参数，test.st是可执行程序</span></span><br></pre></td></tr></table></figure></li><li><p>通过nohup后台运行可执行程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup ./submit.sh test.st &amp;</span><br><span class="line"><span class="comment">// nohup 表示忽略HUP信号，标准输出和标准错误缺省会被重定向到nohup.out文件中</span></span><br><span class="line"><span class="comment">// 在结尾加上 &amp; 来将命令放入后台运行 </span></span><br><span class="line"><span class="comment">// 退出终端时，需要使用exit命令退出终端，如果直接关闭终端窗口会将后台运行的程序一同关闭</span></span><br></pre></td></tr></table></figure></li><li><p>linux 查看隐藏文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：显示所有文件（包含隐藏文件）</span></span><br><span class="line">ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：只显示隐藏文件</span></span><br><span class="line">l.</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：同样只显示隐藏文件</span></span><br><span class="line">ls -d .*</span><br></pre></td></tr></table></figure></li><li><p>通过XTerm打开linux下的图形界面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登陆方式</span></span><br><span class="line">$ ssh username@hostname -Y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登陆成功后，直接输入应用程序名称调用该程序</span></span><br><span class="line">applicationName</span><br></pre></td></tr></table></figure></li><li><p>新建文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可简单利用编辑器vim，如果test.sh存在则打开，不存在则新建</span></span><br><span class="line">vim test.sh</span><br></pre></td></tr></table></figure></li><li><p>删除文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm filename</span><br></pre></td></tr></table></figure></li><li><p>删除文件夹（空与非空）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除空目录</span></span><br><span class="line">rmdir flodername</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除非空目录</span></span><br><span class="line"><span class="comment">// -r 就是向下递归，不管有多少级目录，一并删除</span></span><br><span class="line"><span class="comment">// -f 就是直接强行删除，不作任何提示的意思</span></span><br><span class="line">rm -rf flodername</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">rm -rf /var/<span class="built_in">log</span>/httpd/access</span><br><span class="line">将会删除/var/<span class="built_in">log</span>/httpd/access目录以及其下所有文件、文件夹</span><br><span class="line"></span><br><span class="line">rm -f /var/<span class="built_in">log</span>/httpd/access.<span class="built_in">log</span></span><br><span class="line">将会强制删除/var/<span class="built_in">log</span>/httpd/access.<span class="built_in">log</span>这个文件</span><br></pre></td></tr></table></figure></li><li><p>Linux的关机与重启命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重启命令：</span><br><span class="line">reboot</span><br><span class="line">shutdown -r now     <span class="comment">// 立刻重启(root用户使用)</span></span><br><span class="line">shutdown -r <span class="number">10</span>      <span class="comment">// 过10分钟自动重启(root用户使用) </span></span><br><span class="line">shutdown -r <span class="number">20</span>:<span class="number">35</span>   <span class="comment">// 在时间为20:35时候重启(root用户使用)</span></span><br><span class="line">                    <span class="comment">//如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</span></span><br><span class="line"></span><br><span class="line">关机命令：</span><br><span class="line">halt                <span class="comment">// 立刻关机</span></span><br><span class="line">poweroff            <span class="comment">// 立刻关机</span></span><br><span class="line">shutdown -h now     <span class="comment">// 立刻关机(root用户使用)</span></span><br><span class="line">shutdown -h <span class="number">10</span>      <span class="comment">// 10分钟后自动关机</span></span><br><span class="line">                    <span class="comment">// 如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</span></span><br></pre></td></tr></table></figure></li><li><p>用户、用户组、权限相关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加用户组</span></span><br><span class="line">groupadd groupName</span><br><span class="line">groupdel groupName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加用户</span></span><br><span class="line">useradd userName</span><br><span class="line">passwd userName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个用户添加到用户组中，千万不能直接用： </span></span><br><span class="line">usermod -G groupName userName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样做会使你离开其他用户组，仅仅做为这个用户组groupName的成员。 </span></span><br><span class="line"><span class="comment">// 应该用加上-a选项，a代表append，也就是将自己添加到用户组groupName中，而不必离开其他用户组</span></span><br><span class="line">usermod -a -G groupName userName</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当前登录用户所在的组</span></span><br><span class="line">groups</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看某个用户hmliao所在组</span></span><br><span class="line">groups hmliao</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看有多少用户</span></span><br><span class="line">cat /etc/passwd<span class="comment">//使用此cat命令所打印出来的东西会很乱，可以用下面的命令</span></span><br><span class="line">cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F":" '&#123; print $1"|"$3"|"$4 &#125;'|more</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除用户</span></span><br><span class="line">userdel -r username<span class="comment">// 为了在删除用户时完全删除家目录，我们可以使用 -r 选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通用户加sudo权限</span></span><br><span class="line">sudo vim /etc/sudoers</span><br><span class="line">root  ALL=(ALL)    ALL  <span class="comment">//在“root ALL=(ALL) ALL”这一行下面，再加入一行</span></span><br><span class="line">hmliao ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure></li><li><p>Linux 用户切换、修改用户名、修改密码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通用户到root</span></span><br><span class="line">方式一：命令：su 回车，然后输入root密码</span><br><span class="line">此种方式只是切换了root身份，但Shell环境仍是普通用户的Shell，pwd命令一下，目录仍然是普通用户的工作目录。</span><br><span class="line"></span><br><span class="line">方式二：命令：su - 回车，然后输入root密码</span><br><span class="line">此种方式，是连用户和Shell环境一起切换成root身份。 工作目录变成root的工作目录，pwd命令一下，即可看到。</span><br><span class="line">只有切换用户，才不会出现PATH环境变量错误</span><br><span class="line"></span><br><span class="line"><span class="comment">//root到普通用户</span></span><br><span class="line">命令：su 普通用户名 或 <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改普通用户用户名</span></span><br><span class="line">usermod -l newUserName oldUserName <span class="comment">//这种方法只改了表面，用pwd命令看一下，路径还是之前的用户名</span></span><br><span class="line">usermod -l newUserName -d /home/newUserName -m oldUserName </span><br><span class="line"></span><br><span class="line"><span class="comment">//修改密码</span></span><br><span class="line"><span class="number">1.</span> 修改普通用户密码</span><br><span class="line">命令：sudo passwd userName <span class="comment">//如sudo passwd wyc</span></span><br><span class="line">输入两边新密码</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 修改 root密码</span><br><span class="line">命令：passwd  suName<span class="comment">//修改超级用户的密码，如root的密码</span></span><br><span class="line">输入两遍新密码</span><br></pre></td></tr></table></figure></li><li><p>通过chmod修改文件权限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x submit.sh</span><br><span class="line"><span class="comment">// u代表user，即所有用户，+x代表增加执行权限，submit.sh为要修改权限的文件</span></span><br><span class="line"></span><br><span class="line">chmod u-x submit.sh</span><br><span class="line"><span class="comment">//取消权限</span></span><br></pre></td></tr></table></figure></li><li><p>通过chown修改 文件/目录 的所有者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown userName:userName testfile.xx <span class="comment">//修改tesfile.xx文件拥有者为userName</span></span><br><span class="line">chown -R userName:userName testDir <span class="comment">//修改testDir目录及其所包含的文件的拥有者为userName</span></span><br></pre></td></tr></table></figure></li><li><p>Linux系统查看物理CPU个数、CPU核数及逻辑CPU个数<br>CPU总核数 = 物理CPU个数 <em> 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 </em> 每颗物理CPU的核数 * 超线程数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看CPU信息</span></span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看CPU信息（型号）</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">     <span class="number">28</span>  Intel(R) Xeon(R) CPU E5<span class="number">-2690</span> v4 @ <span class="number">2.60</span>GHz</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看物理CPU个数</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo| grep <span class="string">"physical id"</span>| sort| uniq| wc -l</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; grep 'physical id' /proc/cpuinfo | sort -u | wc -l</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看每个物理CPU中core的个数(即核数)</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo| grep <span class="string">"cpu cores"</span>| uniq</span><br><span class="line">cpu cores       : <span class="number">14</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; grep 'core id' /proc/cpuinfo | sort -u | wc -l</span><br><span class="line"><span class="number">14</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo |grep <span class="string">"cores"</span>|uniq</span><br><span class="line">cpu cores       : <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看逻辑CPU的个数(查看线程数)</span></span><br><span class="line">hmliao@localhost:~&gt; cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br><span class="line"><span class="number">28</span></span><br><span class="line"></span><br><span class="line">hmliao@localhost:~&gt; grep 'processor' /proc/cpuinfo | sort -u | wc -l</span><br><span class="line"><span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看CPU型号</span></span><br><span class="line">sudo dmidecode -s processor-version</span><br></pre></td></tr></table></figure></li><li><p>查看显卡</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -v -s `lspci | awk '/VGA/&#123;print $1&#125;'`</span><br></pre></td></tr></table></figure></li><li><p>查看系统版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">lsb_release  -a</span><br><span class="line"></span><br><span class="line"><span class="comment">//lsb_release: command not found 解决</span></span><br><span class="line"><span class="comment">//解决方法：yum install redhat-lsb -y</span></span><br></pre></td></tr></table></figure></li><li><p>查看硬盘序列号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartctl -i /dev/sda</span><br></pre></td></tr></table></figure></li><li><p>查看硬盘大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -lh</span><br></pre></td></tr></table></figure></li><li><p>查看各文件夹大小</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h <span class="attribute">--max-depth</span>=1</span><br></pre></td></tr></table></figure></li><li><p>查看当前cpu运行的频率、最大频率、最小频率</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu<span class="meta-keyword">/cpu0/</span>cpufreq/cpuinfo_cur_freq</span><br><span class="line"></span><br><span class="line">cat <span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu<span class="meta-keyword">/cpu0/</span>cpufreq/cpuinfo_max_freq</span><br><span class="line"></span><br><span class="line">cat <span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu<span class="meta-keyword">/cpu0/</span>cpufreq/cpuinfo_min_freq</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;持续更新&quot;&gt;&lt;a href=&quot;#持续更新&quot; class=&quot;headerlink&quot; title=&quot;持续更新&quot;&gt;&lt;/a&gt;持续更新&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过ssh登陆linux服务器&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下批量运行测试算例的简单实现（二）</title>
    <link href="http://liaohuming.com/2016/08/22/20160822-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://liaohuming.com/2016/08/22/20160822-Linux下批量运行测试算例的简单实现（二）/</id>
    <published>2016-08-22T15:21:17.000Z</published>
    <updated>2020-02-27T06:02:49.004Z</updated>
    
    <content type="html"><![CDATA[<p>记录在Linux服务器上，批量创建、移动、启动、提取，命名规范的相关计算文件的简单实现。适用情况在<a href="http://liaohuming.com/2016/02/08/notes/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">Linux下批量运行测试算例的简单实现（一）</a>中有详细介绍，此处只对改进的代码做相应的更新，以为备忘。</p><p><strong>1、批量创建、移动</strong><br>创建shell脚本，例如<code>FileCreater.sh</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">floderName=$<span class="number">1</span>#输入参数<span class="number">1</span>，文件夹名称</span><br><span class="line">dir_id_start=$<span class="number">2</span>#输入参数<span class="number">2</span>，起始编号</span><br><span class="line">dir_id_end=$<span class="number">3</span>#输入参数<span class="number">3</span>，结束编号</span><br><span class="line">submitName=submit</span><br><span class="line">submitSuffix=.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> test $dir_id_start -le $dir_id_end</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $floderName$dir_id_start</span><br><span class="line">cp mesh_square.dat $floderName$dir_id_start/mesh.dat</span><br><span class="line">cp verification_oscillation.erosion $floderName$dir_id_start/$floderName$dir_id_start.erosion</span><br><span class="line">mv $submitName$dir_id_start$submitSuffix $floderName$dir_id_start</span><br><span class="line">cd $floderName$dir_id_start</span><br><span class="line">mkdir fluid</span><br><span class="line">mkdir solid</span><br><span class="line">chmod +x $submitName$dir_id_start$submitSuffix</span><br><span class="line">cd ..</span><br><span class="line">dir_id_start=`expr $dir_id_start + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行：<code>./FileCreater.sh test 1 100</code><br>功能：将当前目录存在的100份计算输入参数文件<code>submit1.sh, submit2.sh, ..., submit100.sh</code>分配到100个文件夹（名称通过输入参数floderName定义，本例中为<code>test1, test2, ..., test100</code>）中，并将计算所需的主程序按计算参数文件进行编号后分配至对应的文件夹，并拷贝及创建相应的文件及文件夹，修改权限。</p><p><strong>2、批量启动</strong><br>创建shell脚本，例如<code>ProcessStarter.sh</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dir_name=$<span class="number">1</span>#输入参数<span class="number">1</span>，文件夹名称</span><br><span class="line">dir_id=$<span class="number">2</span>#输入参数<span class="number">2</span>，起始编号</span><br><span class="line">dir_id_end=$<span class="number">3</span>#输入参数<span class="number">3</span>，结束编号</span><br><span class="line"></span><br><span class="line">submitName=./submit</span><br><span class="line">submitSuffix=.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $dir_id_end</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $dir_name$dir_id</span><br><span class="line">nohup $submitName$dir_id$submitSuffix $dir_name$dir_id.erosion &amp;</span><br><span class="line">cd ..</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行：<code>./ProcessStarter.sh test 1 100</code><br>功能：批量启动100份文件夹中的计算主程序<code>test1.erosion, test2.erosion, ..., test100.erosion</code>，运行方式：后台运行。</p><p><strong>3、批量提取</strong><br>创建shell脚本，例如<code>ResultGatherer.sh</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sourcePath=/home/hmliao/#数据源路径</span><br><span class="line">destinationPath=/home/hmliao/createFloder/#数据目标路径</span><br><span class="line">floderName=$<span class="number">1</span>#输入参数<span class="number">1</span>，文件夹名称</span><br><span class="line">floderStart=$<span class="number">2</span>#输入参数<span class="number">2</span>，N个测试文件中需要提取的范围（开始）</span><br><span class="line">floderEnd=$<span class="number">3</span>#输入参数<span class="number">3</span>，N个测试文件中需要提取的范围（结束）</span><br><span class="line">fluidStart=$<span class="number">4</span>#输入参数<span class="number">4</span>，每个份测试文件中M份结果数据，需要提取的结果范围（开始）</span><br><span class="line">fluidEnd=$<span class="number">5</span>#输入参数<span class="number">5</span>，每个份测试文件中M份结果数据，需要提取的结果范围（结束）</span><br><span class="line">fileName=fluid_0_</span><br><span class="line">submitSuffix=.vtu</span><br><span class="line"></span><br><span class="line">#创建目录，用于放置提取的结果</span><br><span class="line">dir_id1=$floderStart</span><br><span class="line"><span class="keyword">while</span> test $dir_id1 -le $floderEnd</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $destinationPath$floderName$dir_id1</span><br><span class="line">dir_id1=`expr $dir_id1 + <span class="number">1</span>`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#提取结果至前述创建的目录</span><br><span class="line">dir_id2=$floderStart</span><br><span class="line"><span class="keyword">while</span> test $dir_id2 -le $floderEnd</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">#Copy fluid files</span><br><span class="line">fileId=$fluidStart</span><br><span class="line"><span class="keyword">while</span> test $fileId -le $fluidEnd</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cp  $sourcePath$<span class="number">1</span>$dir_id2/fluid/$fileName$fileId$submitSuffix $destinationPath$<span class="number">1</span>$dir_id2/</span><br><span class="line">fileId=`expr $fileId + <span class="number">1</span>`</span><br><span class="line">done</span><br><span class="line">dir_id2=`expr $dir_id2 + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行：<code>./ResultGatherer.sh Result 1 100 1 30</code><br>功能：如前所述，批量运行100份测试程序，对于一份测试，其测试过程中计算步数很多，需要在计算过程中即对计算结果（假设已计算得到30份结果）进行可视化分析，以判断是否有必要继续进行下去。因此需要将100个文件夹中，各自的30份文件，提取到一个独立的文件夹Result，然后将Result下载到本地机器进行分析。通过这个简单的脚本，可以方便的提取自己所需要的数据，数据的筛选及收集就是一条命令的事情，最后将结果数据下载即可分析，提高效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录在Linux服务器上，批量创建、移动、启动、提取，命名规范的相关计算文件的简单实现。适用情况在&lt;a href=&quot;http://liaohuming.com/2016/02/08/notes/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://liaohuming.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>最近</title>
    <link href="http://liaohuming.com/2016/08/18/20160818-%E6%9C%80%E8%BF%91/"/>
    <id>http://liaohuming.com/2016/08/18/20160818-最近/</id>
    <published>2016-08-17T16:04:35.000Z</published>
    <updated>2020-02-23T05:12:08.870Z</updated>
    
    <content type="html"><![CDATA[<p>七月的生活可用纯粹、煎熬两个词来概括。</p><p><strong>纯粹</strong><br>这段时间美共和党在克利夫兰召开全国代表大会，正值土耳其政变、法国尼斯国庆恐怖袭击、南海仲裁、枪击警察、黑人游行…，各种烽火不息，加之川普支持反对者向来激进狂热的作风，内忧外患一时之间甚有草木皆兵危机四伏的感觉，为安全起见学校封校一周。至此，我正式开启了闭关修炼的一个月，七月的克利夫兰，炎炎夏日，白天甚至比黑夜还死寂，这种寂静令人心慌，令人兴奋。每天于闷热中从低质量的睡眠中挣扎醒来，泡浓浓一杯咖啡，咬两片干面包，而后伴着李志摇滚式民谣开始coding、simulation、literature research、writing，傍晚去Shaker lake跑三圈，释放一天积压下来的情绪以及思考所遇到的问题，晚餐一罐啤酒，洗漱完毕后重又有了精神，继续干活至凌晨睡觉，这样持续了两周，在<a href="https://github.com/liaohuming/LmeTestTools" target="_blank" rel="noopener">前期</a>积累的基础上，我顺利的完成了论文，这是一段非常纯粹的时光。</p><p><strong>煎熬</strong><br>黎老师风尘仆仆的从国内回来，到学校后立即着手指导我修改论文，涉及文章结构、引用内容、图表质量、行文措辞、语法勘误等方方面面，细节再细节，推倒重来再推倒，来来回回三五轮修改，最终在8月11号将论文投出，这是我第一篇SCI投稿希望会有好的结果。改论文的两周可谓煎熬，有煎熬之感即代表尚有提高之处，非常感谢能有这样的一次学习经历，这种直接向优秀的人学习的机会不可多得，不仅让我清楚明白地认识到自身水平的欠缺，同时也感受到了一名优秀学者严谨的治学态度和敏锐的科研思维，受益匪浅。</p><p><strong>释然</strong><br>八月的第二个周末和朋友去了传说中的世界过山车之都Cedar point，开始我惊愕于各种惊险的轨道路线及乘客歇斯底里的尖叫声。随后和朋友们一起去体验了这种急速超重失重，天旋地转，跌落万丈深渊的感觉，这真的非常刺激，同时也伴随着巨大的恐惧感，所以大家才会歇斯底里的尖叫以释放这种情绪。为什么会有恐惧感？这让我想起大学室友吴力曾经说过，人之所以对某件事感到恐惧或迷茫，是因为自身对这件事没有掌控力。我很赞同这个看法，一只逗比的哈士奇或是温顺忠诚的秋田犬，想必是人见人爱，但如果是一只疯狗，我想大家都可能会有所惧怕，因为它不受控制，随时可能给自己带来伤害。类似的，坐这种惊险的过山车恰恰就会给你提供无限大的无控感：你的身体像炮弹一样进行高速运动，行进路线百转千回，急速状态下的上升、坠落、旋转、俯冲、超重、失重，这些极限的运动状态会让我们脱离平日里舒适的状态，从而失去对自身身体的掌控，下一步会怎么样完全是未知的，换句话说，在这短短的几十秒甚至十几秒的过程中，眼睛所接受的急速影像和身体所承受的极限状态，这些信息给我们的印象是危险，而我们能控制身体来应对这种危险的能力几乎为0，所以抓紧座椅、闭眼和尖叫是绝大部分人的选择。其实并非不能控制，对于这种极限运动，对身体的安全性保护本身就很完善，除非小概率突发故障，否则没有必要担心。这个时候我们需要转换控制对象，要控制的不再是身体，而是情绪，即是说要淡定，知道这个东西它就这么飞，就这么转，它既不会掉下来也不会撞上去，一切可能的危险都是假象都是纸老虎，只要放下了这个担心，不用闭眼，无需尖叫，放松状态下得到的将会极限体验的快感，罗哩吧嗦这么多，其实这就是我在坐第一趟过山车无控感骤升、恐惧感爆表时闪过脑海的想法，现在要码下来还得费半天劲也无法贴切描述出那种感觉，人的大脑在遇到极度危险的时候思维速度之外真的是可以让时间缓若静止，这可以让平日里诸多的困惑在短短的几秒中即得到释然，也许这正是各种极限运动的魅力之所在吧！当然熟知了这些，能够直面恐惧之后，剩余的就是极限运动带来的极致体验了，后面我真的是开始享受这种刺激了。当然，上述这些都是我的个人体验，仅我有效。</p><p><img src="/img/20160818-1.jpg" alt=""></p><p><img src="/img/20160818-2.jpg" alt=""></p><p><img src="/img/20160818-3.jpg" alt=""></p><p><img src="/img/20160818-4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;七月的生活可用纯粹、煎熬两个词来概括。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯粹&lt;/strong&gt;&lt;br&gt;这段时间美共和党在克利夫兰召开全国代表大会，正值土耳其政变、法国尼斯国庆恐怖袭击、南海仲裁、枪击警察、黑人游行…，各种烽火不息，加之川普支持反对者向来激进狂热的作风，内忧外患
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>我们都需要改变</title>
    <link href="http://liaohuming.com/2016/05/01/20160501-%E6%88%91%E4%BB%AC%E9%83%BD%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98/"/>
    <id>http://liaohuming.com/2016/05/01/20160501-我们都需要改变/</id>
    <published>2016-05-01T01:39:33.000Z</published>
    <updated>2020-02-23T04:32:23.850Z</updated>
    
    <content type="html"><![CDATA[<p>“滑膜肉瘤”事件在网上传播有好些日子了，今早起来看到<strong><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;mid=2650968235&amp;idx=1&amp;sn=6c99a7f680af5679215ae09351bf9f1d&amp;scene=25#wechat_redirect" target="_blank" rel="noopener">「青年魏则西之死」</a></strong>在微信朋友圈传播了，每次看到这样的消息，心情都很复杂，想表达些什么，却有一种很深的无力感。“滑膜肉瘤”事件只是存在着的千万事件之一，再多想一点就会对这个社会多绝望一些，但是如果人人都不发声，不作为，那就不会有改变。我们都需要改变。</p><p>百度利益至上不客观(甚至错误导向)竞价排名的搜索是推波助澜的邪恶之手、社会上诸多缺乏有效监督的环节是本源。我们的生活环境很糟糕，「假、毒」的「信息、食品、环境」让我们时时刻刻小心翼翼地甄别着日常生活最基本的要素，即便如此也不能保证自己及身边的亲人好友能不受到伤害。当一个社会环境要求生活在其中的社会成员具备苛刻的辨识能力「才有可能」生存，当生存变得如此艰难时，那么这个社会环境是迫切需要改善了，让大家都成为辨识专家来避免不受各种虚假毒害信息的蛊惑终究是治标不治本的方法，<strong>社会中占主导地位的应该是真善美，传播真善美，不作恶不发不义财，是我们每个人心中都该有的一个基本原则。同时一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。体制要改善，要有作为。</strong>而现在我能做的，就是不用百度(至少在它变得客观之前不用)、不作恶、传播真善美。诸君共勉。</p><p>@2016年5月1日10:10:16</p><hr><p><strong>「魏则西事件」</strong>所引起广泛的<strong>「讨论，调查，还没有到究责，整改阶段」</strong>这股热潮已与以往无数股「骗、假、毒」热潮一般悄然褪去，禁的禁，删的删，挡也挡不住，拉也拉不回，昨一日还是口诛笔伐震惊网坛，今一日已是歌舞升平天下太平，明一日定是不了了之无人问津矣。不知道此次事件牵涉到的对象会有多少改进。社会的进步，体制的健全，真不是一朝一夕的事情，还是需要遵守客观规律，历史的巨轮前进一小步需要巨大的时间来积累矛盾，积累爆发的能量。</p><p>@2016年5月4日00:50:47</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“滑膜肉瘤”事件在网上传播有好些日子了，今早起来看到&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;amp;mid=2650968235&amp;amp;idx=1&amp;amp;sn=6c99a7f68
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
