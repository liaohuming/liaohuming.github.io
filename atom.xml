<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>To Be Better</title>
  
  <subtitle>Keep thinking, and keep writing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaohuming.com/"/>
  <updated>2018-03-06T14:35:37.589Z</updated>
  <id>http://liaohuming.com/</id>
  
  <author>
    <name>liaohuming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大道平直，努力向前</title>
    <link href="http://liaohuming.com/2018/03/06/diary/20180306-%E5%A4%A7%E9%81%93%E5%B9%B3%E7%9B%B4%E5%8A%AA%E5%8A%9B%E5%90%91%E5%89%8D/"/>
    <id>http://liaohuming.com/2018/03/06/diary/20180306-大道平直努力向前/</id>
    <published>2018-03-06T14:02:41.000Z</published>
    <updated>2018-03-06T14:35:37.589Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>最近</title>
    <link href="http://liaohuming.com/2016/08/18/diary/20160818-%E6%9C%80%E8%BF%91/"/>
    <id>http://liaohuming.com/2016/08/18/diary/20160818-最近/</id>
    <published>2016-08-17T16:04:35.000Z</published>
    <updated>2018-03-03T04:00:46.504Z</updated>
    
    <content type="html"><![CDATA[<p>七月的生活可用纯粹、煎熬两个词来概括。</p><p><strong>纯粹</strong><br>这段时间美共和党在克利夫兰召开全国代表大会，正值土耳其政变、法国尼斯国庆恐怖袭击、南海仲裁、枪击警察、黑人游行…，各种烽火不息，加之川普支持反对者向来激进狂热的作风，内忧外患一时之间甚有草木皆兵危机四伏的感觉，为安全起见学校封校一周。至此，我正式开启了闭关修炼的一个月，七月的克利夫兰，炎炎夏日，白天甚至比黑夜还死寂，这种寂静令人心慌，令人兴奋。每天于闷热中从低质量的睡眠中挣扎醒来，泡浓浓一杯咖啡，咬两片干面包，而后伴着李志摇滚式民谣开始coding、simulation、literature research、writing，傍晚去Shaker lake跑三圈，释放一天积压下来的情绪以及思考所遇到的问题，晚餐一罐啤酒，洗漱完毕后重又有了精神，继续干活至凌晨睡觉，这样持续了两周，在<a href="https://github.com/liaohuming/LmeTestTools" target="_blank" rel="noopener">前期</a>积累的基础上，我顺利的完成了论文，这是一段非常纯粹的时光。</p><p><strong>煎熬</strong><br>黎老师风尘仆仆的从国内回来，到学校后立即着手指导我修改论文，涉及文章结构、引用内容、图表质量、行文措辞、语法勘误等方方面面，细节再细节，推倒重来再推倒，来来回回三五轮修改，最终在8月11号将论文投出，这是我第一篇SCI投稿希望会有好的结果。改论文的两周可谓煎熬，有煎熬之感即代表尚有提高之处，非常感谢能有这样的一次学习经历，这种直接向优秀的人学习的机会不可多得，不仅让我清楚明白地认识到自身水平的欠缺，同时也感受到了一名优秀学者严谨的治学态度和敏锐的科研思维，受益匪浅。</p><p><strong>释然</strong><br>八月的第二个周末和朋友去了传说中的世界过山车之都Cedar point，开始我惊愕于各种惊险的轨道路线及乘客歇斯底里的尖叫声。随后和朋友们一起去体验了这种急速超重失重，天旋地转，跌落万丈深渊的感觉，这真的非常刺激，同时也伴随着巨大的恐惧感，所以大家才会歇斯底里的尖叫以释放这种情绪。为什么会有恐惧感？这让我想起大学室友吴力曾经说过，人之所以对某件事感到恐惧或迷茫，是因为自身对这件事没有掌控力。我很赞同这个看法，一只逗比的哈士奇或是温顺忠诚的秋田犬，想必是人见人爱，但如果是一只疯狗，我想大家都可能会有所惧怕，因为它不受控制，随时可能给自己带来伤害。类似的，坐这种惊险的过山车恰恰就会给你提供无限大的无控感：你的身体像炮弹一样进行高速运动，行进路线百转千回，急速状态下的上升、坠落、旋转、俯冲、超重、失重，这些极限的运动状态会让我们脱离平日里舒适的状态，从而失去对自身身体的掌控，下一步会怎么样完全是未知的，换句话说，在这短短的几十秒甚至十几秒的过程中，眼睛所接受的急速影像和身体所承受的极限状态，这些信息给我们的印象是危险，而我们能控制身体来应对这种危险的能力几乎为0，所以抓紧座椅、闭眼和尖叫是绝大部分人的选择。其实并非不能控制，对于这种极限运动，对身体的安全性保护本身就很完善，除非小概率突发故障，否则没有必要担心。这个时候我们需要转换控制对象，要控制的不再是身体，而是情绪，即是说要淡定，知道这个东西它就这么飞，就这么转，它既不会掉下来也不会撞上去，一切可能的危险都是假象都是纸老虎，只要放下了这个担心，不用闭眼，无需尖叫，放松状态下得到的将会极限体验的快感，罗哩吧嗦这么多，其实这就是我在坐第一趟过山车无控感骤升、恐惧感爆表时闪过脑海的想法，现在要码下来还得费半天劲也无法贴切描述出那种感觉，人的大脑在遇到极度危险的时候思维速度之外真的是可以让时间缓若静止，这可以让平日里诸多的困惑在短短的几秒中即得到释然，也许这正是各种极限运动的魅力之所在吧！当然熟知了这些，能够直面恐惧之后，剩余的就是极限运动带来的极致体验了，后面我真的是开始享受这种刺激了。当然，上述这些都是我的个人体验，仅我有效。</p><p><img src="/img/cedar point1.jpg" alt=""></p><p><img src="/img/cedar point2.jpg" alt=""></p><p><img src="/img/cedar point3.jpg" alt=""></p><p><img src="/img/cedar point4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;七月的生活可用纯粹、煎熬两个词来概括。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯粹&lt;/strong&gt;&lt;br&gt;这段时间美共和党在克利夫兰召开全国代表大会，正值土耳其政变、法国尼斯国庆恐怖袭击、南海仲裁、枪击警察、黑人游行…，各种烽火不息，加之川普支持反对者向来激进狂热的作风，内忧外患
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>我们都需要改变</title>
    <link href="http://liaohuming.com/2016/05/01/diary/20160501-%E6%88%91%E4%BB%AC%E9%83%BD%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98/"/>
    <id>http://liaohuming.com/2016/05/01/diary/20160501-我们都需要改变/</id>
    <published>2016-05-01T01:39:33.000Z</published>
    <updated>2016-07-28T02:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>“滑膜肉瘤”事件在网上传播有好些日子了，今早起来看到<strong><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;mid=2650968235&amp;idx=1&amp;sn=6c99a7f680af5679215ae09351bf9f1d&amp;scene=25#wechat_redirect" target="_blank" rel="noopener">「青年魏则西之死」</a></strong>在微信朋友圈传播了，每次看到这样的消息，心情都很复杂，想表达些什么，却有一种很深的无力感。“滑膜肉瘤”事件只是存在着的千万事件之一，再多想一点就会对这个社会多绝望一些，但是如果人人都不发声，不作为，那就不会有改变。我们都需要改变。</p><p>百度利益至上不客观(甚至错误导向)竞价排名的搜索是推波助澜的邪恶之手、社会上诸多缺乏有效监督的环节是本源。我们的生活环境很糟糕，「假、毒」的「信息、食品、环境」让我们时时刻刻小心翼翼地甄别着日常生活最基本的要素，即便如此也不能保证自己及身边的亲人好友能不受到伤害。当一个社会环境要求生活在其中的社会成员具备苛刻的辨识能力「才有可能」生存，当生存变得如此艰难时，那么这个社会环境是迫切需要改善了，让大家都成为辨识专家来避免不受各种虚假毒害信息的蛊惑终究是治标不治本的方法，<strong>社会中占主导地位的应该是真善美，传播真善美，不作恶不发不义财，是我们每个人心中都该有的一个基本原则。同时一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。体制要改善，要有作为。</strong>而现在我能做的，就是不用百度(至少在它变得客观之前不用)、不作恶、传播真善美。诸君共勉。</p><p>@2016年5月1日10:10:16</p><hr><p><strong>「魏则西事件」</strong>所引起广泛的<strong>「讨论，调查，还没有到究责，整改阶段」</strong>这股热潮已与以往无数股「骗、假、毒」热潮一般悄然褪去，禁的禁，删的删，挡也挡不住，拉也拉不回，昨一日还是口诛笔伐震惊网坛，今一日已是歌舞升平天下太平，明一日定是不了了之无人问津矣。不知道此次事件牵涉到的对象会有多少改进。社会的进步，体制的健全，真不是一朝一夕的事情，还是需要遵守客观规律，历史的巨轮前进一小步需要巨大的时间来积累矛盾，积累爆发的能量。</p><p>@2016年5月4日00:50:47</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“滑膜肉瘤”事件在网上传播有好些日子了，今早起来看到&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;amp;mid=2650968235&amp;amp;idx=1&amp;amp;sn=6c99a7f68
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>多思考，勤笔记</title>
    <link href="http://liaohuming.com/2016/03/31/notes/20160331-%E5%A4%9A%E6%80%9D%E8%80%83%EF%BC%8C%E5%8B%A4%E7%AC%94%E8%AE%B0/"/>
    <id>http://liaohuming.com/2016/03/31/notes/20160331-多思考，勤笔记/</id>
    <published>2016-03-31T13:49:21.000Z</published>
    <updated>2018-03-03T04:02:07.392Z</updated>
    
    <content type="html"><![CDATA[<p>好像有这么个说法：“代码都在网上，学会google你就学会了coding”，确实是如此，学会向搜索引擎提问，问得越到位，得到的答案越精准而且快速。这不仅限于coding，所有一切，只要有疑问的都可以向搜索引擎提问，或多或少都会有些帮助，前提是客观的搜索引擎。然而实际生活中，并不是人人都善于利用搜索引擎来解决问题，大多的时候都喜欢让人代工，我自己以前就常常这么干，明明自己上网搜一下就可以解决的问题，却总是问别人，想着谁能告诉你怎么做。这就是典型的不思考。虽然一般情况下强调学习要多提问，然而多提问很多时候并不一定就是好的，更要注重提问的质量。能自己解决的尽量自己解决，不要让自己成为一个一遇到问题就问人的问题机器，要多思考，注重独自解决问题的能力，求助别人的时候，要搞清楚自己要问的是什么，而不是稀里糊涂的把锅一甩，这不是提问，这是让别人给你做了。</p><p>对于coding这件事，不止于会问，如果想要有提高，夯实基础和总结积累是两个很重要的方面。夯实基础即是要多看书，看好书，看经典。把基本的原理，概念要理解透。总结积累即是要在实践的过程中，对每次遇到的问题、困难进行总结提炼，遇到的问题是什么，自己是怎么解决的，总结的一个好方式就是做笔记写备忘，所谓好记性不如烂笔头，与其相同的问题一次次重复地遇到不如把每次遇到的问题及解决方法都记录下来，一是加深了理解，二来把东西放在自家后院，那才是自己的，用起来或者平时翻出来看看也是方便。</p><p>刚刚开始写笔记的时候常常会觉得，这个东西太简单了，用一次就记住了，没有必要去写。其实并不是这样。简单又何妨，就我个人经验而言，只要是一开始把你难住的问题，往往还会有第二次，第三次。所以，多思考，勤笔记，下次再遇则有迹可循。只有足够努力，方显毫不费力。想做一件事，任何时候都不算太晚，除非只是想想而已。</p><p>呵呵。口号喊完了，该开始写笔记了。我将在这篇笔记中不断地记录自己平时在使用C++时遇到并解决的小问题，并不需要特意去花上半天一天来总结，记录这一动作就发生在平时遇到问题并解决后。</p><hr><p><strong>CString与string的区别及转化</strong></p><p><em>关于CString类型：</em>CString是MFC的类，利用MFC进行编程时会经常用到，而一些标准C/C++库函数是不能直接对CString类型进行操作的，所以经常遇到将CString类型转化char*等其他数据类型的情况。</p><p><em>关于string类型：</em>标准C中是不存在string类型的，string是标准C++扩充字符串操作的一个类，但是标准C中有<code>&lt;string.h&gt;</code>这个头文件，在里面定义了一些经常用到的操作字符串的函数，如：strcpy、strcat、strcmp等，这些函数的操作对象都是char*指向的字符串。 </p><p>而C++的string类（头文件是<code>&lt;string&gt;</code>）操作对象是string类型字符串，该类重载了一些运算符，添加了一些字符串操作成员函数，使得操作字符串更加方便。有时候需要将string串和char*串配合使用，因此也会涉及到这两个类型的转化问题。</p><p>上述是CSting、string.h和string的区别，要对CString和string类型的字符串进行转换，首先将类型转化为<code>char*</code>类型，因为<code>char*</code>是不同类型之间的桥梁。得到<code>char*</code>类型，转化为其他类型就非常容易了。</p><p>1、string to char</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"string to char"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(ch, str.c_str());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>2、char to string</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">255</span>] = <span class="string">"ch to string"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(ch);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>3、string to CString（在Unicode和多字节字符集环境下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"string2CString"</span>;</span><br><span class="line">CString cstr;</span><br><span class="line">cstr = str.c_str();</span><br><span class="line">MessageBox(cstr);</span><br></pre></td></tr></table></figure><p>4、CString to string（在Unicode和多字节字符集环境下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CString cstr = _T(<span class="string">"Cstring2string"</span>);</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = (CStringA)cstr;</span><br></pre></td></tr></table></figure><p>5、string to double</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to double</span></span><br><span class="line"><span class="built_in">string</span> = <span class="string">"3.14159"</span>;</span><br><span class="line"><span class="keyword">double</span> PI=atof(str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将double值转换为string，string转double，或者其他类型</span></span><br><span class="line"><span class="keyword">double</span> length=<span class="number">5.38725</span>;</span><br><span class="line"><span class="built_in">string</span> tempStr;</span><br><span class="line"><span class="built_in">stringstream</span> ssStr;</span><br><span class="line">ssStr&lt;&lt;length;</span><br><span class="line">ssStr&gt;&gt;tempStr;</span><br><span class="line">CString msg;</span><br><span class="line">msg=tempStr.c_str();</span><br><span class="line">MessageBox(msg);</span><br><span class="line">ssStr.clear();</span><br></pre></td></tr></table></figure><p>6、将int转换为CString</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">123</span>;</span><br><span class="line">CString intStr;</span><br><span class="line">intStr.Format(_T(<span class="string">"%d"</span>),num);</span><br><span class="line">MessageBox(intStr);</span><br></pre></td></tr></table></figure><p>7、 CString转char*（解决在Unicode字符集环境下中文乱码问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unicode环境下将CString转换成char*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CStringToChar</span><span class="params">(CString inputStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取宽字节字符的大小，大小是按字节计算的</span></span><br><span class="line">    DWORD dwLength=WideCharToMultiByte(CP_ACP,<span class="literal">NULL</span>,inputStr,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为多字节字符数组申请空间，数组大小为按字节计算的宽字节字节大小</span></span><br><span class="line">    <span class="keyword">char</span> *charStr;</span><br><span class="line">    charStr = <span class="keyword">new</span> <span class="keyword">char</span>[dwLength];</span><br><span class="line">    <span class="keyword">if</span>(!charStr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []charStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//宽字节编码转换成多字节编码</span></span><br><span class="line">    WideCharToMultiByte(CP_ACP,<span class="literal">NULL</span>,inputStr,<span class="number">-1</span>,charStr,dwLength,<span class="literal">NULL</span>,FALSE);</span><br><span class="line">    <span class="keyword">return</span> charStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、MFC 多字节字符集环境下 CString转char*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString Length=<span class="string">"10"</span>;</span><br><span class="line"><span class="keyword">char</span> *LengthStr=Length.GetBuffer(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>9、Unicode环境下将 CString转int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString str=_T(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> i=_ttoi(str);</span><br></pre></td></tr></table></figure><hr><p><strong>C中字符串操作</strong></p><p>1、由于字符串是数组类型，所以两个字符串赋值运算不能直接用“=”（除了初始化时），字符串的比较也不能直接用”==”,，字符串的拼接也不能用”+”,在C中有专门的操作函数，如：strcpy、strcat、strcmp。</p><p>char <em>strcpy(char </em>strDest,const char *strSrc); //是字符串复制函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> strSrc[<span class="number">255</span>] = <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(strDest,strSrc); <span class="comment">// strDest=World!</span></span><br></pre></td></tr></table></figure><p>char <em>strcat(char </em>strDest,const char *strSrc);    //是字符串拼接函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> strSrc[<span class="number">255</span>] = <span class="string">" World!"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(strDest,strSrc); <span class="comment">// strDest=Hello World!</span></span><br></pre></td></tr></table></figure><p>int strcmp(const char <em>str1, const char </em>str2 ; //是字符串比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">255</span>] = <span class="string">" World!"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcat</span>(str1,str2)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 not equal to str2!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、字符串查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> setEndFindStr=<span class="string">"END SETS"</span>;</span><br><span class="line"><span class="keyword">if</span> (lineStr.find(nodesFindStr) &lt; lineStr.length())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; find <span class="string">"END SETS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>格式化字符串</strong></p><p>1、用sscanf</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getline(_inputFile, firstLineStr);</span><br><span class="line"><span class="keyword">char</span> setType[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">char</span> setName[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(firstLineStr.c_str(), <span class="string">"%*[^,],%[^,],%[^,],%*[^,]"</span>, &amp;(setName),&amp;(setType));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解释一下，在这里firstLineStr=CMBLOCK,ELESET1 ,ELEM,28 !users element component definition</span></span><br><span class="line"><span class="comment">//格式化字符串后，setName==ELESET1，setType==ELEM</span></span><br><span class="line"><span class="comment">//%[]类似于一个正则表达式。[a-z]表示读取a-z的所有字符，[^a-z]表示读取除a-z以外的所有字符。</span></span><br><span class="line"><span class="comment">//所以此处``%*[^,]``表示满足``[]``里的条件将被过滤掉，不会向目标参数中写入值。</span></span><br><span class="line"><span class="comment">//即：将在遇到第一个``,``之前的（不为``,``的）字符全部过滤掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他简单用法</span></span><br><span class="line"><span class="comment">//Splitting the string,e.g."*node(1,0.292676,0.078422,-0.07,0,0,0,5,86)"</span></span><br><span class="line"><span class="built_in">sscanf</span>(firstLineStr.c_str(), <span class="string">"*node(%d,%lf,%lf,%lf,%*s,%*s,%*s,%*s,%*s"</span>,</span><br><span class="line">&amp;(node.id), &amp;(node.coordinate[<span class="number">0</span>]), &amp;(node.coordinate[<span class="number">1</span>]), &amp;(node.coordinate[<span class="number">2</span>]));</span><br></pre></td></tr></table></figure><p>2、用strtok<br>strtok的函数原型为char <em>strtok(char </em>s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成中文就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string lineStr="3-4917-1926-2933-34"，以“ ”作为分隔符</span></span><br><span class="line"><span class="keyword">char</span> lineData[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(lineData, lineStr.c_str());</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *delimter = <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">char</span> *item;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; itemCounter;</span><br><span class="line">item = strtok(lineData, delimter);</span><br><span class="line"><span class="keyword">while</span> (item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把char类型的转换成int类型存入临时变量</span></span><br><span class="line"><span class="keyword">int</span> nodeInt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">nodeStr</span><span class="params">(item)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">nodeSs</span><span class="params">(nodeStr)</span></span>;</span><br><span class="line">nodeSs &gt;&gt; nodeInt;</span><br><span class="line">itemCounter.push_back(nodeInt);</span><br><span class="line">item = strtok(<span class="literal">NULL</span>, delimter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、用AfxExtractSubString</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考PDS系统代码，MatlabSample.cpp</span></span><br><span class="line"><span class="comment">//以tab键为分割符，将apdl几何变量存到容器</span></span><br><span class="line">CString tempName;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=ugVariableNum; i&lt;(ugVariableNum+apdlVariableNum); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//tempName得到的字符串，tempStr完整待分割的字符串，i取第几个放在tempName</span></span><br><span class="line">AfxExtractSubString(tempName,tempStr,i,<span class="string">'\t'</span>); </span><br><span class="line">apdlVariableName.push_back(tempName);</span><br><span class="line"><span class="comment">/*MessageBox(tempName);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、用Cstring中的Find()、Mid()、Replace()、Right()、Left()等用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考机场安保系统代码，Logical_Relationship.cpp</span></span><br><span class="line"><span class="keyword">int</span> charPOS=indexstr_old.Find(<span class="string">' '</span>);</span><br><span class="line">Cstring temp=indexstr_old.Right(indexstr_old.GetLength()-charPOS<span class="number">-1</span>);</span><br><span class="line">index=atoi(temp)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>写文件的几种方式</strong></p><p>1、用FILE<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *outputFile = <span class="literal">NULL</span>;</span><br><span class="line">outputFile = fopen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outputFile, <span class="string">"%d\t%d\t%d\t%d\n"</span>, dimension, <span class="number">3</span>, nodes.size(), tria3.size());</span><br><span class="line">fclose(outputFile);</span><br></pre></td></tr></table></figure></p><p>2、用ofstream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">"test.txt"</span>,ofstream::out)</span></span>;</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">"# vtk DataFile Version 2.0"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"VTK file"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"ASCII"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"DATASET UNSTRUCTURED_GRID"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"POINTS "</span> &lt;&lt; nodes.size() &lt;&lt; <span class="string">" float"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; nodes[i].coordinate[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> </span><br><span class="line">&lt;&lt; nodes[i].coordinate[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> </span><br><span class="line">&lt;&lt; nodes[i].coordinate[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、用CStdioFile</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CStdioFile outPutFile( _T("temp.txt"),CFile::modeCreate | CFile::modeWrite | CFile::typeText );</span><br><span class="line"></span><br><span class="line">CString headStr=_T(<span class="string">"!设置工作目录\n"</span>);</span><br><span class="line">outPutFile.WriteString(headStr);</span><br><span class="line"></span><br><span class="line">CString stressDataStr;</span><br><span class="line">stressDataStr.Format(_T(<span class="string">"*cfopen,DATA-stress-result,txt,'%s'"</span>),G_projectPath);</span><br><span class="line">outPutFile.WriteString(stressDataStr);</span><br><span class="line"></span><br><span class="line">outPutFile.Close();</span><br></pre></td></tr></table></figure><hr><p><strong>读文件的几种方式</strong></p><p>1、用ifstream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile;</span><br><span class="line">infile.open(filepath);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (!infile.eof()) </span><br><span class="line">&#123;</span><br><span class="line">getline(infile, line);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure><p>2、用CStdioFile</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CStdioFile apdlFile;</span><br><span class="line">CString apdlPath=_T(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!apdlFile.Open(apdlPath, CFile::modeRead))</span><br><span class="line">&#123;</span><br><span class="line">::AfxMessageBox(_T(<span class="string">"文件打开失败。"</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString apdlStr = _T(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算文件的行数</span></span><br><span class="line"><span class="keyword">int</span> lineCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (apdlFile.ReadString(apdlStr))</span><br><span class="line">&#123;</span><br><span class="line">lineCount++;</span><br><span class="line">&#125;</span><br><span class="line">apdlFile.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件写入一个动态数组</span></span><br><span class="line">CString *apdlArray=<span class="keyword">new</span> CString[lineCount];</span><br><span class="line">apdlFile.Open(apdlPath, CFile::modeRead)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> writeNumber=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (apdlFile.ReadString(apdlStr))</span><br><span class="line">&#123;</span><br><span class="line">apdlArray[writeNumber]=apdlStr;</span><br><span class="line">writeNumber++;</span><br><span class="line">&#125;</span><br><span class="line">apdlFile.Close();</span><br></pre></td></tr></table></figure><hr><p><strong>const 与 #define的比较 @2016年4月5日10:09:41</strong></p><p>C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：</p><ul><li>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</li><li>有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。<blockquote><p>「规则1」在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。</p></blockquote></li><li>常量定义规则<blockquote><p>「规则2」需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。<br>「规则3」如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。</p></blockquote></li></ul><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100 <span class="comment">// C语言的宏常量 </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>; <span class="comment">// C++ 语言的const常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159</span>; <span class="comment">// C++ 语言的const常量</span></span><br></pre></td></tr></table></figure></p><hr><p><strong>main函数中argc和argv参数的含义  @2016年4月10日 16:32:23</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="comment">//argc=argument count</span></span></span><br><span class="line"><span class="function"><span class="comment">//argv=argument value</span></span></span><br></pre></td></tr></table></figure><hr><p><strong>使用geline读文件时判断文件末尾的问题  @2016年4月17日00:35:15</strong></p><p>使用<code>getline(infile, lineStr);</code>时，如果infile文件中最后一行不是空行，则会死循环（跳不出循环），这可能是LmeTestTool中有空行没空行时计算出bug的症结之所在。有时间可以去检查一下代码，在这做个备忘。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile;</span><br><span class="line">infile.open(<span class="string">"RBF-Init-Data-Points.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> lineStr = <span class="string">""</span>;</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line"><span class="keyword">while</span> (lineStr != <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> lifeTemp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(lineStr.c_str(), <span class="string">"%d"</span>, &amp;(lifeTemp));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lifeTemp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">lifeVector.push_back(lifeTemp);</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line">&#125;</span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure></p><p>检测EOF：成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(infile.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"已经到达文件尾！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>const和static const的区别 @2016年5月2日16:11:21</strong></p><p>对于C/C++语言来讲，<br>const就是只读的意思，只在声明中使用；<br>static一般有2个作用，规定作用域和存储方式。<br>对于局部变量，static规定其为静态存储方式，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放；<br>对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见；<br>对于static函数也是在当前模块内函数可见。<br>static const 应该就是上面两者的合集。</p><p>下面分别说明：</p><p>全局：<br>const，只读的全局变量，其值不可修改。<br>static，规定此全局变量只在当前模块(文件)中可见。<br>static const，既是只读的，又是只在当前模块中可见的。</p><p>文件:<br>文件指针可当作一个变量来看，与上面所说类似。</p><p>函数:<br>const，返回只读变量的函数。<br>static，规定此函数只在当前模块可见。</p><hr><p><strong>double数组进行递增排序算法 @2016年5月5日11:32:14</strong></p><p>代码示例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">double</span> *)a &gt; *(<span class="keyword">double</span> *)b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcSample_H</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> *h_all = <span class="keyword">new</span> <span class="keyword">double</span>[x_sp.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x_sp.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> h_temp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">if</span> (DIM == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">h_temp = <span class="built_in">sqrt</span>((x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>])*(x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>]) +</span><br><span class="line">(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>])*(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>]));</span><br><span class="line">h_all[i] = h_temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DIM == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">h_temp = <span class="built_in">sqrt</span>((x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>])*(x_sp[id].x[<span class="number">0</span>] - x_sp[i].x[<span class="number">0</span>]) +</span><br><span class="line">(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>])*(x_sp[id].x[<span class="number">1</span>] - x_sp[i].x[<span class="number">1</span>]) +</span><br><span class="line">(x_sp[id].x[<span class="number">2</span>] - x_sp[i].x[<span class="number">2</span>])*(x_sp[id].x[<span class="number">2</span>] - x_sp[i].x[<span class="number">2</span>]));</span><br><span class="line">h_all[i] = h_temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(h_all, x_sp.size(), <span class="keyword">sizeof</span>(h_all[<span class="number">0</span>]), Cmp);<span class="comment">// 从小到大排序</span></span><br><span class="line">x_sp[id].h_min = h_all[<span class="number">1</span>];<span class="comment">// 取第二个h作为该点的最小h，因为第一个是到该点本身的距离，为0</span></span><br><span class="line"><span class="keyword">delete</span>[]h_all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>C++ 函数参数的传递方式 @2016年5月14日13:57:47</strong></p><p>今天写个小程序时犯了个错误，具体表现为：在主函数里声明了一个变量，然后将这个变量传递给一个子函数，这个变量在子函数里进行赋值操作，然后在主函数里接着对该变量进行操作（本意是想对赋值后的变量进行操作的），结果当然是该变量只是初始化的状态，子函数中对该变量的赋值操作并不会对主函数中该变量产生影响。这要从函数参数的传递方式来分析：</p><p><strong>（1）值传递：</strong><br>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参 —&gt; 形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</p><p><strong>（2）指针传递：</strong><br>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p><p><strong>（3）引用传递：</strong><br>形参相当于是实参的「别名」，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><p>下面是之前的错误代码，贴上来做个备忘<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Elements&gt; elementVector;<span class="comment">//1、声明一个变量</span></span><br><span class="line">ReadElemet(elementVector);<span class="comment">//2、传递给子函数（值传递）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、主函数中再调用，该变量并没有赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; elementVector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Elements&gt; ReadElemet(<span class="built_in">vector</span>&lt;Elements&gt; elementVector)</span><br><span class="line">&#123;</span><br><span class="line">Elements tempElem;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.open(<span class="string">"elem_rat.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open \"elem_rat.txt\""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!infile.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> lineStr = <span class="string">""</span>;</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line"><span class="keyword">if</span> (lineStr != <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lineStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(lineStr.c_str(), <span class="string">"%d,%d,%d,%d,%d"</span>, </span><br><span class="line">&amp;(tempElem.id), </span><br><span class="line">&amp;(tempElem.node[<span class="number">0</span>]), </span><br><span class="line">&amp;(tempElem.node[<span class="number">1</span>]), </span><br><span class="line">&amp;(tempElem.node[<span class="number">2</span>]), </span><br><span class="line">&amp;(tempElem.node[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、子函数中做赋值操作，不影响主函数中的变量</span></span><br><span class="line">elementVector.push_back(tempElem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好像有这么个说法：“代码都在网上，学会google你就学会了coding”，确实是如此，学会向搜索引擎提问，问得越到位，得到的答案越精准而且快速。这不仅限于coding，所有一切，只要有疑问的都可以向搜索引擎提问，或多或少都会有些帮助，前提是客观的搜索引擎。然而实际生活中，
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>关于读书的随想</title>
    <link href="http://liaohuming.com/2016/02/05/diary/20160206-%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E9%9A%8F%E6%83%B3/"/>
    <id>http://liaohuming.com/2016/02/05/diary/20160206-关于读书的随想/</id>
    <published>2016-02-05T15:25:57.000Z</published>
    <updated>2016-07-29T04:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直很喜欢阅读，但阅读对我而言已经是很遥远的事情了，能算得上阅读的，最近的也只能追溯到大二大三那会儿了，也就是2007，2008年那段时间，无事的时候便去学校那碉堡似的图书馆去找一些书来看，远离了浮躁，看完一个又一个故事，一时间好似回到了03年的那个夏天：中考结束了，一波三折后终于是被我们镇上的中学录取了。接下来的每天，白天和爸爸妈妈进大坪山里做事，晚上在家里看水浒看得热火朝天，兴奋得常常凌晨一两点都不睡，这在九、十点就是万籁俱寂的农村，真是别样的感受，那会哥哥已在县一中读书了，我整天一个人，劳作让我得到锻炼，阅读让我感到充实。长长的暑假结束后，依旧清晰的记得9月份开学后的第一个晚自习，黑乎乎的我突然见到很多的新同学，像是进城了一样，那天的晚霞很美。</p><p>倒是啊，在北航的这些年常常觉得孤独，常常觉着自己无趣，多少个风雨过后的黑夜，踉踉跄跄独自走过三馆前那片伸手不见五指的小树林，无数个这样的夜里，这条走过千遍万遍的路啊，在脚下却是高高低低总也踩不准，走着走着就撞上了周围的树木，这种感觉就和我现在被禁锢的日子一般，挣扎在铜墙铁壁里处处碰壁，这夜黑得似乎永远不会有黎明的到来，这片树林长得似乎无穷无尽永远都走不出去，而我的生活似乎总也回不到正轨。这样的时候啊，我或者亢奋的唱起许巍的“蓝莲花”释放胸中的豪情，或者呢喃着齐秦的“夜夜夜夜”舒尽心底的柔情，这样的光景，我便常常不好意思起来，担心会有人听到，但跌跌撞撞总归能走出这一片黑暗。呵，就是这样的黑夜，很有奋斗的感觉，也是这样的夜，觉着自己好孤独，更觉着自己是个无趣的人，我的精力和热情多半被繁杂的项目一点点消耗，于是我变得越来越孤独，也许孤僻更合适，越来越无趣，每天只想着怎么完成任务。很显然我和现实的关系有些紧张了，这是必然的结果，长期单调索然无味的生活工作，缺乏交流、缺乏阅读。缺乏交流的结果是对他人的现状缺乏了解以致交流中出现缺乏共同话题而产生厌倦社交的潜意识暗示；而缺乏阅读则更甚，现在大都只读工具书，工具书读了很多，虽是提升了技能，并不能给精神带来滋养，一个干涸扭曲的灵魂，是不可能带来美好的，这才是万恶的根源，而通过阅读、写作、经历、感悟等诸多途径的自我锻炼是有可能获得所期待的美好的，想必那会儿会把自身的这种美好称为修养了吧，是的，因为这是一个修炼的过程，然而要达到这样泰然自若的极佳状态，没有任何人能够帮助你，非得身体力行不可，庆幸向往美好是人的本性，就像肚子饿了本能地会去找食物一样，现在的我又对阅读有了如饥似渴的需求，而一旦开始，在每天的阅读里我非常轻易的就获得了快乐，每一天都收获着美好，书中自有黄金屋，书中自有颜如玉，书中还有美金书签呢。呵，多棒。</p><p>接下来我会持续在本篇博文中更新列出今年所读完的书，并简单附上一句两句若干句即时的随想，到16年年末，看看这一年都会看完了哪些书，看看有什么有趣的事情发生。</p><hr><p><strong>1.《春风沉醉的晚上》</strong></p><p>这是买来kindle后读完的第一本，郁达夫的短篇小说。很短，耐人寻味，常常都会带着一种美好去想邓脱路贫民窟的作者和陈二妹后面怎么样了，他们的生活是否都有好转？</p><p><strong>2.《活着》</strong></p><p>余华的长篇小说，我是在和师弟去Costco的路上开始看的，我不爱出去，来到这该死的克利夫兰之后，每周的超市购物尤其让我头疼，非要我一起去的时候索性在车上看书吧，去的路上有点堵，比往常慢了许多，故事就从爱骑着胖妓女去老丈人门口大声打招呼的败家子福贵身上开始了……，读着有味。逛完超市去理发的路上总觉着时间太短，按预约时间到了理发店见到乌泱泱的前来理发的人占了我们的预约我倒暗自高兴起来，可以接着读这个故事。那天后面，半夜睡不着，起来一口气把剩下的故事读完，好的作品就是有这样的魅力，可是读着读着就不那么美好了，福贵接下来的故事开始让人愤怒、鄙视、可怜、同情、感动、感慨，一系列的感情变化。故事里写出了人对苦难的承受能力，对世界乐观的态度，那种绝望中的希望是那么的有力量。</p><p>于2016年2月6日01:15:08</p><p><strong>3.《兄弟》</strong></p><p>余华的长篇小说，分上下两部。上半部分，在文革的浪潮中，兄弟俩的父亲成为了文革的牺牲品，兄弟俩的母亲成为了接下来艰苦生活的牺牲品，随着父母的离去，精神狂热，本能压抑和命运惨烈的文革时代过去了。下半部分是近现在的故事，是一个伦理颠覆、浮躁纵欲和众生万象的时代。在小说中连接这两个时代的纽带是这兄弟两人，他们的生活在裂变中裂变，他们的悲喜在爆发中爆发，他们的命运和这两个时代一样天翻地覆，最终他们恩怨交集地自食其果。人性是复杂的，自私的弟弟、没有主见的哥哥、善变的女人，是我能够想到的并不贴切的评价。</p><p>于2016年2月13日16:04:24</p><p><strong>4.《罗马不是一天造成的》</strong></p><p>罗马人在智力上比不上希腊人，体力也逊于高卢人或日耳曼人，工艺发展也不是伊特鲁里亚人的对手，经济力更不如迦太基人优秀，但是罗马人开放包容的性格正是它超越其他民族的地方。</p><p>军事及建筑方面的成就会随时间而消逝，但是人们对于古罗马的崇敬却是永不改变的。古代罗马遗留给后世最大的遗产就是他们开放的民族性格。</p><p>讽刺的是，二千年后的现代人非但在宗教上变得狭隘，连统治理念也变得拘泥，种族之间更存在着严重的排他意识，因此罗马可以说是离我们越来越远了。</p><p>于2016年4月29日23:57:38</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直很喜欢阅读，但阅读对我而言已经是很遥远的事情了，能算得上阅读的，最近的也只能追溯到大二大三那会儿了，也就是2007，2008年那段时间，无事的时候便去学校那碉堡似的图书馆去找一些书来看，远离了浮躁，看完一个又一个故事，一时间好似回到了03年的那个夏天：中考结束了，一波三
      
    
    </summary>
    
      <category term="读书" scheme="http://liaohuming.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>命令行多参数解析时getopt()函数的使用方法小结</title>
    <link href="http://liaohuming.com/2016/02/01/notes/20160201-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%9A%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%97%B6getopt()%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://liaohuming.com/2016/02/01/notes/20160201-命令行多参数解析时getopt()函数的使用方法小结/</id>
    <published>2016-02-01T04:13:48.000Z</published>
    <updated>2017-12-13T01:36:22.078Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中，用命令行执行可执行文件时，常常涉及到：<strong>大量、不同类型、不同形式的</strong> 输入参数问题。从简单的说起，现在假设有我们一个用户定义的可执行程序，名为<code>test.sh</code>，它需要3个输入参数，于是我们通过命令行去执行它的时候，往往通过如下的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="一-main函数"><a href="#一-main函数" class="headerlink" title="一. main函数"></a>一. main函数</h3><p>上面的<code>./test.sh</code>是执行程序，<code>1、2、3</code>是<code>test.sh</code>的输入参数，这些命令项通过传递给程序的main函数进行处理，main函数的一般形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>argc是一个整型，argv是一个指针数组，argc记录argv的大小，例如<code>./test.sh 1 2 3</code>将被以如下的方式传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argc=<span class="number">4</span>；</span><br><span class="line">argv[<span class="number">0</span>]=./test.sh;</span><br><span class="line">argv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">argv[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">argv[<span class="number">3</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="二-getopt函数"><a href="#二-getopt函数" class="headerlink" title="二. getopt函数"></a>二. getopt函数</h3><p>现在我们考虑更复杂一些的输入要求，还是以<code>test.sh</code>为例，不过这时它的输入参数要更多一些了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> -a <span class="number">4</span> -b <span class="number">5</span> -c <span class="number">6</span> -Q -S -T  <span class="comment">// 此处仅作为示例，还可以有更多更复杂参数，见后续实例</span></span><br></pre></td></tr></table></figure><p>先说说这一行参数表示什么意思，这里的破折号<code>-</code>表示这是一个控制选项，例如<code>-1</code>，在此处1是单字符选项，而<code>-a 4</code>表示带参数的选项，a是该选项的标识符，4是随同该选项一同传入的参数，<code>-Q</code>，与<code>-1</code>一样，Q也是单字符选项，没有随同的输入参数。通过定义不同的选项，我们可以在<code>test.sh</code>中定义丰富的操作完成各种各样的计算任务，但是这个时候main函数可没有办法给你完成上面的解析工作，main函数只是将<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>传递进来，保存在argc和argv里，至于这些参数如何分配并对应什么操作则是需要用户自行定义了，当然，自己写解析函数是可行的，但是有更好的选择。</p><p>在C语言中，<code>unistd.h</code>提供的<code>getopt()</code>这个函数，结合<code>switch</code>语句，可以帮助我们方便实现参数解析。</p><p>先看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ( (opt=getopt(argc, argv, <span class="string">"123a:b:c:QST"</span>)) != <span class="number">-1</span> ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">      para1 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">      para2 = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">      para3 = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">      para4 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">      para4 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">      para5 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">      definedOption1 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">      definedOption2 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">      definedOption3 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>getopt()函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure><p>使用getopt函数需要包含以下头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>有几个全局变量与getopt函数解析参数有关:<br>optind：int型， 指示下一个要解析的参数位置，初始时为1。<br>optarg：char *， 必须接参数的选项元素的参数， optarg 就指向参数字符串。<br>opterr： int 型， 设为0将不打印错误信。</p><p><code>int argc, char * const argv[]</code>一般是直接通过读取main函数的argc和argv，而optstring则是用户定义的选项字符，例如在上面的例子中，optstring是 <code>123a:b:c:QST</code> ，它用来解析输入参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>，并且是由用户定义。</p><p>字符串optstring的元素一般可分为下面几种：</p><ul><li>单个字符，表示选项，<code>123a:b:c:QST</code>中的1、2、3、Q、S、T都是单字符选项</li><li>单个字符后接一个冒号<code>:</code>表示该选项后必须跟一个参数。参数紧跟在选项后以空格隔开。该参数的指针赋给optarg。<code>123a:b:c:QST</code>中的<code>a:</code>, <code>b:</code>, <code>c:</code> 都表示它们需要附加指定输入参数，这就是为什么在输入参数时是<code>-a 4 -b 5 -c 6</code>的缘故</li><li>单个字符后跟两个冒号<code>::</code>表示该选项后<strong>可选地</strong>跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张，本例中不作介绍）。</li></ul><p><em>update@2016年5月17日17:11:51</em><br>一个选项的识别符号只能是单个字符（或加上与一个冒号<code>:</code>或两个冒号<code>::</code>的组合），不能用多个字符来表示一个选项。<br>例如这样做就会识别出错：<br>用户输入的参数<code>./test.sh -1 -2 -3 -a1 4 -b 5 -c 6 -Q -S -T</code>，那么它对应的optstring则是 <code>123a1:b:c:QST</code>，显然其中<code>a1</code>为两个字符，想让它表示一个选项，是会出现问题的。</p><p>同时，getopt()在unistd.h中的相关定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">extern</span> <span class="keyword">char</span> *optarg;  <span class="comment">//选项的参数指针</span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> optind,    <span class="comment">//下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 </span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> opterr,    <span class="comment">//当opterr=0时，getopt不向stderr输出错误信息。</span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> optopt;    <span class="comment">//当命令行选项字符不包括在optstring中或者选项缺少必要的参数时,</span></span><br><span class="line">                        <span class="comment">//该选项存储在optopt中，getopt返回'?'</span></span><br></pre></td></tr></table></figure><p>那么现在就清楚用户输入的参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>是怎么进行传递和解析的了：</p><ul><li>通过main函数将输入参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>保存在argc和argv</li><li>getopt()按照<code>123a:b:c:QST</code>这个规则去解析argc和argv中保存的数据</li><li>例如，首先去<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>读取到的选项是<code>-1</code>（第一个输入参数./test.sh是执行程序是名称不予考虑），于是就去<code>123a:b:c:QST</code>中检查是否有<code>1</code>这个选项，有的话就返回该选项（这个时候就会转入相应的case执行对应的操作），同时将选项索引optind更新为输入参数的下一个位置(此处为<code>-2</code>的位置)作为下次搜索的开始位置，如果在optstring里没有找到<code>1</code>，例如我们的optstring是<code>23a:b:c:QST</code>，即当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回<code>&#39;?&#39;</code>，并从optind开始进行下一个输入参数的解析</li><li><p>继续解析，当解析到<code>-a</code>时，这个时候getopt()发现optstring里的<code>a</code>后面跟着<code>:</code>于是它知道a是还需要传递进来一个指定的参数，于是就将指针*optarg指向-a后面的一个参数即是4，这样返回选项a的时候，a所对应的参数值此时由optarg指向，这样转入<code>case &#39;a&#39;</code>的时候就可以对该参数进行相应的操作了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">  para4 = atof(optarg);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li><p>接着往下走，-Q -S -T与前面的-1是一样的，都是不带参数的单字符选择，当检查完-T后，返回-1，表示检查完毕，这个时候就完成了对<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>中所有参数的分配工作。</p></li></ul><p>上述简单介绍了命令行多参数解析时getopt()函数的用法，若有错误，欢迎斧正与探讨；若干概念引自文献[1]，若有需要相关概念更详细的解释，可前往阅读。</p><h3 id="三-实例"><a href="#三-实例" class="headerlink" title="三. 实例"></a>三. 实例</h3><p>在Eureka中进行的FSI数值算例中用到如下控制选项，整理出来作为备忘。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">500</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> -M <span class="number">0.01</span> </span><br><span class="line">-U -Q -t <span class="number">0.1</span> -T <span class="number">0.1</span> -d <span class="number">1000</span> -v <span class="number">513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> -g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> </span><br><span class="line">-i <span class="number">0.1</span> -l <span class="number">10.0</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> -K <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line">解析</span><br><span class="line">getopt(argc, argv, <span class="string">"23L:H:W:J:h:D:r:c:x:b:q:R:M:SQUt:T:d:v:f:G:k:p:g:m:s:i:l:I:A:E:P:N:n:K:"</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>控制符</strong></th><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>./$1</td><td></td><td>执行程序名称，e.g. verification_oscillation_structure.gcc_v714M.st</td><td></td></tr><tr><td>-2</td><td>2</td><td>二维</td><td></td></tr><tr><td>-3</td><td>3</td><td>三维</td><td></td></tr><tr><td>-L</td><td>290</td><td>Length</td><td></td></tr><tr><td>-H</td><td>120</td><td>Height</td><td></td></tr><tr><td>-W</td><td>0</td><td>Width</td><td></td></tr><tr><td>-J</td><td>0.1</td><td>critical_shear/maximum shear strain</td><td></td></tr><tr><td>-h</td><td>8</td><td>element size that determines the patch thickness 入口单元尺寸</td><td></td></tr><tr><td>-D</td><td>500</td><td>Domain_End 计算域终点，计算域起点为0.0</td><td></td></tr><tr><td>-r</td><td>1.5</td><td>searchRange, parameters for the shape function</td><td></td></tr><tr><td>-c</td><td>1.0e-5</td><td>cutoff, parameters for the shape function</td><td></td></tr><tr><td>-x</td><td>3.1</td><td>extension, parameters for the shape function</td><td></td></tr><tr><td>-b</td><td>1.6</td><td>beta, parameters for the shape function</td><td></td></tr><tr><td>-q</td><td>1</td><td>integration_order q=1表示单元的中心插入1个质量点</td><td></td></tr><tr><td>-R</td><td>1</td><td>nRing 邻域控制，1表示从单元本身节点开始，如果变形大，可以设置为2</td><td></td></tr><tr><td>-M</td><td>0.01</td><td>mass_factor</td><td></td></tr><tr><td>-S</td><td>true</td><td>adaptive_search</td><td></td></tr><tr><td>-Q</td><td>true</td><td>adaptive_beta</td><td></td></tr><tr><td>-U</td><td>true</td><td>updateNeighbor</td><td></td></tr><tr><td>-t</td><td>0.1</td><td>time step ratio 0.1表示10%</td><td></td></tr><tr><td>-T</td><td>0.1</td><td>total_time simulation time</td><td></td></tr><tr><td>-d</td><td>1000</td><td>dump，number of time steps to visualize the results</td><td></td></tr><tr><td>-v</td><td>513</td><td>max velocity of inflow，speed</td><td></td></tr><tr><td>-f</td><td>1.0</td><td>parameters for the rupture of solids，epsilon_h=1 包含裂纹扩展</td><td></td></tr><tr><td>-G</td><td>1.0e7</td><td>parameters for the rupture of solids</td><td></td></tr><tr><td>-k</td><td>1.42e5</td><td>the bulk modulus of fluid (2.1e9 Pa for water) 体积模量</td><td></td></tr><tr><td>-p</td><td>1.18e-6</td><td>the density of fluid (1.0e3 kg/m^3 for water)</td><td></td></tr><tr><td>-g</td><td>1.4</td><td>Gruneisen parameter in the equation of state of the fluid</td><td></td></tr><tr><td>-m</td><td>0</td><td>nuf，poisson’s ratio of the fluid</td><td></td></tr><tr><td>-s</td><td>1.82e-5</td><td>the shear viscosity coefficient of fluid (1.82e-5kg/(m.s))动力粘度</td><td></td></tr><tr><td>-i</td><td>0.1</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-l</td><td>10</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-I</td><td>0.0</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-A</td><td>0.0</td><td>artificial viscosity coefficient to stablize the simulation 经验系数</td><td></td></tr><tr><td>-E</td><td>2.5e6</td><td>E_Solid，Young’s modulus of solid 固体材料弹性模量</td><td></td></tr><tr><td>-P</td><td>1.0e-4</td><td>rho_Solid，density of solid 固体材料密度</td><td></td></tr><tr><td>-N</td><td>0.35</td><td>nu_Solid，Poisson’s ratio of solid 固体材料泊松比</td><td></td></tr><tr><td>-n</td><td>8</td><td>number of threads 线程数</td><td></td></tr><tr><td>-K</td><td>10</td><td></td><td></td></tr></tbody></table><h3 id="四-参考文献"><a href="#四-参考文献" class="headerlink" title="四. 参考文献"></a>四. 参考文献</h3><p>[1] <a href="http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt" target="_blank" rel="noopener">http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt</a></p><p>2016年2月1日16:18:12<br>于克利夫兰</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux中，用命令行执行可执行文件时，常常涉及到：&lt;strong&gt;大量、不同类型、不同形式的&lt;/strong&gt; 输入参数问题。从简单的说起，现在假设有我们一个用户定义的可执行程序，名为&lt;code&gt;test.sh&lt;/code&gt;，它需要3个输入参数，于是我们通过命令行去执行
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我所理解的C++类设计中private成员变量和返回const引用类型</title>
    <link href="http://liaohuming.com/2016/01/21/notes/20160121-%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84C++%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%ADprivate%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%94%E5%9B%9Econst%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liaohuming.com/2016/01/21/notes/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/</id>
    <published>2016-01-20T16:57:23.000Z</published>
    <updated>2018-03-03T06:27:25.056Z</updated>
    
    <content type="html"><![CDATA[<p>从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。</p><p>简单说说现在现在的需求：为了测试数值算法，需将有限元前处理器HyperMesh生成的网格文件按Eureka格式进行转换，网格文件格式已知，目标文件格式已知，那么要做的事情就是把网格文件解析，然后按目标格式存储即可实现目标，这是一般的做法。</p><p>如果以后换了一种格式，那么可能又要重新写过转换程序了，并没有通用性。能想到的解决方法，自然是设计一个类，这个类和输出什么格式没有任何关系，这个类只是单纯的将网格文件的所有有效数据（例如：nodes、elements、sets等等）保存在类中，用户只需要直接引用或继承这个类，就可以访问到所有的网格数据，进而根据自己的需求输出想要的格式。</p><p>这样的思路，其实是数据解析、数据存储（类来保存）、数据重组（用户自定义）的过程，由于输出不是这个类考虑的，而是由用户来决定，因此有了通用性。</p><p>在设计这个类的时候遇到了几个问题，下面说说：</p><h3 id="一-将成员变量声明为private"><a href="#一-将成员变量声明为private" class="headerlink" title="一. 将成员变量声明为private"></a>一. 将成员变量声明为private</h3><p>最开始我是用public的，简单嘛，这也是我一直以来的做法，[Li Bo][2] 老师看了之后提出了修改要求，作为一个完善、安全、高效的类，必须把成员变量声明为私有类型，即private，如果你没有用过，你就一直没有概念，我就是这样，于是我找了《C++ Primer》和《Effective C++》相关的内容补充了一下概念，最重要的是封装性。</p><p><strong>封装性</strong></p><p>成员变量声明为private后，只能通过成员函数进行访问，因此如果以后对成员变量有改动，例如以某个计算替换这个成员变量或者是其他的一些改动，使用这个类的用户并不知道，也不会受到影响，顶多重新编译一下。</p><p>将成员变量声明为private后就对使用这个类的用户隐藏了成员变量，即封装，这样便确保了class的约束条件总是会获得维护，因为只有成员函数可以影响它们，并且保留了日后变更实现的权利。如果不隐藏它们，我们很快会发现，即使拥有class原始代码，改变任何public事物的能力还是极端受到束缚，因为那会破坏太多的用户代码。public意味着不封装，不封装意味着不可改变，特别是对被广泛使用的classes而言。</p><p>假设我们有一个public成员变量，而我们修改甚至最终取消了它，那么多少代码会被破坏呢？取决于该class被使用的范围，如果就你自己用，可能修改代码的工作量是可以接受的，如果有更多一些人用，那么被破坏的代码就是一个未知量，往往是很大的。</p><p>一旦你将一个成员变量声明为public而用户开始使用它，就很难改变那个成员变量涉及的一切，太多的代码需要重写、重新测试、重新编写文档和重新编译，可见在一个类的设计之初，考虑周全是多么的重要。</p><p>除了public类型之外，protected类型同样也存在封装问题（此处不展开），因此从封装的角度，就只有两种访问权限：<strong>private提供封装</strong> 和 <strong>其他不提供封装</strong>。</p><p>上述封装讨论源自参考文献[1]并结合我的理解。</p><h3 id="二-将访问private成员变量的成员函数定义为“返回const引用类型”"><a href="#二-将访问private成员变量的成员函数定义为“返回const引用类型”" class="headerlink" title="二. 将访问private成员变量的成员函数定义为“返回const引用类型”"></a>二. 将访问private成员变量的成员函数定义为“返回const引用类型”</h3><p>前面讲到了将成员变量声明为private，通过提供成员函数来访问这些private变量。那么现在就有一个问题，这些成员函数怎么设计才合适呢？基于本文的目的是想将这个class设计成适用于各种有限元计算，这个类只要将Hypermesh网格文件作为输入，这个类便完全提取并保存了数据，这些数据可以直接被用户在各自的有限元计算代码中调用，也可以按用户的指定的格式输出。对于第一种直接应用的情况，由于网格数量巨大，计算过程中有大数量级的数据操作，因此我们需要从成员函数访问private变量的效率方面进行考虑。</p><p><font color="red"><strong>首先说说引用类型</strong><font></font></font></p><p>“引用类型”（reference type）是C++的一种<strong>变量类型</strong>，它的作用是为变量起一个别名。<br>假如有一个变量a，想给它起一个别名，可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure></p><p>这就表明了b是a的“引用”，即a的别名。经过这样的声明，使用a或b的作用相同，都代表同一变量。在上述引用中，&amp;是“引用声明符”，并不代表地址，可以这样理解：在这里int&amp;是一种变量类型，它和int、double、string一样，都是一种变量的类型。不要理解为“把a的值赋给b的地址”。</p><p><font color="red"><strong>其次说说函数返回值</strong><font></font></font></p><p>在这里主要讨论返回值的类型为：引用类型和非引用类型</p><p>函数返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值拷贝给临时对象，这样的话，每调用一次该函数就会得到一个新的拷贝值。因此如果我们设计的成员函数，获得的是private变量的一个拷贝，那么在大数级量的操作中就会消耗不可估量的内存，因此对于这种问题，需要我们的成员函数获得的是private变量的一个引用，由于计算过程中的调用，并没有拷贝变量，而是直接引用原对象，因此能节约内存同时不需要拷贝也提高了效率。</p><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; AskElementData(<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3);</span><br><span class="line"></span><br><span class="line">上面复杂的函数其实是以下这个形式：</span><br><span class="line"></span><br><span class="line"><span class="function">type&amp; <span class="title">FunctionName</span><span class="params">(type&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>type&amp; FunctionName()</strong>即代表，函数返回的是引用类型，这样，成员函数返回的则是引用。</p><p><font color="red"><strong>然后说说返回const引用类型</strong><font></font></font></p><p>试想，类中保存着诸多的数据，单元节点、节点坐标等，由于我们提供的成员函数是对原private变量的直接引用，用户对该引用的任何修改都是直接对原变量的修改，这样会导致数据的不安全，即便一般情况下用户不会主动去修改原始数据，但是不排除误操作的情况，从数据安全角度，应该从类的设计上杜绝这种修改的可能性，而不是靠用户的自律性来维护。<strong>在这里突然很想说个个人观点，一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。</strong>只是突然想到的。回归正题，那么const关键字则提供了这样的功能，const类型的引用，既避免了复制的低效高耗操作又能防止用户直接对引用变量进行修改的可能，多么好，是吧。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line"><span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>接下来谈谈对type&amp; functionName(type&amp;)中形参type&amp;的困惑</strong><font></font></font></p><p>由于我之前的编程经验都是野路子，并没有太多系统的知识，在明白了<strong>const type&amp; functionName()</strong>之后，还有一个困惑，那就是为什么函数的形参中需要一个引用类型的参数<strong>(type&amp;)</strong>呢？</p><p>这还得从返回的变量说起，如果我们的成员函数定义的是返回非引用类型，那么它是可以返回局部变量的，因为返回非引用类型，返回的是原变量的一个拷贝值，所以，当成员函数执行完毕，在它函数体内定义的局部变量虽然被销毁，但是返回的是该局部变量的一个拷贝值，这个拷贝值独立于原变量，所以这样用是没有问题的。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; tria3; <span class="comment">// 局部变量</span></span><br><span class="line">tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line"><span class="keyword">return</span> tria3; </span><br><span class="line"><span class="comment">// 返回的是tria3的一个拷贝，所以当AskElementData()执行完毕，</span></span><br><span class="line"><span class="comment">// tria3被销毁，AskElementData()返回的拷贝值是依然存在可用的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们定义的成员函数是返回引用类型，当成员函数执行完毕时，将释放分配给局部变量的存储空间，此时对局部变量的引用就会指向不确定的内存，返回指向局部变量的指针也是一样的，当函数结束时，局部变量被释放，返回的指针就变成了不再存在的变量的悬垂指针。</p><p>例如下面这种做法是错误的：返回局部变量的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; element_tria3; <span class="comment">// 局部变量</span></span><br><span class="line">tria3 = element_tria3; <span class="comment">// 对局部变量的引用</span></span><br><span class="line"><span class="keyword">return</span> tria3; <span class="comment">// 返回的是对局部变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么就明确了，如果你的成员函数要返回的是对变量的引用，那么它不可以是局部变量。</strong></p><p><strong>而，返回非局部变量的引用时，要求在函数的形参中，包含有以引用方式或指针方式存在的，需要被返回的参数。</strong></p><p>例如我们现在所讨论的类中的private成员变量，下面的做法也是错误的，因为它的形参中没有提供以引用方式或指针方式存在的，需要被返回的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3 = _element_tria3; <span class="comment">// 对private变量的引用</span></span><br><span class="line"><span class="keyword">return</span> tria3; <span class="comment">// 引用类型变量tria3是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的用法应该是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3) <span class="comment">// 提供一个引用方式存在的需要返回的参数</span></span><br><span class="line">&#123;</span><br><span class="line">tria3 = _element_tria3;</span><br><span class="line"><span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>最后总结一下</strong><font></font></font></p><p>根据前面的需求分析，本文设计的类需要：</p><ul><li>类的成员变量为私有类型private</li><li>用来访问private成员变量的是返回const引用类型的成员函数</li></ul><p>所以最后采用的是下面这个形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">tria3 = _element_tria3;</span><br><span class="line"><span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> type&amp; <span class="title">FunctionName</span><span class="params">(type&amp; xx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">xx = privateObject;</span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于这方面的总结大概就是这些了，日后若有进一步的理解再进行补充。<br>以上内容皆为个人理解，有错之处欢迎斧正和讨论。</p><p>2016年1月21日03:23:06<br>于克利夫兰</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 《Effective C++》第三版，条款22。<br>[2]: <a href="http://engineering.case.edu/emae/Faculty/Bo_Li" target="_blank" rel="noopener">http://engineering.case.edu/emae/Faculty/Bo_Li</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。&lt;/p&gt;
&lt;p&gt;简单说说现在现在的需求：为
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://liaohuming.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>就像一个被抛弃的孩子一样无助</title>
    <link href="http://liaohuming.com/2012/08/06/diary/20120806-%E5%B0%B1%E5%83%8F%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%8A%9B%E5%BC%83%E7%9A%84%E5%AD%A9%E5%AD%90%E4%B8%80%E6%A0%B7%E6%97%A0%E5%8A%A9/"/>
    <id>http://liaohuming.com/2012/08/06/diary/20120806-就像一个被抛弃的孩子一样无助/</id>
    <published>2012-08-06T11:49:48.000Z</published>
    <updated>2018-03-03T04:01:11.457Z</updated>
    
    <content type="html"><![CDATA[<p>去年的时候，一个老同学好朋友，向我买淘宝账号，说想开个小店。</p><p>自从上研后，我便不再繁于业务，虽是不再用了，但是这相伴我多年的账号，这许些年的生活费都是它卖力挣得，这即是另一个我。我断然是不会卖的，只是老朋友开口，又不好拒绝，于是就提出借用，并叮嘱一定好生照顾好这个账号。</p><p>只要想起来时就会去点击收藏夹中店铺的网址。就看看。<br>这种感觉就好像，每次回乡，心底里希望家乡的面貌越变越美好。</p><p>可是，说过的小店，从没成功出现过，隐约记得有过几个出售的商品，破烂不堪。<br>并不是卖的东西不好，只是一眼就可以令人看出，这是一个没有用心做事的人。<br>我想，也许，还不熟悉吧。</p><p>后来，点击网址，已是什么都没有了。<br>再后来，收到哥哥的电话，问我的号是不是被盗了，一直给他发不良信息。</p><p>当即，我便测试了账号，已是被锁定了，而据上次正常登陆时间也是大半年之前，近期被盗被用于群发广告。<br>想必老同学已是非常久都没登过了。</p><p>打了个电话过去，问是否还在用，却回答说，一直都在用，前几天都还在传东西上去。<br>我说号被盗了，很久都没有登陆过了。<br>于是改口说，上个月还用过。<br>我说你还要用就用吧，被盗了，你先把号找回来吧，别一直发骗人的信息。<br>好好好。</p><p>好多天，过去了，好好好，也不见动静。<br>见你于如此水深火热，我还指望着他人。<br>突然对自己的愚蠢感到无尽的愤怒。<br>通过与客服的各种验证，终于要回了账号。</p><p>这一登陆，已是面目全非，所有分组下的好友显示名，都被程序加上数字编号，用于群发信息。<br>看着一个个熟悉的id，竟然都成了这样，心痛不已。</p><p>我曾经是那么的爱惜你，多少次追着那些愚蠢的买家解释，各种赔偿，只为保持住你100%的好评。<br>而如今我却将你抛弃，我不曾想到这是让你过起了有后妈的日子，我更不曾想到，会是这么糟蹋你。</p><p>我把一切信息都修改回我自己的信息。<br>对不起，我让你这么长一段时间，像一个被抛弃的孩子一样无助。</p><p>如果觉得自己坦诚相待是没有错的，那么也不要觉得别人占有欲太强也是有错的。<br>如果觉得自己善始善终是没有错的，那么别人就是做事有头无尾就有错吗？</p><p>老同学还是老同学，好朋友还是好朋友。<br>对自己有意义的东西，不见得对别人就有。<br>正确的处事方式，不见得别人就认同。</p><p>自己能做到的事，每次都做到即可，也不能强求别人就一定也要这么做。</p><p>无论如何，将心爱的东西借给别人，而遭受迫害。<br>罪魁祸首都应该是自己。</p><p>只是，如果是我借到了朋友心爱的东西，我想我会倍加珍爱的。<br>没有什么是不可以拒绝的，该拒绝的就拒绝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年的时候，一个老同学好朋友，向我买淘宝账号，说想开个小店。&lt;/p&gt;
&lt;p&gt;自从上研后，我便不再繁于业务，虽是不再用了，但是这相伴我多年的账号，这许些年的生活费都是它卖力挣得，这即是另一个我。我断然是不会卖的，只是老朋友开口，又不好拒绝，于是就提出借用，并叮嘱一定好生照顾好
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>愿今天的傻逼会成为明日的弥足珍贵</title>
    <link href="http://liaohuming.com/2012/04/16/diary/20120416-%E6%84%BF%E4%BB%8A%E5%A4%A9%E7%9A%84%E5%82%BB%E9%80%BC%E4%BC%9A%E6%88%90%E4%B8%BA%E6%98%8E%E6%97%A5%E7%9A%84%E5%BC%A5%E8%B6%B3%E7%8F%8D%E8%B4%B5/"/>
    <id>http://liaohuming.com/2012/04/16/diary/20120416-愿今天的傻逼会成为明日的弥足珍贵/</id>
    <published>2012-04-16T09:58:58.000Z</published>
    <updated>2016-07-28T02:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周六，秋嫂考研成功宴请在京人士，秋哥也终有闲暇，给我过起生日来了，众人大喜，豪饮醉归。<br>第二天醒来，头晕脑胀，不知昨夜如何归来，只觉饥肠辘辘，于是三步并作两步走，于路就近找了些东西填肚子。</p><p>吃完饭，想起昨夜是骑单车去赴宴的，现在它却不知在何处了，一时情感泛滥，内心愧疚无限。<br>于是信步来到东北虎菜馆，看看小车尚在否，放眼扫去，目及之处，并无你的身影。<br>于是又来到教学区北门看了看，亦不在此，无奈醉意未退，头晕的很，拖着疲惫的身子便回去了。</p><p>晚上吃饭的时候，秋哥说，明天你去买车，买过一辆新的。<br>我却没有萌生这样的想法，倒是不缺这三五百块钱。<br>总是觉着，事情不该是这样的，甚至我都还没搞明白是被偷了还是被我遗失在哪个角落了。<br>我要找到你，即便最后没有结果，我也要让自己内心拥有一份曾经努力过的平静。</p><p>新欢有的仅仅是欢，旧爱虽旧却是爱。</p><p>于是中午又来到东北虎菜馆，此次甚为仔细，盯着每辆车子看，都觉得像，如果车子是人，我敢保证其中的一些都被我盯得不好意思了。<br>可却是没有你。</p><p>我想想，还会在哪呢？就还剩东南门的车棚和教学区小南门没去了。<br>我纵身越过天桥楼梯的栅栏，跳上天桥楼梯，快速穿过天桥，来到东南门车棚。</p><p>眼前一亮，眼前又一亮，终究不是。</p><p>拖着疲惫的脚步，沿着北航新建的还未命名的艺术馆走着，懒懒的看着楼前破旧的车子。<br>看看你们失魂落魄的样子吧，想必你们也是被主人抛弃了。</p><p>看着路上匆匆行人，感受头上灼灼烈日，突然一种孤独寂寞冷涌上心头。<br>心里不禁害臊想到，找一辆单车至于弄得像找情人似的落魄么。</p><p>在逸夫楼前，我说，算了吧，回去。<br>可脚步却迈向了最后一个未去的地方。</p><p>现实版的众里寻你千百度，走着看着，终见你在小南门栅栏停车处。<br>再见到暖暖阳光下灰头土脸的你，安静如斯。<br>此刻，不是拥有新欢的激动和快乐，而是找回旧爱的平静和踏实。</p><p>你是否曾埋怨过我，骑在你身上这么多年，只一个晚上工夫就把你抛弃了呢？<br>呵，这么形容有点花花公子无情郎的味道。我想我不是，所以我出现了。</p><p>还记得有多少次，你在努力的最后时刻因为没有坚持下去而放弃了？<br>还记得有多少人，你在懵懵懂懂间就莫名其妙的不欢而散了呢？</p><p>也许，只要再多坚持一会，就成功了。<br>也许，只要一回头，就会发现，其实那人一直都在，从未走远。</p><p>在哪里跌倒的在哪里爬起来，在哪里失去的在哪里找寻回来。<br>愿今天的傻逼会成为明日的弥足珍贵。</p><p><img src="/img/愿今天的傻逼会成为明日的弥足珍贵.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周六，秋嫂考研成功宴请在京人士，秋哥也终有闲暇，给我过起生日来了，众人大喜，豪饮醉归。&lt;br&gt;第二天醒来，头晕脑胀，不知昨夜如何归来，只觉饥肠辘辘，于是三步并作两步走，于路就近找了些东西填肚子。&lt;/p&gt;
&lt;p&gt;吃完饭，想起昨夜是骑单车去赴宴的，现在它却不知在何处了，一时情
      
    
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>UG二次开发环境配置、UG版本、外部模式等问题及实例</title>
    <link href="http://liaohuming.com/2011/03/24/notes/20110324-UG%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%81UG%E7%89%88%E6%9C%AC%E3%80%81%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%AD%89%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AE%9E%E4%BE%8B/"/>
    <id>http://liaohuming.com/2011/03/24/notes/20110324-UG二次开发中开发环境配置、UG版本、外部程序运行等问题及实例/</id>
    <published>2011-03-24T07:40:47.000Z</published>
    <updated>2016-07-28T02:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天花一些时间把UG二次开发中较常遇到两个问题做一个简单的说明以供参考：</p><ul><li>UG二次开发中x86和x64版本问题</li><li>程序运行时缺失libufun.lib等库文件的问题</li></ul><p>并对如何配置开发环境进行说明，最后给出一个实例及演示视频：</p><ul><li>如何配置UG二次开发环境？</li><li>实例及视频演示</li></ul><hr><p><font color="red"><strong>(1) UG二次开发中x86和x64版本问题</strong><font></font></font></p><p>做UG二次开发时，版本问题一定要有清晰的概念，电脑分为x86（32位）和x64（64位）。UG软件的版本也有x86和x64之分。x86的UG，对应的是x86的支持库文件lib x86，x64的UG对应的支持库文件lib x64。</p><p>那么好了，x86的电脑只能安装x86的UG软件，一般在这样的环境下进行二次开发不会有太大的问题。</p><p>而x64的电脑，可以安装x64也可以安装x86的UG软件，这个时候，如果你要生成的x64的UG软件可以用的二次开发程序，你电脑里安装的UG得是x64的版本，这样在编译时候，用到的lib x64的库文件，因此你生成的dll或者exe可以在x64版本的UG中使用。</p><p>同理，如果要使生成的dll或者exe可以在x86的UG版本中使用，那么编译代码的时候提供的库文件得是x86版本的lib。</p><p>这些lib里包含了UG OpenAPI的实现，不同版本的会有不同，所以需要确保对应关系，方能确保程序正确运行。</p><p>小结：</p><p>x86 UG → x86 lib → 生成的dll或者exe是x86版本的  → 可以在 x86 UG上运行 → 可以在x86或者x64的电脑系统上运行</p><p>x64 UG → x64 lib → 生成的dll或者exe是x64版本的  → 可以在 x64 UG上运行 → 只能在x64位的电脑系统上运行</p><hr><p><font color="red"><strong>(2) 程序运行时缺失libufun.lib等库文件的问题</strong><font></font></font></p><p>这个应该是新手常常遇到的问题：在尝试UG的external模式时，遇到这个问题</p><p>具体情况是：对visual studio中的“附加包含目录”与“附加依赖性”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">附加包含目录：$(UGII_BASE_DIR)\ugopen</span><br><span class="line"></span><br><span class="line">附加依赖性：libufun.lib libugopenint.lib</span><br></pre></td></tr></table></figure><p>都做了正确的设置，而且也完全编译成功，但是这个编译成功的exe，运行时却弹出警告窗口，提示：“没有找到libufun.dll,因此这个应用程序未能启动。重新安装应用程序可能会修复此问题”</p><p>这是为什么呢？</p><p>在外部模式下，程序之所以不能运行，是因为缺dll 支持。所以光加了libufun.lib libugopenint.lib没有用，WINDOWS中，lib只是对dll中的接口函数的声明，像目录一样</p><p>外部开发，应该只能在UGII下可以运行，要么就找到libufun.dll和libugopenint.dll所引用的每一个库，也就是说把整个UGII中的文件夹打个包到exe所在的debug目录下。</p><p>目前了解到的解决办法是：</p><ul><li><p>直接将生成的exe文件拷贝到UGII目录下，双击运行，试过了，可以正常运行；</p></li><li><p>将整个UGII中的文件夹打个包到exe目录（没试过）</p></li></ul><p>这里有很好的讨论结果</p><p><a href="http://bbs.icax.org/viewthread.php?tid=145192&amp;extra=&amp;page=1" target="_blank" rel="noopener">http://bbs.icax.org/viewthread.php?tid=145192&amp;extra=&amp;page=1</a></p><p><font color="red"><strong>update：2011-3-28 17:02:22</strong><font></font></font></p><p>其实是少设置了环境变量的缘故</p><p>我的电脑-右键属性-高级-环境变量-系统变量-Path</p><p>添加UGII的路径，比如：D:\Program Files\UGS\NX 7.5\UGII</p><p>设置之后，生成的exe便可成功运行，而不会再提示找不到libufun.dll</p><p>之前上面所述其实道理一样，只是没有从本质上解决问题，通过设置环境变量之后便可不用将生成的exe文件复制到UGII目录下了。</p><p><font color="red"><strong>update：2012-3-12 16:29:39</strong><font></font></font></p><p>设置完Path后需要重启电脑。</p><hr><p><font color="red"><strong>(3) 如何配置UG二次开发环境？</strong><font></font></font></p><p>如何配置UG二次开发环境？下面以UG7.5在visual studio2015下的配置为例进行简单的说明。</p><p>1、设置：UGII_BASE_DIR<br>目的是为UGII目录下的库文件设置一个宏，在Visual Stuido配置附加包含目录的时候直接引用这个宏即可，而不需要在项目解决方案里直接设置软件的安装路径，这样一个好处就是，二次开发程序在不同的电脑里编译的时候，只要在不同的电脑里将宏所对应的路径做修改就可以，而不必去改项目解决方案属性中附加包含目录的值。</p><p>具体设置为：“我的电脑-右键属性-高级-环境变量-系统变量”，新建一个环境变量（一般UG安装的时候已经默认设置好了，如果没有就按此步骤设置）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名：UGII_BASE_DIR</span><br><span class="line"></span><br><span class="line">变量值：C:\Program Files\UGS\NX <span class="number">7.5</span>\UGII</span><br></pre></td></tr></table></figure><p>2、增加：UGII_USER_DIR<br>目的是告诉系统用户开发的程序放在哪里了，系统知道路径后在启动UG的时候会把用户开发的程序也进行加载，这样才能在程序里调用。用户路径需要设置为全英文的（可能新版本的UG已经支持中文了？没有去尝试），该路径下有两个目录<code>startup</code>和<code>application</code>，其中<code>startup</code>用于存放二次开发得到的dll，<code>application</code>用于存放采用UG风格的对话框文件等，一般如果是MFC开发，则只有dll都放<code>startup</code>，定义了这个环境变量后，在UG启动的时候会加载这个目录下的dll和对话框文件，从而使得可以在UG里调用。</p><p>具体设置为：“我的电脑-右键属性-高级-环境变量-系统变量”，新建一个系统变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名：UGII_USER_DIR</span><br><span class="line"></span><br><span class="line">变量值：C:\Users\hxl650\Desktop\UG_workspace</span><br></pre></td></tr></table></figure><p>3、设置：Path<br>这种情况主要是针对在外部模式下，程序不能运行的情况（详见本文的前半段:(2) 程序运行时缺失libufun.lib等库文件的问题）</p><p>4、在Visual studio中设置“附加包含目录”</p><ul><li>项目属性 - C/C++ - 常规 - 附加包含目录 - $(UGII_BASE_DIR)\ugopen</li><li>项目属性 - 链接器 - 常规 - 附加包含目录 - $(UGII_BASE_DIR)\ugopen</li></ul><p><img src="/img/ug1.png" alt="项目属性 - C/C++ - 常规 - 附加包含目录"><br><img src="/img/ug2.png" alt="项目属性 - 链接器 - 常规 - 附加包含目录"></p><p>5、在Visual studio中设置“附加依赖性”</p><ul><li>项目属性 - 链接器 - 输入 - 附加依赖项 - libufun.lib;libugopenint.lib;libnxopencpp.lib;libnxopenuicpp.lib;</li></ul><p><img src="/img/ug3.png" alt="项目属性 - 链接器 - 输入 - 附加依赖项"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前两项：libufun.lib;libugopenint.lib;是UGOPEN的</span><br><span class="line">后两项：libnxopencpp.lib;libnxopenuicpp.lib;是UGNXOPEN的</span><br><span class="line">根据需要自行设置</span><br></pre></td></tr></table></figure><hr><p><font color="red"><strong>(4) 实例及视频演示</strong><font><br><a href="https://github.com/liaohuming/UG-Redevelope-Demo.git" target="_blank" rel="noopener">另有一个简单的视频教程和实例代码，请戳此处前往我的Githup下载。</a></font></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天花一些时间把UG二次开发中较常遇到两个问题做一个简单的说明以供参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UG二次开发中x86和x64版本问题&lt;/li&gt;
&lt;li&gt;程序运行时缺失libufun.lib等库文件的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并对如何配置开发环境进行说明，最后给出
      
    
    </summary>
    
      <category term="笔记" scheme="http://liaohuming.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UG 二次开发" scheme="http://liaohuming.com/tags/UG-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
