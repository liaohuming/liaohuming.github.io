<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="liaohuming.com"><title>我所理解的C++类设计中private成员变量和返回const引用类型 | To Be Better</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">我所理解的C++类设计中private成员变量和返回const引用类型</h1><a id="logo" href="/.">To Be Better</a><p class="description">Keep thinking, and keep writing.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 简历</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">我所理解的C++类设计中private成员变量和返回const引用类型</h1><div class="post-meta">Jan 21, 2016<span> | </span><span class="category"><a href="/categories/笔记/">笔记</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2016/01/21/notes/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/" href="/2016/01/21/notes/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/#disqus_thread"></a><div class="post-content"><p>从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。</p>
<p>简单说说现在现在的需求：为了测试数值算法，需将有限元前处理器HyperMesh生成的网格文件按Eureka格式进行转换，网格文件格式已知，目标文件格式已知，那么要做的事情就是把网格文件解析，然后按目标格式存储即可实现目标，这是一般的做法。</p>
<p>如果以后换了一种格式，那么可能又要重新写过转换程序了，并没有通用性。能想到的解决方法，自然是设计一个类，这个类和输出什么格式没有任何关系，这个类只是单纯的将网格文件的所有有效数据（例如：nodes、elements、sets等等）保存在类中，用户只需要直接引用或继承这个类，就可以访问到所有的网格数据，进而根据自己的需求输出想要的格式。</p>
<p>这样的思路，其实是数据解析、数据存储（类来保存）、数据重组（用户自定义）的过程，由于输出不是这个类考虑的，而是由用户来决定，因此有了通用性。</p>
<p>在设计这个类的时候遇到了几个问题，下面说说：</p>
<h3 id="一-将成员变量声明为private"><a href="#一-将成员变量声明为private" class="headerlink" title="一. 将成员变量声明为private"></a>一. 将成员变量声明为private</h3><p>最开始我是用public的，简单嘛，这也是我一直以来的做法，[Li Bo][2] 老师看了之后提出了修改要求，作为一个完善、安全、高效的类，必须把成员变量声明为私有类型，即private，如果你没有用过，你就一直没有概念，我就是这样，于是我找了《C++ Primer》和《Effective C++》相关的内容补充了一下概念，最重要的是封装性。</p>
<p><strong>封装性</strong></p>
<p>成员变量声明为private后，只能通过成员函数进行访问，因此如果以后对成员变量有改动，例如以某个计算替换这个成员变量或者是其他的一些改动，使用这个类的用户并不知道，也不会受到影响，顶多重新编译一下。</p>
<p>将成员变量声明为private后就对使用这个类的用户隐藏了成员变量，即封装，这样便确保了class的约束条件总是会获得维护，因为只有成员函数可以影响它们，并且保留了日后变更实现的权利。如果不隐藏它们，我们很快会发现，即使拥有class原始代码，改变任何public事物的能力还是极端受到束缚，因为那会破坏太多的用户代码。public意味着不封装，不封装意味着不可改变，特别是对被广泛使用的classes而言。</p>
<p>假设我们有一个public成员变量，而我们修改甚至最终取消了它，那么多少代码会被破坏呢？取决于该class被使用的范围，如果就你自己用，可能修改代码的工作量是可以接受的，如果有更多一些人用，那么被破坏的代码就是一个未知量，往往是很大的。</p>
<p>一旦你将一个成员变量声明为public而用户开始使用它，就很难改变那个成员变量涉及的一切，太多的代码需要重写、重新测试、重新编写文档和重新编译，可见在一个类的设计之初，考虑周全是多么的重要。</p>
<p>除了public类型之外，protected类型同样也存在封装问题（此处不展开），因此从封装的角度，就只有两种访问权限：<strong>private提供封装</strong> 和 <strong>其他不提供封装</strong>。</p>
<p>上述封装讨论源自参考文献[1]并结合我的理解。</p>
<h3 id="二-将访问private成员变量的成员函数定义为“返回const引用类型”"><a href="#二-将访问private成员变量的成员函数定义为“返回const引用类型”" class="headerlink" title="二. 将访问private成员变量的成员函数定义为“返回const引用类型”"></a>二. 将访问private成员变量的成员函数定义为“返回const引用类型”</h3><p>前面讲到了将成员变量声明为private，通过提供成员函数来访问这些private变量。那么现在就有一个问题，这些成员函数怎么设计才合适呢？基于本文的目的是想将这个class设计成适用于各种有限元计算，这个类只要将Hypermesh网格文件作为输入，这个类便完全提取并保存了数据，这些数据可以直接被用户在各自的有限元计算代码中调用，也可以按用户的指定的格式输出。对于第一种直接应用的情况，由于网格数量巨大，计算过程中有大数量级的数据操作，因此我们需要从成员函数访问private变量的效率方面进行考虑。</p>
<p><font color="red"><strong>首先说说引用类型</strong><font></font></font></p>
<p>“引用类型”（reference type）是C++的一种<strong>变量类型</strong>，它的作用是为变量起一个别名。<br>假如有一个变量a，想给它起一个别名，可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure></p>
<p>这就表明了b是a的“引用”，即a的别名。经过这样的声明，使用a或b的作用相同，都代表同一变量。在上述引用中，&amp;是“引用声明符”，并不代表地址，可以这样理解：在这里int&amp;是一种变量类型，它和int、double、string一样，都是一种变量的类型。不要理解为“把a的值赋给b的地址”。</p>
<p><font color="red"><strong>其次说说函数返回值</strong><font></font></font></p>
<p>在这里主要讨论返回值的类型为：引用类型和非引用类型</p>
<p>函数返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值拷贝给临时对象，这样的话，每调用一次该函数就会得到一个新的拷贝值。因此如果我们设计的成员函数，获得的是private变量的一个拷贝，那么在大数级量的操作中就会消耗不可估量的内存，因此对于这种问题，需要我们的成员函数获得的是private变量的一个引用，由于计算过程中的调用，并没有拷贝变量，而是直接引用原对象，因此能节约内存同时不需要拷贝也提高了效率。</p>
<p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; AskElementData(<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3);</span><br><span class="line"></span><br><span class="line">上面复杂的函数其实是以下这个形式：</span><br><span class="line"></span><br><span class="line"><span class="function">type&amp; <span class="title">FunctionName</span><span class="params">(type&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>type&amp; FunctionName()</strong>即代表，函数返回的是引用类型，这样，成员函数返回的则是引用。</p>
<p><font color="red"><strong>然后说说返回const引用类型</strong><font></font></font></p>
<p>试想，类中保存着诸多的数据，单元节点、节点坐标等，由于我们提供的成员函数是对原private变量的直接引用，用户对该引用的任何修改都是直接对原变量的修改，这样会导致数据的不安全，即便一般情况下用户不会主动去修改原始数据，但是不排除误操作的情况，从数据安全角度，应该从类的设计上杜绝这种修改的可能性，而不是靠用户的自律性来维护。<strong>在这里突然很想说个个人观点，一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。</strong>只是突然想到的。回归正题，那么const关键字则提供了这样的功能，const类型的引用，既避免了复制的低效高耗操作又能防止用户直接对引用变量进行修改的可能，多么好，是吧。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">	tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line">	<span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>接下来谈谈对type&amp; functionName(type&amp;)中形参type&amp;的困惑</strong><font></font></font></p>
<p>由于我之前的编程经验都是野路子，并没有太多系统的知识，在明白了<strong>const type&amp; functionName()</strong>之后，还有一个困惑，那就是为什么函数的形参中需要一个引用类型的参数<strong>(type&amp;)</strong>呢？</p>
<p>这还得从返回的变量说起，如果我们的成员函数定义的是返回非引用类型，那么它是可以返回局部变量的，因为返回非引用类型，返回的是原变量的一个拷贝值，所以，当成员函数执行完毕，在它函数体内定义的局部变量虽然被销毁，但是返回的是该局部变量的一个拷贝值，这个拷贝值独立于原变量，所以这样用是没有问题的。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; tria3; <span class="comment">// 局部变量</span></span><br><span class="line">	tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line">	<span class="keyword">return</span> tria3; </span><br><span class="line">	<span class="comment">// 返回的是tria3的一个拷贝，所以当AskElementData()执行完毕，</span></span><br><span class="line">	<span class="comment">// tria3被销毁，AskElementData()返回的拷贝值是依然存在可用的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果我们定义的成员函数是返回引用类型，当成员函数执行完毕时，将释放分配给局部变量的存储空间，此时对局部变量的引用就会指向不确定的内存，返回指向局部变量的指针也是一样的，当函数结束时，局部变量被释放，返回的指针就变成了不再存在的变量的悬垂指针。</p>
<p>例如下面这种做法是错误的：返回局部变量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; element_tria3; <span class="comment">// 局部变量</span></span><br><span class="line">	tria3 = element_tria3; <span class="comment">// 对局部变量的引用</span></span><br><span class="line">	<span class="keyword">return</span> tria3; <span class="comment">// 返回的是对局部变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那么就明确了，如果你的成员函数要返回的是对变量的引用，那么它不可以是局部变量。</strong></p>
<p><strong>而，返回非局部变量的引用时，要求在函数的形参中，包含有以引用方式或指针方式存在的，需要被返回的参数。</strong></p>
<p>例如我们现在所讨论的类中的private成员变量，下面的做法也是错误的，因为它的形参中没有提供以引用方式或指针方式存在的，需要被返回的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3 = _element_tria3; <span class="comment">// 对private变量的引用</span></span><br><span class="line">	<span class="keyword">return</span> tria3; <span class="comment">// 引用类型变量tria3是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的用法应该是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3) <span class="comment">// 提供一个引用方式存在的需要返回的参数</span></span><br><span class="line">&#123;</span><br><span class="line">	tria3 = _element_tria3;</span><br><span class="line">	<span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>最后总结一下</strong><font></font></font></p>
<p>根据前面的需求分析，本文设计的类需要：</p>
<ul>
<li>类的成员变量为私有类型private</li>
<li>用来访问private成员变量的是返回const引用类型的成员函数</li>
</ul>
<p>所以最后采用的是下面这个形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">	tria3 = _element_tria3;</span><br><span class="line">	<span class="keyword">return</span> tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> type&amp; <span class="title">FunctionName</span><span class="params">(type&amp; xx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	xx = privateObject;</span><br><span class="line">	<span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于这方面的总结大概就是这些了，日后若有进一步的理解再进行补充。<br>以上内容皆为个人理解，有错之处欢迎斧正和讨论。</p>
<p>2016年1月21日03:23:06<br>于克利夫兰</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 《Effective C++》第三版，条款22。<br>[2]: <a href="http://engineering.case.edu/emae/Faculty/Bo_Li" target="_blank" rel="noopener">http://engineering.case.edu/emae/Faculty/Bo_Li</a></p>
</div><div class="tags"><a href="/tags/C/">C++</a></div><div class="post-nav"><a class="pre" href="/2016/02/01/notes/20160201-命令行多参数解析时getopt()函数的使用方法小结/">命令行多参数解析时getopt()函数的使用方法小结</a><a class="next" href="/2016/01/06/diary/20160106-If you never try, you will never know/">If you never try, you will never know.</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'liaohuming';
var disqus_identifier = '2016/01/21/notes/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/';
var disqus_title = '我所理解的C++类设计中private成员变量和返回const引用类型';
var disqus_url = 'http://liaohuming.com/2016/01/21/notes/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//liaohuming.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://liaohuming.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/UG-二次开发/" style="font-size: 15px;">UG 二次开发</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/diary/20180306-大道平直努力向前/">大道平直，努力向前</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/notes/20171212-Linux下安装paraview和totalview日志/">Linux下安装paraview和totalview</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/notes/20170906-Apache安装日志/">Apache安装日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/16/notes/20170516-Linux下安装openmpi/">Linux下安装openmpi</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/15/notes/20170515-Linux下安装mpich/">Linux下安装mpich</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/19/notes/20170419-编程过程中的小错误/">编程过程中的小错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/09/notes/20161209-Red hat 配置/">Red hat 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/02/notes/20160902-Linux常用命令备忘（持续更新）/">Linux常用命令备忘（持续更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/notes/20160822-Linux下批量运行测试算例的简单实现（二）/">Linux下批量运行测试算例的简单实现（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/18/diary/20160818-最近/">最近</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//liaohuming.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://liaohuqiu.net/" title="Srain" target="_blank">Srain</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">To Be Better.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>